## Ресурс крок

Ресурс секції <code>step</code>, який представляє собою інструкцію для виконання утилітою при побудові модуля. Описують операції та бажаний результат. Збірки складаються із кроків.

### Поля ресурсів секції `step`   

| Поле           | Опис                                                             |
|----------------|------------------------------------------------------------------|
| description    | описова інформація для інших розробників                         |
| criterion      | умова використання ресурса (див. [критеріон](Criterion.md))     |
| opts           | додаткові опції можуть передаватися через мапу `opts`            |
| inherit        | наслідування від інших кроків                                    |


### Перелік вбудованих кроків
### Вбудований крок `predefined.delete`  

Призначений для видалення файлів за вказаним шляхом. 

Включає одне поле `filePath`, в якому вказується шлях до файлів, що потрібно видалити.  

#### Приклад ресурсу з кроком `predefined.delete` 

```yaml
step:                                   # Назва секції
  delete.files:                         # Назва кроку
    inherit: predefined.delete          # Наслідування вбудованого кроку видалення файлів
    filePath: path::fileToDelete        # Файл чи директорія 'fileToDelete' в секції 'path'

```

У ресурсі `delete.files`, через [наслідування](Inheritance.md), використовується вбудований крок `predefined.delete`. Крок видаляє файли за шляхом `path::fileToDelete`.

### Вбудований крок `predefined.reflect`  

Крок призначений для виклику [рефлектора](ResourceReflector.md#Ресурс-рефлектор).  

Рефлектори виконують файлові операції над групою файлів. 

Крок включає поля `reflector` для указання ресурса секції `reflector` i поле `verbosity`, яке визначає рівень вербальності виводу консолі, тобто, кількість сервісної інформації при виконанні кроку. Діапазон зміни рівня вербальності можна задати від 0 до 8. 8 - найвищий рівень вербальності.  

#### Приклад ресурсу з кроком `predefined.reflect`

```yaml
step:                                         # Назва секції
  reflect.files:                              # Назва кроку
    inherit: predefined.reflect               # Наслідування вбудованого кроку виклика рефлектора
    reflector: reflector::reflect.some.files  # Виклик рефлектора із секції 'reflector'  
    verbosity: 3                              # Деталізація логу виконання побудови модуля (значення                                             # від 0 до 8)

```

У ресурсі `reflect.files`, через [наслідування](Inheritance.md), використовується вбудований крок `predefined.reflect`. Крок використовує рефлектор `reflect.some.files`. Рівень вербальності виводу - 3.

### Вбудований крок `predefined.js`   

Призначений для виконання JavaScript-файлів під час побудови модуля.  

Крок може використовувати лише експортовані функції і змінні в JS-файлі.  

`predefined.js` включає одне поле з назвою `js`, яке вказує шлях до JS-файла для виконання. 

Оскільки вказане поле унікальне - відсутнє в інших вбудованих кроках, то крок `predefined.js` може бути записаний через неявне наслідування, тобто, з указанням в ресурсі поля `js`.  

#### Приклади ресурсів з кроком `predefined.js`

```yaml
step:                                   # Назва секції
  run.js:                               # Назва кроку
    inherit: predefined.js              # Наслідування вбудованого кроку використання терміналу ОС
    js: path::jsFileToRun               # Шлях до JS-файла в секції 'path'

```

Запис вбудованого кроку `predefined.js` з явним указаннням наслідування в полі `inherit` ресурса `run.js`. Крок виконує файл за указаним шляхом `path::jsFileToRun`.

```yaml
step:                                   
  run.js:                           
    js: path::jsFileToRun               

```

Запис вбудованого кроку `predefined.js` в ресурсі `run.js` з неявним указаннням наслідування - поле `inherit` відсутнє. 

### Вбудований крок `predefined.shell`  

Призначений  для запуску команд в командній оболонці операційної системи.  

Розширює вбудовані можливості утиліти завдяки використанню зовнішніх програм і команд операційної системи.  

Крок `predefined.shell` має поля:
- shell - указується команда для виконання операційною системою;
- currentPath - указується шлях до директорії, в якій команда буде виконана. Якщо поле не вказано, то використовується шлях `predefined.dir`.
- forEachDst - в полі вказується назва рефлектора для указання директорії призначення для файлів, що будуть створені командою. Директорія призначення вибирається з фільтра `dst` рефлектора.
- upToDate - поле, яке встановлює можливість повторного запуску команди над файлами, що не змінились з попередньої побудови. Приймає два значення: `preserve` - не виконувати команду, якщо файли не змінились; `rebuild` - виконувати команду незалежно від змін в файлі. За замовчуванням установлено значення `preserve`. Наприклад, утиліта виконала компіляцію файлів з вихідних, якщо при повторному запуску побудови не відбулось змін в вихідних і скомпілованих файлах, то утиліта не буде виконувати команду компіляції. 

Поле `shell` присутнє тільки в вбудованому кроці `predefined.shell` і, тому, крок може бути записаний через неявне наслідування, тобто, з указанням поля `shell` в ресурсі. При цьому, якщо додаткові поля не вказані, то вони приймають значення за замовчуванням.  

#### Приклади ресурсів з кроком `predefined.shell`

```yaml
step:                                   # Назва секції
  run.command:                          # Назва кроку
    inherit: predefined.shell           # Наслідування вбудованого кроку використання терміналу ОС
    shell: ls -a                        # Команда для вводу в термінал ОС
    currentPath: path::dirToRun         # Вказується директорія в якій виконується файл
    forEachDst : some_reflector         # Рефлектор для команди (необов'язково)
    upToDate : 'preserve'               # Опція - виконувати команду при зміні файлів вибірки

```
Приклад іллюструє використання явного наслідування кроку `predefined.shell` в ресурсі `run.command`. Розшифровується так: виконати команду `ls -a` в директорії за шляхом `path::dirToRun`. Для файлів призначення використати шлях в полі `dst` рефлектора `some_reflector`.   

```yaml
step:                                   
  run.command:                         
    shell: npm install
    currentPath: path::dirToRun         

```

Приклад показує неявне наслідування кроку `predefined.shell` в ресурсі `run.command`. Крок `run.command` виконує команду `npm install` в директорії за шляхом `path::dirToRun`.  

### Вбудований крок `predefined.transpile` 

Призначений для транспіляції `JavaScript` файлів або їх конкатенації. 

Конкатенація - об'єднання групи файлів в один. Транспіляція в утиліті `willbe` - це перетворення вихідних JavaScript файлів в стиснений і перетворений код.  Для вибору режиму перетворення застосовується критеріон `debug`. При значенні `debug : 1` утиліта виконує конкатенацію файлів без їх зміни (оптимізації), при `debug : 0` - виконується транспіляція, утиліта об'єднує і оптимізує код.

Крок `predefined.transpile` має одне поле `reflector` для указання рефлектора за яким буде здійснено перетворення. 

#### Приклад ресурсу з кроком `predefined.transpile`

```yaml
step:                                           # Назва секції
  transpile.files:                              # Назва кроку
    inherit: predefined.transpile               # Наслідування вбудованого кроку об'єднання JS-файлів
    reflector: reflector::reflect.js.files      # Рефлектор для відбору JS-файлів
    criterion: 
      debug : 0

```

Крок `transpile.files` виконує транспіляцію файлів (`debug : 0`) згідно рефлектора `reflect.js.files `. 
В вказуються шляхи для файлів, які будуть скомпоновані і файл, який згенерується. Для цього в рефлекторі вказуйте відповідні фільтри. Наприклад, для при використанні поля `filePath` рефлектора запис може мати вигляд:  

```yaml
  filePath :                                    # Вказується для вибору JS-файлів
    path::filesFrom : '{path::filesTo}/file.js' # Зліва - директорія з якої беруться файли,
                                                # справа - директорія в який буде згенеровано файл і його назва.

```

Тобто, поле `filePath` указує вибрати файли з директорії `filesFrom` i об'єднати їх в файлі `file.js` в директорії `filesTo`.  

### Вбудований крок `predefined.export`  

Призначений для особливого виду побудови модуля - експорту. Результатом побудови є згенеровані `out-will-файл` i, опціонально, архів з експортованими файлами.  

Згенерований `out-will-файл` містить повну інформацію про модуль і експортовані файли, а також збірку, за якою побудовано експорт.  

Крок `predefined.export` має поля:
- export - вказуються шляхи до файлів для експорту; 
- tar - архівування файлів модуля. Поле прийма значення: 1 - архівування включене; 0 - архівування вимкнене. За замовувчуванням значення - 1.

Поле `export` присутнє тільки у вбудованому кроці `predefined.export` і, тому, крок може бути записаний через неявне наслідування, тобто, з указанням поля `export` в ресурсі. При цьому, якщо полe `tar` не вказане, то при виконанні побудови буде створено архів.

#### Приклади ресурсів з кроком `predefined.export`

```yaml
step:                                   # Назва секції
  export.files:                         # Назва кроку
    inherit: predefined.export          # Наслідування вбудованого кроку експорту модуля
    export: path::fileToExport          # Шлях до файлів модуля, що експортуються
    tar: 0                              # Архівування експортованої конфігурації. '1' - ввімкнена,
                                        # '0' - вимкнена. За замовчуванням '1'

```

В кроці `export.files` явно указане наслідування вбудованого кроку `predefined.export`. При виконанні побудови буде експортовано файли за шляхом `path::fileToExport` без створення архіву з файлами.  

```yaml
step:                                   
  export.reflect:                           
    export: reflector::fileToExport          

```

В кроці `export.reflect` експортуються файли, які вибрано з допомогою рефлектора `fileToExport`. Поле `tar` не вказане - буде створено архів.

### Вбудований крок `predefined.view`  

Призначений для відкриття файлів i URI-посилань в програмах для перегляду. 

Крок `predefined.view` використовує програми перегляду, що встановлені в операційній системі за замовчуванням для даного типу файлів. Файли і посилання запускаються з затримкою, яку визначає користувач.     

Крок `predefined.view` має поля:
- filePath - вказується шлях до файлів, що потрібно відкрити;
- delay - затримка перед запуском програми для перегляду, вказується в мс.

#### Приклад ресурсу з кроком `predefined.view`

```yaml
step:                                        # Назва секції
  open.url:                                 # Назва кроку
    inherit: predefined.view                 # Наслідування вбудованого кроку перегляду
    filePath: 'http://google.com'            # URI-посилання
    delay: 10000                              # Затримка запуску файла

```

Після виконання кроку `open.url`, через десять секунд утиліта запустить браузер для відкриття посилання `http://google.com`.

### Вбудовані кроки `submodules.download`, `submodules.update`, `submodules.reload`, `submodules.clean`, `clean`   

#### `submodules.download`

Виконує завантаження віддалених підмодулів указаних в ресурсах секції `submodule`. 

Полів не має і може вказуватись безпосередньо в полі `steps` секції `build`.  

#### `submodules.update`

При наявності нових версій віддалених підмодулів завантажує і встановлює їх. 

Полів не має і може вказуватись безпосередньо в полі `steps` секції `build`. 

#### `submodules.reload`

Виконує перезавантаження статусу підмодулів в утиліті.

Після запуску побудови, утиліта зчитує і записує статус підмодулів. Алгоритм побудови може включати дії над підмодулями, що призведе до зміни їх статусу, а крок `submodules.reload` переписує його для правильного виконання наступних дій.  

Полів не має і може вказуватись безпосередньо в полі `steps` секції `build`. 

#### `submodules.clean`

Виконує повне видалення директорії `.module` з підмодулями. 

Полів не має і може вказуватись безпосередньо в полі `steps` секції `build`. 

#### `clean`

Виконує видалення з модуля тимчасових і згененрованих файлів. До них відносяться: 
- завантажені підмодулі (директорія `./.module`); 
- експортовані `out-will-файл` і архів в директорії `path:out`; 
- `path::temp` директорія.

Полів не має і може вказуватись безпосередньо в полі `steps` секції `build`. 

#### Приклад ресурсу з кроками, що можуть записуватись в секцію `build`

```yaml
build:                                  # Назва секції
  direct.writen:                        # Назва кроку
    steps:                              # Кроки - сценарій збірки
    - submodules.update                 # Вбудовані кроки, що поміщаються в секцію `build`
    - submodules.clean
    - submodules.reload
    - submodules.download               
    - clean                             

```

Вбудовані кроки `submodules.download`, `submodules.update`, `submodules.reload`, `submodules.clean`, `clean` поміщені в один сценарій збірки `direct.writen` так, як вони виконують визначену функцію і не мають додаткових полів. Вказані кроки використовуються згідно призначення збірки окремо.  
Якщо запустити побудову збірки `direct.writen`, то утиліта виконає оновлення (завантаження) віддалених підмодулів в директорії `.module`, видалить їх, оновить статус підмодулів, завантажить кроком `submodules.download`, після чого видалить тимчасові і згенеровані файли кроком `clean`.

### Секція <code>step</code>

Секція містить кроки, які можуть бути застосовані збіркою для побудови модуля. Ресурси секції - кроки - поміщають в сценарії збірок секції <code>build</code> для виконання побудови.  

#### Приклад

```yaml
step  :

  export.proto :
    inherit : predefined.export
    export : path::fileToExport.*
    criterion : 
      debug : 0

  proto.debug :
    inherit : predefined.reflect
    export : path::fileToReflect.*
    criterion : 
      debug : 1
      
```

Приклад секції `step` з кроками `export.proto`, `proto.debug`. Крок `export.proto` виконує експорт файлів якщо в збірці критеріон `debug` має значення `0`, а виконання файлової операції в кроці `proto.debug` виконується з встановленим критеріоном `debug : 1`.
