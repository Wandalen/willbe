( function _FileProvider_test_s_( ) {

'use strict';

if( typeof module !== 'undefined' )
{

  let _ = require( '../../Tools.s' );

  _.include( 'wTesting' );

  require( '../files/UseTop.s' );

  var crypto = require( 'crypto' );
  var waitSync = require( 'wait-sync' );

}

//

var _ = _global_.wTools;
var Parent = wTester;

// --
//
// --

function onSuiteBegin( test )
{
  let context = this;
  let path = context.provider.path;
}

//

function onSuiteEnd()
{
  let path = this.provider.path;
  _.assert( _.strHas( this.suitePath, '.tmp' ) );
  path.pathDirTempClose( this.suitePath );
  this.provider.finit();
  this.system.finit();
}

//

function onRoutineEnd( test )
{
  let context = this;
  let provider = context.provider;
  let system = context.system;
  let path = context.provider.path;
  _.sure( _.arraySetIdentical( _.mapKeys( system.providersWithProtocolMap ), [ 'second', 'current' ] ), test.name, 'has not restored system!' );
}

//
//

function pathFor( filePath )
{
  let path = this.provider.path;
  filePath =  path.join( this.suitePath, filePath );
  return path.normalize( filePath );
}

//

function providerIsInstanceOf( src )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( provider instanceof src )
  return true;

  if( _.FileProvider.System && provider instanceof _.FileProvider.System )
  {
    var routinePath = self.pathFor( 'routinePath' );
    var provider2 = provider.providerForPath( routinePath );
    if( provider2 instanceof src )
    return true;
  }

  return false;
}

//

function softLinkIsSupported()
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( Config.interpreter === 'njs' && typeof process !== undefined )
  if( process.platform === 'win32' )
  {
    var allowed = false;
    var routinePath = self.pathFor( 'softLinkIsSupported' );
    var srcPath = self.pathFor( 'softLinkIsSupported/src' );
    var dstPath = self.pathFor( 'softLinkIsSupported/dst' );

    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );

    try
    {
      provider.softLink({ dstPath, srcPath, throwing : 1, sync : 1 });
      allowed = provider.isSoftLink( dstPath );
    }
    catch( err )
    {
      logger.error( err );
    }

    return allowed;
  }

  return true;
}

// --
// tests
// --

function testDelaySample( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  test.case = 'delay test';

  var con = _.timeOut( 1000 );

  test.identical( 1,1 );

  con.finally( function( ){ logger.log( '1000ms delay' ) } );

  con.finally( _.routineSeal( _,_.timeOut,[ 1000 ] ) );

  con.finally( function( ){ logger.log( '2000ms delay' ) } );

  con.finally( function( ){ test.identical( 1,1 ); } );

  return con;
}

//

function mustNotThrowError( test )
{

  // test.identical( 0,0 );
  //
  // test.case = 'if passes dont appears in output/passed test cases/total counter';
  // test.mustNotThrowError( function()
  // {
  // });
  //
  // test.identical( 0,0 );
  //
  // test.case = 'if not passes then appears in output/total counter';
  // test.mustNotThrowError( function()
  // {
  //   return _.timeOut( 1000,function()
  //   {
  //     throw _.err( 'test' );
  //   });
  //   // throw _.err( 'test' );
  // });
  //
  // test.identical( 0,0 );
  //

  /**/

  test.case = 'mustNotThrowError must return con with message';

  var con = new _.Consequence().take( '123' );
  test.mustNotThrowError( con )
  .ifNoErrorThen( function( got )
  {
    test.identical( got, '123' );
  })

}

//

function readWriteSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = path.normalize( test.context.pathFor( 'written/readWriteSync' ) );
  var got, filePath, readOptions, writeOptions;
  var testData = 'Lorem ipsum dolor sit amet';

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );



  test.case = 'fileRead, invalid path';

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      filePath : 'invalid path',
      sync : 1,
      throwing : 1,
    })
  });

  /**/

  test.mustNotThrowError( function()
  {
    debugger
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'invalid path' ),
      sync : 1,
      throwing : 0,
    });
    test.identical( got, null );
  })

  //

  test.case = 'fileRead, path ways to not a terminal file';
  filePath = test.context.pathFor( 'written/readWriteSync/dir' );
  provider.dirMake( filePath );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      filePath,
      sync : 1,
      throwing : 1,
    })
  });

  /**/

  test.mustNotThrowError( function()
  {
    var got = provider.fileRead
    ({
      filePath,
      sync : 1,
      throwing : 0,
    });
    test.identical( got, null );
  });

  //

  test.case = 'fileRead,simple file read ';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );

  /**/

  // test.shouldThrowErrorSync( function()
  // {
  //   provider.fileRead
  //   ({
  //     filePath,
  //     sync : 1,
  //     encoding : 'utf8',
  //     throwing : 1,
  //   })
  // });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'utf8',
      throwing : 1,
    })
  });
  test.identical( got, testData );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'unknown',
      throwing : 1,
    })
  });

  /**/

  test.mustNotThrowError( function()
  {
    var got = provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'unknown',
      throwing : 0,
    });
    test.identical( got, null );
  });

  //

  test.case = 'fileRead,file read with common encodings';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/file' );

  /**/

  testData = { a : 'abc' };
  provider.fileWrite( filePath, JSON.stringify( testData ) );
  got = provider.fileRead
  ({
    filePath,
    sync : 1,
    encoding : 'json',
    throwing : 1,
  });
  test.identical( got , testData );

  /**/

  var isHd = self.providerIsInstanceOf( _.FileProvider.HardDrive );

  if( isHd )
  testData = 'module.exports = { a : 1 }';
  else
  testData = '1 + 2';

  provider.fileWrite( filePath, testData );
  got = provider.fileRead
  ({
    filePath,
    sync : 1,
    encoding : isHd ? 'js.node' : 'js.structure',
    throwing : 1,
  });

  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( got, { a : 1 } );
  }
  else
  {
    var expected = _.exec
    ({
      code : testData,
      filePath :filePath,
      prependingReturn : 1,
    });
    test.identical( got , expected );
  }

  /**/

  testData = filePath;
  provider.fileWrite( filePath, testData );
  got = provider.fileRead
  ({
    filePath,
    sync : 1,
    encoding : 'original.type',
    throwing : 1,
  });
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.is( _.bufferBytesIs( got ) )
    test.identical( got, _.bufferBytesFrom( BufferNode.from( testData ) ) );
  }
  else
  {
    test.identical( got , testData );
  }

  /**/

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'abcde',
      throwing : 1,
    });
  })

  /**/

  test.mustNotThrowError( () =>
  {
    var got = provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'abcde',
      throwing : 0,
    });
    test.identical( got, null );
  })

  /**/

  test.case = 'encoder not finded';
  var encoding = 'unknown';
  test.identical( provider.fileRead.encoders[ encoding ], undefined );
  // test.identical( provider.fileReadAct.encoders[ encoding ], undefined );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead
    ({
      filePath,
      sync : 1,
      throwing : 1,
      encoding
    });
  });

  //

  if( Config.interpreter === 'njs' )
  {
    test.case = 'other encodings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteSync/file' );
    testData = 'abc';

    provider.fileWrite( filePath, testData );
    got = provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'buffer.node',
      throwing : 1,
    });
    test.is( _.bufferNodeIs( got ) );

    provider.fileWrite( filePath, testData );
    got = provider.fileRead
    ({
      filePath,
      sync : 1,
      encoding : 'buffer.raw',
      throwing : 1,
    });
    test.is( _.bufferRawIs( got ) );
  }

  //

  test.case = 'fileRead,onBegin,onEnd,onError';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';
  function onBegin( err, o )
  {
    provider.fileWrite( filePath, testData );
    if( o )
    got = o;
  }
  function onEnd( err, data )
  {
    got = data;
  }
  function onError( err )
  {
    got = err;
  }

  /*onBegin returningRead 0*/

  got = provider.fileRead
  ({
    sync : 1,
    returningRead : 0,
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin,
    onEnd : null,
    onError : null,
  });
  test.identical( got.result, testData );

  /*onBegin returningRead 1*/

  var got = provider.fileRead
  ({
    sync : 1,
    returningRead : 1,
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin,
    onEnd : null,
    onError : null,
  });
  test.identical( _.objectIs( got ), false );

  /*onEnd returningRead 0*/

  var got = provider.fileRead
  ({
    sync : 1,
    returningRead : 0,
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin : null,
    onEnd,
    onError : null,
  });
  test.identical( got.result, testData );

  /*onEnd returningRead 1*/

  debugger;
  var got = provider.fileRead
  ({
    sync : 1,
    returningRead : 1,
    throwing : 1,
    filePath,
    encoding : 'utf8',
    onBegin : null,
    onEnd,
    onError : null,
  });
  debugger;
  test.identical( got, testData );
  debugger;

  /*onError is no called*/

  debugger;
  test.shouldThrowErrorSync( function()
  {
    var got = provider.fileRead
    ({
      sync : 1,
      returningRead : 0,
      throwing : 1,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  debugger;
  test.identical( _.errIs( got ), true )
  debugger;

  /*onError is no called*/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      sync : 1,
      returningRead : 1,
      throwing : 1,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  test.identical( _.errIs( got ), true );

  /*onError is no called*/

  test.mustNotThrowError( function()
  {
    provider.fileRead
    ({
      sync : 1,
      returningRead : 0,
      throwing : 0,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  test.identical( _.errIs( got ), true );

  /*onError is no called*/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRead
    ({
      sync : 1,
      returningRead : 0,
      throwing : 1,
      filePath : test.context.pathFor( 'invalid path' ),
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
  });
  test.identical( _.errIs( got ), true );

  //fileWrite

  //

  test.case = 'fileWrite, path not exist,default settings';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /* path includes not existing directory */

  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/files/file' );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( self.provider.path.dir( filePath ) );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  //

  test.case = 'fileWrite, path already exist,default settings';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';
  provider.fileWrite( filePath, testData );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /*try rewrite folder*/
  test.shouldThrowErrorSync( function()
  {
    provider.fileWrite( routinePath, testData );
  });

  //

  test.case = 'fileWrite, path already exist';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/readWriteSync/file' );
  testData = 'Lorem ipsum dolor sit amet';
  provider.fileWrite( filePath, testData );

  /**/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    makingDirectory : 1,
    purging : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /**/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    makingDirectory : 0,
    purging : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /**/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    makingDirectory : 0,
    purging : 0,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  //

  test.case = 'fileWrite, path not exist';
  provider.filesDelete( routinePath );
  testData = 'Lorem ipsum dolor sit amet';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );


  /*path includes not existing directory*/

  debugger
  // provider.filesDelete( self.provider.path.dir( filePath ) );
  test.shouldThrowErrorSync( function()
  {
    provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 1,
      makingDirectory : 0,
      purging : 0,
    });
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, null );

  /*file not exist*/

  provider.dirMake( routinePath );
  test.mustNotThrowError( function()
  {
    provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 1,
      makingDirectory : 0,
      purging : 0,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  /*purging non existing filePath*/

  provider.filesDelete( filePath );
  test.mustNotThrowError( function()
  {
    provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 1,
      makingDirectory : 0,
      purging : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  test.identical( got, testData );

  //

  test.case = 'fileWrite, different write modes';
  provider.filesDelete( routinePath );
  testData = 'Lorem ipsum dolor sit amet';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );

  /*rewrite*/

  provider.fileWrite( filePath, ' ' );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'rewrite'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /*prepend*/

  provider.fileWrite( filePath, testData );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'prepend'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData+testData );

  /*append*/

  provider.fileWrite( filePath, testData );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'append'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData+testData );

  //

  test.case = 'fileWrite, any writeMode should create file it not exist';
  provider.filesDelete( routinePath );
  testData = 'Lorem ipsum dolor sit amet';
  filePath = test.context.pathFor( 'written/readWriteSync/file' );

  /*rewrite*/

  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'rewrite'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /*prepend*/

  provider.filesDelete( filePath );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'prepend'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  /*append*/

  provider.filesDelete( filePath );
  provider.fileWrite
  ({
    filePath,
    data : testData,
    sync : 1,
    writeMode : 'append'
  });
  got = provider.fileRead
  ({
    filePath,
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'file' ] );
  test.identical( got, testData );

  //

  var softLinkIsSupported = test.context.softLinkIsSupported();

  //

  if( softLinkIsSupported )
  {
    /* resolvingSoftLink */

    test.case = 'read from soft link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    var got = provider.fileRead( linkPath );
    test.identical( got, data);
    provider.fieldPop( 'resolvingSoftLink', 1 );

    test.case = 'read from soft link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.fileRead( linkPath );
    });
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    provider.fileWrite( linkPath, data + data );
    var got = provider.fileRead( filePath );
    test.identical( got, data + data );
    provider.fieldPop( 'resolvingSoftLink', 1 );

    //

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    provider.fileWrite( linkPath, data + data );
    var got = provider.fileRead( filePath );
    test.identical( got, data );
    var got = provider.fileRead( linkPath );
    test.identical( got, data + data );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    provider.fileWrite
    ({
      filePath : linkPath,
      writeMode : 'append',
      data
    });
    var got = provider.fileRead( filePath );
    test.identical( got, data );
    var got = provider.fileRead( linkPath );
    test.identical( got, data + data );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    provider.fileWrite
    ({
      filePath : linkPath,
      writeMode : 'append',
      encoding : 'original.type',
      data
    });
    var got = provider.fileRead( filePath );
    test.identical( got, data );
    var got = provider.fileRead( linkPath );
    test.identical( got, data + data );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data = _.bufferBytesFrom( 'abc' );
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite
    ({
      filePath,
      encoding : 'original.type',
      data
    });
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    var appendData = 'abc';
    provider.fileWrite
    ({
      filePath : linkPath,
      writeMode : 'append',
      encoding : 'original.type',
      data : appendData
    });
    var got = provider.fileRead({ filePath, encoding : 'original.type' });
    test.identical( got, data );
    var got = provider.fileRead({ filePath : linkPath, encoding : 'original.type' });
    test.is( _.bufferBytesIs( got ) );
    test.identical( got, _.bufferBytesFrom( appendData + appendData ) );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    provider.fileWrite
    ({
      filePath : linkPath,
      writeMode : 'prepend',
      data : '1'
    });
    var got = provider.fileRead( filePath );
    test.identical( got, data );
    var got = provider.fileRead( linkPath );
    test.identical( got, '1' + data );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite( filePath, data );
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    provider.fileWrite
    ({
      filePath : linkPath,
      writeMode : 'prepend',
      encoding : 'original.type',
      data : '1'
    });
    var got = provider.fileRead( filePath );
    test.identical( got, data );
    var got = provider.fileRead( linkPath );
    test.identical( got, '1' + data );
    provider.fieldPop( 'resolvingSoftLink', 0 );

    test.case = 'write using link, resolvingSoftLink off';
    var data = _.bufferBytesFrom( 'abc' );
    provider.fieldPush( 'resolvingSoftLink', 0 );
    provider.fileWrite
    ({
      filePath,
      encoding : 'original.type',
      data
    });
    var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
    provider.softLink( linkPath, filePath );
    var appendData = 'abc';
    provider.fileWrite
    ({
      filePath : linkPath,
      writeMode : 'prepend',
      encoding : 'original.type',
      data : appendData
    });
    var got = provider.fileRead({ filePath, encoding : 'original.type' });
    test.identical( got, data );
    var got = provider.fileRead({ filePath : linkPath, encoding : 'original.type' });
    test.is( _.bufferBytesIs( got ) );
    test.identical( got, _.bufferBytesFrom( appendData + appendData ) );
    provider.fieldPop( 'resolvingSoftLink', 0 );

  }

  //

  if( Config.interpreter === 'njs' )
  {
    test.case = 'fileWrite, data is raw buffer';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    var buffer = _.bufferRawFrom( BufferNode.from( testData ) );
    filePath = test.context.pathFor( 'written/readWriteSync/file' );

    /**/

    provider.fileWrite( filePath,buffer );
    got = provider.fileRead
    ({
     filePath,
     sync : 1,
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );

    if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    {
      test.case = 'typed buffer'
      buffer = new U16x( buffer );
      provider.fileWrite( filePath,buffer );
      got = provider.fileRead
      ({
       filePath,
       sync : 1,
      });
      test.identical( got, testData );

      test.case = 'node buffer'
      buffer = BufferNode.from( testData );
      provider.fileWrite( filePath,buffer );
      got = provider.fileRead
      ({
       filePath,
       sync : 1,
      });
      test.identical( got, testData );

      if( softLinkIsSupported )
      {
        test.case = 'write using link, resolvingSoftLink off';
        var data = 'data';
        provider.fieldPush( 'resolvingSoftLink', 0 );
        provider.fileWrite( filePath, data );
        var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
        provider.softLink( linkPath, filePath );
        provider.fileWrite
        ({
           filePath : linkPath,
           writeMode : 'prepend',
           data : BufferNode.from( data )
        });
        var got = provider.fileRead( filePath );
        test.identical( got, data );
        var got = provider.fileRead( linkPath );
        test.identical( got, data + data );
        provider.fieldPop( 'resolvingSoftLink', 0 );

        test.case = 'write using link, resolvingSoftLink off';
        var data = 'data';
        provider.fieldPush( 'resolvingSoftLink', 0 );
        provider.fileWrite( filePath, data );
        var linkPath = test.context.pathFor( 'written/readWriteSync/link' );
        provider.softLink( linkPath, filePath );
        provider.fileWrite
        ({
           filePath : linkPath,
           writeMode : 'prepend',
           data : BufferNode.from( data ),
           encoding : 'original.type'
        });
        var got = provider.fileRead( filePath );
        test.identical( got, data );
        var got = provider.fileRead( linkPath );
        test.identical( got, data + data );
        provider.fieldPop( 'resolvingSoftLink', 0 );
      }
    }
  }

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    var data = 'data';

    provider.fieldPush( 'safe', 0 );


    /* hardLink */

    // var resolvingHardLink = provider.resolvingHardLink;

    /* resolving on */

    // provider.fieldPush( 'resolvingHardLink', 1 );

    // test.case = 'read, hardLink to file that not exist';
    // var linkPath = '/linkToUnknown';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );

    // test.case = 'write+read, hardLink to file that not exist';
    // var linkPath = '/linkToUnknown';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath, data ) );
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );

    // test.case = 'update file using hardLink, then read';
    // var linkPath = '/linkToTerminal';
    // var filePath = '/file';
    // provider.fileWrite( linkPath, data );
    // var got = provider.fileRead( filePath );
    // test.identical( got, data );

    // test.case = 'update file, then read it using hardLink';
    // var linkPath = '/linkToTerminal';
    // var filePath = '/file';
    // provider.fileWrite( filePath, data + data );
    // var got = provider.fileRead( linkPath );
    // test.identical( got, data + data );

    // test.case = 'hardLink to directory, read+write';
    // var linkPath = '/linkToDir';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath, data ) );

    /* resolving off */

    // provider.fieldPush( 'resolvingHardLink', 0 );

    // test.case = 'resolving disabled, read using hardLink';
    // var linkPath = '/linkToTerminal';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );

    // test.case = 'resolving disabled, write using hardLink, link becomes usual file';
    // var linkPath = '/linkToTerminal';
    // provider.fileWrite( linkPath, data );
    // var got = provider.fileRead( linkPath );
    // test.identical( got, data );
    // test.is( !provider.isHardLink( linkPath ) );

    //

    // provider.fieldPop( 'resolvingHardLink', 0 );

    /* softLink */

    var resolvingSoftLink = provider.resolvingSoftLink;

    /* resolving on */

    provider.fieldPush( 'resolvingSoftLink', 1 );

    test.case = 'read, softLink to file that not exist';
    var linkPath = '/softLinkToUnknown';
    var filePath = '/unknown';
    // provider.filesDelete( filePath );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );

    test.case = 'write+read, softLink to file that not exist';
    var linkPath = '/softLinkToUnknown';
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath, data ) );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );

    test.case = 'update file using softLink, then read';
    var linkPath = '/softLinkToFile';
    var filePath = '/file';
    provider.fileWrite( filePath, '' );
    provider.softLink( linkPath, filePath )
    provider.fileWrite( linkPath, data );
    var got = provider.fileRead( filePath );
    test.identical( got, data );

    test.case = 'update file, then read it using softLink';
    var linkPath = '/softLinkToFile';
    var filePath = '/file';
    provider.fileWrite( filePath, data + data );
    var got = provider.fileRead( linkPath );
    test.identical( got, data + data );

    test.case = 'softLink to directory, read+write';
    var filePath = '/dir';
    var linkPath = '/softLinkToDir';
    provider.dirMake( filePath );
    provider.softLink( linkPath, filePath );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );
    test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath, data ) );

    test.case = 'softLink to file, file renamed';
    var linkPath = '/softLinkToFile';
    var filePath = '/file';
    var filePathNew = '/file_new';
    provider.fileWrite( filePath, filePath );
    provider.softLink( linkPath, filePath );
    provider.fileRename( filePathNew, filePath );
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );
    // test.shouldThrowErrorOfAnyKind( () => provider.fileWrite( linkPath, data ) );
    provider.fileRename( filePath, filePathNew );


    /* resolving off */

    provider.fieldPush( 'resolvingSoftLink', 0 );

    test.case = 'resolving disabled, read using softLink';
    var linkPath = '/softLinkToFile';
    test.shouldThrowErrorOfAnyKind( () => provider.fileRead( linkPath ) );

    test.case = 'resolving disabled, write using softLink, link becomes usual file';
    var linkPath = '/softLinkToFile';
    provider.fileWrite( linkPath, data );
    var got = provider.fileRead( linkPath );
    test.identical( got, data );
    test.is( !provider.isSoftLink( linkPath ) );

    //

    provider.fieldPop( 'resolvingSoftLink', 0 );
    provider.fieldPop( 'safe', 0 );
  }

  //

  // var data1 = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit';
  // provider.fileWrite
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   data : data1,
  //   sync : 1,
  // });
  //
  // test.case = 'single file is written';
  // var files = provider.dirRead( test.context.pathFor( 'written/readWriteSync/' ) );
  // test.identical( files, [ 'test.txt' ] );
  //
  // test.case = 'synchronous, writeMode : rewrite';
  // var got = provider.fileRead
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   sync : 1
  // });
  // var expected = data1;
  // test.identical( got, expected );
  //
  // var data2 = 'LOREM';
  // provider.fileWrite
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   data : data2,
  //   sync : 1,
  //   writeMode : 'append'
  // });
  //
  // test.case = 'single file is written';
  // var files = provider.dirRead( test.context.pathFor( 'written/readWriteSync/' ) );
  // test.identical( files, [ 'test.txt' ] );
  //
  // test.case = 'synchronous, writeMode : append';
  // var got = provider.fileRead
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   sync : 1
  // });
  // var expected = data1 + data2;
  // test.identical( got, expected );
  //
  // var data2 = 'LOREM';
  // provider.fileWrite
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   data : data2,
  //   sync : 1,
  //   writeMode : 'prepend'
  // });
  //
  // test.case = 'single file is written';
  // var files = provider.dirRead( test.context.pathFor( 'written/readWriteSync/' ) );
  // test.identical( files, [ 'test.txt' ] );
  //
  // test.case = 'synchronous, writeMode : prepend';
  // var got = provider.fileRead
  // ({
  //   filePath : test.context.pathFor( 'written/readWriteSync/test.txt' ),
  //   sync : 1
  // });
  // var expected = data2 + data1 + data2;
  // test.identical( got, expected );
  //
  // if( Config.debug )
  // {
  //   test.case = 'file doesn`t exist';
  //   test.shouldThrowErrorSync( function( )
  //   {
  //     provider.fileRead
  //     ({
  //       filePath : test.context.pathFor( 'unknown' ),
  //       sync : 1
  //     });
  //   });
  //
  //   test.case = 'try to read dir';
  //   test.shouldThrowErrorSync( function( )
  //   {
  //     provider.fileRead
  //     ({
  //       filePath : test.context.pathFor( '/' ),
  //       sync : 1
  //     });
  //   });
  // }
}

//

function readWriteAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var softLinkIsSupported = test.context.softLinkIsSupported();
  var routinePath = test.context.pathFor( 'written/readWriteAsync' );
  var got, filePath, readOptions, writeOptions,onBegin,onEnd,onError,buffer;
  var testData = 'Lorem ipsum dolor sit amet';

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );
  consequence

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead, invalid path';
    var con = provider.fileRead
    ({
      filePath : '/invalid path',
      sync : 0,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function()
  {
    var con = provider.fileRead
    ({
      filePath : '/invalid path',
      sync : 0,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) =>
    {
      test.identical( got, null );
      return got;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead, path ways to not a terminal file';
    filePath = test.context.pathFor( 'written/readWriteAsync/dir' );
    provider.dirMake( filePath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function()
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) =>
    {
      test.identical( got, null );
      return got;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead,simple file read ';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    provider.fileWrite( filePath, testData );
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'utf8',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .finally( function( err, got )
    {
      test.identical( got, testData );
      return got;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'unknown',
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function()
  {
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'unknown',
      throwing : 0,
    });
    return test.mustNotThrowError( con );
  })

  //

  .finally( function( err, arg )
  {
    test.case = 'fileRead,file read with common encodings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    testData = { a : 'abc' };
    provider.fileWrite( filePath, JSON.stringify( testData ) );
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'json',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .finally( function( err, got )
    {
      test.identical( got , testData );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    testData = 'module.exports = { a : 1 }';
    else
    testData = '1 + 2';

    provider.fileWrite( filePath, testData );
    var con  = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'js.smart',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      {
        test.identical( got, { a : 1 } );
      }
      else
      {
        var expected = _.exec
        ({
          code : testData,
          filePath :filePath,
          prependingReturn : 1,
        });
        test.identical( got , expected );
      }

      return got;
    });
  })

  //

  .ifNoErrorThen( ( arg ) =>
  {
    testData = filePath;
    provider.fileWrite( filePath, testData );
    var con = provider.fileRead
    ({
      filePath,
      sync : 0,
      encoding : 'original.type',
      throwing : 1,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) =>
    {
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      {
        test.is( _.bufferBytesIs( got ) )
        test.identical( got, _.bufferBytesFrom( BufferNode.from( testData ) ) );
      }
      else
      {
        test.identical( got , testData );
      }

      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileRead,onBegin,onEnd,onError';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    onBegin = function onBegin( err, o )
    {
      provider.fileWrite( filePath, testData );
      if( o )
      got = o;
    }
    onEnd = function onEnd( err, data )
    {
      got = data;
    }
    onError = function onError( err )
    {
      got = err;
    }
    return null;
  })

  /*onBegin returningRead 0*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 0,
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin,
      onEnd : null,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( _.objectIs( got ), true );
      return null;
    });
  })

  /*onBegin returningRead 1*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 1,
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin,
      onEnd : null,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( _.objectIs( got ), true );
      return null;
    });
  })

  /*onEnd returningRead 0*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 0,
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin : null,
      onEnd,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( got.result, testData );
      return null;
    });
  })

  /*onEnd returningRead 1*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 1,
      throwing : 1,
      filePath,
      encoding : 'utf8',
      onBegin : null,
      onEnd,
      onError : null,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( got.result, testData );
      return null;
    });
  })

  /*onError is no called*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 0,
      throwing : 1,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      test.identical( _.errIs( got ), true )
      return null;
    });
  })

  /*onError is no called*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 1,
      throwing : 1,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      test.identical( _.errIs( got ), true );
      return null;
    });
  })

  /*onError is no called*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 0,
      throwing : 0,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      test.identical( _.errIs( got ), true );
      return null;
    });
  })

  /*onError is no called*/
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRead
    ({
      sync : 0,
      returningRead : 0,
      throwing : 1,
      filePath : '/invalid path',
      encoding : 'utf8',
      onBegin : null,
      onEnd : null,
      onError,
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      test.identical( _.errIs( got ), true );
      return null;
    });
  })

  //fileWrite

  .finally( function( err, arg )
  {
    test.case = 'fileWrite, path not exist,default settings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
       sync : 0,
       filePath,
       data : testData,
    })
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );

    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /*path includes not existing directory*/

  .ifNoErrorThen( function( arg )
  {
    filePath = test.context.pathFor( 'written/readWriteAsync/files/file.txt' );
    return provider.fileWrite
    ({
       sync : 0,
       filePath,
       data : testData
    })
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( test.context.pathFor( 'written/readWriteAsync/files' ) );
    test.identical( files, [ 'file.txt' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, path already exist,default settings';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    provider.fileWrite( filePath, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
       sync : 0,
       filePath,
       data : testData
    })
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /*try rewrite folder*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileWrite
    ({
       sync : 0,
       filePath : routinePath,
       data : testData
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, path already exist';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    testData = 'Lorem ipsum dolor sit amet';
    provider.fileWrite( filePath, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 1,
      purging : 1,
    });
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 1,
    });

  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 0,
    });
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, path not exist';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /*path includes not existing directory*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con )
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, null );
    return null;
  })

  /*file not exist*/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( routinePath );
    var con = provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 0,
    });
    return test.mustNotThrowError( con );
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  /*purging non existing filePath*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    var con = provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      makingDirectory : 0,
      purging : 1,
    });
    return test.mustNotThrowError( con );
  })
  .ifNoErrorThen( function( arg )
  {
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    test.identical( got, testData );
    return null;
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, different write modes';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /*rewrite*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'rewrite'
    });

  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /*prepend*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, testData );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'prepend'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData+testData );
    return null;
  })

  /*append*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, testData );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'append'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData+testData );
    return null;
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'fileWrite, any writeMode should create file it not exist';
    provider.filesDelete( routinePath );
    testData = 'Lorem ipsum dolor sit amet';
    filePath = test.context.pathFor( 'written/readWriteAsync/file' );
    return null;
  })

  /*rewrite*/

  .ifNoErrorThen( function( arg )
  {
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'rewrite'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /*prepend*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'prepend'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /*append*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    return provider.fileWrite
    ({
      filePath,
      data : testData,
      sync : 0,
      writeMode : 'append'
    });
  })
  .ifNoErrorThen( function( arg )
  {
    got = provider.fileRead
    ({
      filePath,
      sync : 1
    });
    var files = provider.dirRead( routinePath );
    test.identical( files, [ 'file' ] );
    test.identical( got, testData );
    return null;
  })

  /* resolvingSoftLink */

  .ifNoErrorThen( ( arg ) =>
  {

    if( !softLinkIsSupported )
    return null;

    test.case = 'read from soft link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
      provider.softLink( linkPath, filePath );
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, data );
        provider.fieldPop( 'resolvingSoftLink', 1 );
        return null;

      })
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'read from soft link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
      provider.softLink( linkPath, filePath );
      var con = provider.fileRead({ filePath : linkPath, sync : 0 });
      return test.shouldThrowErrorOfAnyKind( con )
      .finally( () =>
      {
        provider.fieldPop( 'resolvingSoftLink', 0 );
        return null;
      })
    })

  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink on';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
      provider.softLink( linkPath, filePath );
      return provider.fileWrite({ filePath, data : data + data, sync : 0 })
    })
    .finally( () => provider.fileRead({ filePath, sync : 0 }) )
    .finally( ( err, got ) =>
    {
      test.identical( got, data + data );
      provider.fieldPop( 'resolvingSoftLink', 1 );
      return null;
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      provider.softLink( linkPath, filePath );
      return provider.fileWrite({ filePath : linkPath, data : data + data, sync : 0 })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, data );
        return null;
      })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, data + data );
        return null;
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      return true;
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      provider.softLink( linkPath, filePath );
      return provider.fileWrite
      ({
         filePath : linkPath,
         writeMode : 'append',
         sync : 0,
         data
      });
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, data );
        return null;
      })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, data + data );
        return null;
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      return true;
    })
  })

  .ifNoErrorThen( ( arg ) =>
  {
    if( !softLinkIsSupported )
    return null;

    test.case = 'write using link, resolvingSoftLink off';
    var data = 'data';
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var linkPath = test.context.pathFor( 'written/readWriteAsync/link' );
    return provider.fileWrite({ filePath, data, sync : 0 })
    .finally( () =>
    {
      provider.softLink( linkPath, filePath );
      return provider.fileWrite
      ({
         filePath : linkPath,
         writeMode : 'prepend',
         sync : 0,
         data : 'prepend'
      });
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, data );
        return null;
      })
    })
    .finally( () =>
    {
      return provider.fileRead({ filePath : linkPath, sync : 0 })
      .finally( ( err, got ) =>
      {
        test.identical( got, 'prepend' + data );
        return null;
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 )
      return null;
    })

  })



  //

  if( Config.interpreter === 'njs' )
  {
    consequence.ifNoErrorThen( function( arg )
    {
      test.case = 'fileWrite, data is raw buffer';
      provider.filesDelete( routinePath );
      testData = 'Lorem ipsum dolor sit amet';
      buffer = _.bufferRawFrom( BufferNode.from( testData ) );
      filePath = test.context.pathFor( 'written/readWriteAsync/file' );
      return null;
    })

    /**/

    consequence.ifNoErrorThen( function( arg )
    {
      return provider.fileWrite
      ({
        filePath,
        data : buffer,
        sync : 0,
      });
    })
    .ifNoErrorThen( function( arg )
    {
      got = provider.fileRead
      ({
         filePath,
         sync : 1,
      });
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'file' ] );
      test.identical( got, testData );
      return null;
    });

    //

    consequence.ifNoErrorThen( function( arg )
    {
      test.case = 'encoder not finded';
      var encoding = 'unknown';
      test.identical( provider.fileRead.encoders[ encoding ], undefined );
      // test.identical( provider.fileReadAct.encoders[ encoding ], undefined );
      var con = provider.fileRead
      ({
        filePath,
        sync : 0,
        throwing : 1,
        encoding
      });
      return test.shouldThrowErrorOfAnyKind( con );
    })
    .ifNoErrorThen( function( arg )
    {
      test.case = 'other encodings';
      provider.filesDelete( routinePath );
      filePath = test.context.pathFor( 'written/readWriteSync/file' );
      testData = 'abc';
      return null;
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite( filePath, testData );
      return provider.fileRead
      ({
        filePath,
        sync : 0,
        encoding : 'buffer.node',
        throwing : 1,
      })
      .finally( ( err, got ) => test.is( _.bufferNodeIs( got ) ) )
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite( filePath, testData );
      return provider.fileRead
      ({
        filePath,
        sync : 0,
        encoding : 'buffer.raw',
        throwing : 1,
      })
      .finally( ( err, got ) => test.is( _.bufferRawIs( got ) ) )
    })
  }

 return consequence;
}

//

function fileReadJson( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';
  var bufferData1;

  if( Config.interpreter === 'browser' || self.providerIsInstanceOf( _.FileProvider.Extract ))
  bufferData1 = new BufferRaw( 4 );
  else
  bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );


  var dataToJSON1 = [ 1, 'a', { b : 34 } ];
  var dataToJSON2 = { a : 1, b : 's', c : [ 1, 3, 4 ] };

  var testChecks =
  [
    {
      name : 'try to load empty text file as json',
      data : '',
      path : 'fileReadJson/rtext1.txt',
      expected :
      {
        error : true,
        content : void 0
      },
    },
    {
      name : 'try to read non json string as json',
      data : textData1,
      path : 'fileReadJson/text2.txt',
      expected :
      {
        error : true,
        content : void 0
      }
    },
    {
      name : 'try to parse buffer as json',
      data : bufferData1,
      path : 'fileReadJson/data0',
      expected :
      {
        error : true,
        content : void 0
      }
    },
    {
      name : 'read json from file',
      data : dataToJSON1,
      path : 'fileReadJson/jason1.json',
      encoding : 'json',
      expected :
      {
        error : null,
        content : dataToJSON1
      }
    },
    {
      name : 'read json from file 2',
      data : dataToJSON2,
      path : 'fileReadJson/json2.json',
      encoding : 'json',
      expected :
      {
        error : null,
        content : dataToJSON2
      }
    }
  ];

  for( var testCheck of testChecks )
  {
    // join several test aspects together
    var got =
    {
      error : null,
      content : void 0
    };

    let path = test.context.pathFor( testCheck.path );

    if( provider.statResolvedRead( path ) )
    provider.fileDelete( path );

    if( testCheck.encoding === 'json' )
    {
      provider.fileWriteJson( path, testCheck.data );
    }
    else
    {
      provider.fileWrite({ filePath : path, data : testCheck.data })
    }

    try
    {
      got.content = provider.fileReadJson( path );
    }
    catch ( err )
    {
      got.error = true;
    }

    test.identical( got, testCheck.expected );
  }

  //

  if( Config.debug )
  {
    test.case = 'missed arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileReadJson( );
    });

    test.case = 'extra arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileReadJson( 'tmp.tmp/tmp.tmp.json', {} );
    });
  }

};

//

function fileReadWithEncoding( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let filePath = test.context.pathFor( 'written/fileReadWithEncoding/dstFile' );
  let isHd = self.providerIsInstanceOf( _.FileProvider.HardDrive );

  test.open( 'buffer.*' );

  var data = 'abc'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, data );

  //

  var got = provider.fileRead({ filePath, encoding : 'buffer.bytes' });
  test.identical( got, _.bufferBytesFrom( data ) );

  //

  if( isHd )
  {
    var got = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got, _.bufferNodeFrom( data ) )
  }

  //

  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, _.bufferRawFrom( data ) )

  test.close( 'buffer.*' );

  /**/

  test.open( 'json' );

  var data = 'string'
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data, encoding : 'json' });
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, data );

  //

  var data = [ 1,2,3 ];
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data, encoding : 'json' });
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, data );

  //

  var data = '{a : b}';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead({ filePath, encoding : 'json' });
  })

  //

  var data =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  };
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data, encoding : 'json' });
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, data );

  test.close( 'json' );

  /**/

  test.open( 'js' );

  var data  =
  `{
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date( Date.UTC( 2018,1,1 ) ),
    buffer : new U16x([ 1,2,3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }`;
  var expected =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date( Date.UTC( 2018,1,1 ) ),
    buffer : new U16x([ 1,2,3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, expected )

  //

  var data = '{a : b}';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead({ filePath, encoding : 'js.structure' });
  })

  test.close( 'js' );

  /* */

  test.open( 'js.smart' );

  var data = 'return 1';
  if( isHd )
  data = 'module.exports = { data : 1 }'
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data });
  var got = provider.fileRead({ filePath, encoding : 'js.smart' });
  if( isHd )
  test.identical( got, { data : 1 } );
  else
  test.identical( got, 1 );

  //

  var data = '{a : b}';
  var filePath2 = test.context.pathFor( 'written/fileReadWithEncoding/dstFile2' );
  provider.filesDelete( filePath2 );
  provider.fileWrite({ filePath : filePath2, data });
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRead({ filePath : filePath2, encoding : 'js.smart' });
  })

  test.close( 'js.smart' );

  /* */

  if( isHd )
  {
    test.case = 'js.node'
    var data = 'module.exports = { data : 1 }'
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data });
    var got = provider.fileRead({ filePath, encoding : 'js.node' });
    test.identical( got, { data : 1 });

    //

    var data = 'module.exports = { data : 1 '
    var filePath3 = test.context.pathFor( 'written/fileReadWithEncoding/dstFile3' );
    provider.filesDelete( filePath3 );
    provider.fileWrite({ filePath : filePath3, data });
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.fileRead({ filePath : filePath3, encoding : 'js.node' });
    })
  }
}

//

function fileWriteWithEncoding( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let filePath = test.context.pathFor( 'written/fileWriteWithEncoding/dstFile' );
  let isHd = self.providerIsInstanceOf( _.FileProvider.HardDrive );

  /* js */

  var src = '';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src = 'return 1';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src = [ 1, '2', { a : 3 } ];
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src = new Date();
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  var src =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date(),
    buffer : new U16x([ 1,2,3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'js.structure' })
  var got = provider.fileRead({ filePath, encoding : 'js.structure' });
  test.identical( got, src );

  /* json */

  var src = '';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = [ 1, 'a', { b : 34 } ];
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = { a : 1, b : 's', c : [ 1, 3, 4 ] };
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = '{ "a" : "3" }';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, src );

  var src = new Date( Date.UTC( 2018,1,1 ) );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, '2018-02-01T00:00:00.000Z' );

  var src =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : new Date( Date.UTC( 2018,1,1 ) ),
    buffer : new U16x([ 1,2,3 ]),
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  var expected  =
  {
    string : 'string',
    number : 1,
    array : [ 1, 'string' ],
    date : '2018-02-01T00:00:00.000Z' ,
    buffer : { 0 : 1, 1 : 2, 2 : 3 },
    map : { string : 'string', number : 1, array : [ 'string', 1 ] }
  }
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'json.min' })
  var got = provider.fileRead({ filePath, encoding : 'json' });
  test.identical( got, expected );

  /* origignal.type rewrite */

  var src = 'string';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
  var got = provider.fileRead( filePath );
  test.identical( got, src );

  var src = new U8x([ 99,100,101 ]);
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.bytes' });
  test.identical( got, src );

  if( isHd )
  {
    var src = _.bufferNodeFrom( [ 99,100,101 ] )
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
    var got = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got, src );
  }

  var src = new BufferRaw( 3 );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src, encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, src );

  /* original.type append to existing file */

  var src = 'string';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
  var got = provider.fileRead( filePath );
  test.identical( got, src + src );

  var src = new U8x([ 99,100,101 ]);
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'original.type' });
  test.identical( got, _.bufferJoin( src,src ) );

  if( isHd )
  {
    var src = _.bufferNodeFrom( [ 99,100,101 ] )
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : src });
    provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
    var got = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got, _.bufferJoin( src,src ) );
  }

  var src = new BufferRaw( 3 );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'append', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, _.bufferJoin( src,src ) );

  /* original.type prepend to existing file */

  var src = 'string';
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
  var got = provider.fileRead( filePath );
  test.identical( got, src + src );

  var src = new U8x([ 99,100,101 ]);
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'original.type' });
  test.identical( got, _.bufferJoin( src,src ) );

  if( isHd )
  {
    var src = _.bufferNodeFrom( [ 99,100,101 ] )
    provider.filesDelete( filePath );
    provider.fileWrite({ filePath, data : src });
    provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
    var got = provider.fileRead({ filePath, encoding : 'buffer.node' });
    test.identical( got, _.bufferJoin( src,src ) );
  }

  var src = new BufferRaw( 3 );
  provider.filesDelete( filePath );
  provider.fileWrite({ filePath, data : src });
  provider.fileWrite({ filePath, data : src, writeMode : 'prepend', encoding : 'original.type' })
  var got = provider.fileRead({ filePath, encoding : 'buffer.raw' });
  test.identical( got, _.bufferJoin( src,src ) );

};

//

function fileWriteJson( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var defReadOptions =
  {
    encoding : 'utf8'
  };
  var dataToJSON1 = [ 1, 'a', { b : 34 } ];
  var dataToJSON2 = { a : 1, b : 's', c : [ 1, 3, 4 ] };
  var dataToJSON3 = '{ "a" : "3" }';

  var testChecks =
  [
    {
      name : 'write empty JSON string file',
      data : '',
      path : 'fileWriteJson/data1.json',
      expected :
      {
        instance : false,
        content : '',
        exist : true
      },
      readOptions : defReadOptions
    },
    {
      name : 'write array to file',
      data : dataToJSON1,
      path : 'fileWriteJson/data1.json',
      expected :
      {
        instance : false,
        content : dataToJSON1,
        exist : true
      },
      readOptions : defReadOptions
    },
    {
      name : 'write object using options',
      data : dataToJSON2,
      path : 'fileWriteJson/data2.json',
      expected :
      {
        instance : false,
        content : dataToJSON2,
        exist : true
      },
      readOptions : defReadOptions
    },
    {
      name : 'write jason string',
      data : dataToJSON3,
      path : 'fileWriteJson/data3.json',
      expected :
      {
        instance : false,
        content : dataToJSON3,
        exist : true
      },
      readOptions : defReadOptions
    }
  ];


  // regular tests
  for( var testCheck of testChecks )
  {
    // join several test aspects together
    var got =
    {
      instance : null,
      content : null,
      exist : null
    }

    let path = test.context.pathFor( testCheck.path );

    // clear

    if( provider.statResolvedRead( path ) )
    provider.fileDelete( path );

    var con = provider.fileWriteJson( path, testCheck.data );

    // fileWtrite must returns wConsequence
    got.instance = _.consequenceIs( con );

    // recorded file should exists
    got.exist = !!provider.statResolvedRead( path );

    // check content of created file.
    var o = _.mapExtend( null, testCheck.readOptions, { filePath : path } );
    // got.content = JSON.parse( _.fileProvider.fileRead( path, testCheck.readOptions ) );
    got.content = JSON.parse( provider.fileRead( o ) );

    test.case = testCheck.name;
    test.identical( got, testCheck.expected );
  }

  if( Config.debug )
  {
    test.case = 'missed arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( );
    } );

    test.case = 'extra arguments';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( 'temp/sample.txt', { a : 'hello' }, { b : 'world' } );
    } );

    test.case = 'path is not string';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( 3, 'hello' );
    } );

    test.case = 'passed unexpected property in options';
    test.shouldThrowErrorSync( function( )
    {
      provider.fileWriteJson( { filePath : 'temp/some.txt', data : 'hello', parentDir : './work/project' } );
    } );
  }
}

//

function fileTouch( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWriteAct ) || self.providerIsInstanceOf( _.FileProvider.Extract )  )
  {
    test.identical( 1,1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileTouch' );

  provider.filesDelete( routinePath );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var srcPath = path.normalize( test.context.pathFor( 'written/fileTouch/src.txt' ) );
  var testData = 'test';

  //

  test.case = 'filePath doesnt exist'
  // provider.filesDelete( srcPath );
  provider.fileTouch( srcPath );
  var stat = provider.statResolvedRead( srcPath );
  test.is( _.objectIs( stat ) );

  test.case = 'filePath doesnt exist, filePath as record';
  provider.filesDelete( srcPath );
  var record = provider.recordFactory({ allowingMissed : 1 }).record( srcPath );
  test.identical( record.stat, null );
  provider.fileTouch( record );
  var stat = provider.statResolvedRead( srcPath );
  test.is( _.objectIs( stat ) );

  test.case = 'filePath is a directory';
  provider.filesDelete( srcPath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( srcPath ) );

  test.case = 'directory, filePath as record';
  provider.filesDelete( srcPath );
  provider.dirMake( srcPath );
  var record = provider.recordFactory().record( srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( record ) );

  if( Config.debug )
  {
    test.case = 'invalid filePath type'
    test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( 1 ) );

    test.case = 'data option must be undefined'
    test.shouldThrowErrorOfAnyKind( () => provider.fileTouch({ filePath : srcPath, data : testData }) );

    test.case = 'more then one arg'
    test.shouldThrowErrorOfAnyKind( () => provider.fileTouch( srcPath, testData ) );
  }

  var con = new _.Consequence().take( null )

  /**/

  .ifNoErrorThen( ( arg ) =>
  {
    test.case = 'filePath is a terminal';
    provider.filesDelete( srcPath );
    provider.fileWrite( srcPath, testData );
    var statsBefore = provider.statResolvedRead( srcPath );
    return _.timeOut( 1000, () =>
    {
      provider.fileTouch( srcPath );
      var statsAfter = provider.statResolvedRead( srcPath );
      test.identical( statsAfter.size, statsBefore.size );
      test.identical( statsAfter.ino , statsBefore.ino );
      test.is( statsAfter.mtime > statsBefore.mtime );
      test.is( statsAfter.ctime > statsBefore.mtime );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( ( arg ) =>
  {
    test.case = 'terminal, filePath as record';
    provider.filesDelete( srcPath );
    provider.fileWrite( srcPath, testData );
    var record = provider.recordFactory().record( srcPath );
    var statsBefore = record.stat;
    return _.timeOut( 1000, () =>
    {
      provider.fileTouch( record );
      var statsAfter = provider.statResolvedRead( srcPath );
      test.identical( statsAfter.size, statsBefore.size );
      test.identical( statsAfter.ino , statsBefore.ino );
      test.is( statsAfter.mtime > statsBefore.mtime );
      test.is( statsAfter.ctime > statsBefore.mtime );
      return null;
    })
  })

  return con;
}

//

function fileTimeSet( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileTimeSet' );
  let filePath = test.context.pathFor( 'written/fileTimeSet/file' );

  let maxDiff = provider.systemBitrateTimeGet();

  test.case = 'path does not exist';
  provider.filesDelete( filePath );
  var time = _.timeNow();
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet( filePath, time, time ) );

  function testDiff( diff )
  {
    if( !diff )
    test.identical( diff, 0 );
    else
    test.le( diff, maxDiff );
  }

  test.case = 'terminal file';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.fileTimeSet( filePath, time, time );
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.fileTimeSet( routinePath, time, time );
  var stat  = provider.statResolvedRead( routinePath );
  test.is( stat.isDir() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'object, file';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.fileTimeSet({ filePath, atime : time, mtime : time });
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'object, dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  provider.fileTimeSet({ filePath : routinePath, atime : time, mtime : time });
  var stat  = provider.statResolvedRead( routinePath );
  test.is( stat.isDir() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'two args, file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var filePath2 = test.context.pathFor( 'written/fileTimeSet/file2' );
  provider.fileWrite( filePath2, filePath2 );
  var time = new Date();
  provider.fileTimeSet( filePath2, time, time );
  provider.fileTimeSet( filePath, filePath2 );
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'two args, dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var filePath2 = test.context.pathFor( 'written/fileTimeSet/dir' );
  provider.dirMake( filePath2 );
  var time = new Date();
  provider.fileTimeSet( filePath2, time, time );
  provider.fileTimeSet( routinePath, filePath2 );
  var stat  = provider.statResolvedRead( routinePath );
  test.is( stat.isDir() );
  var adiff = time.getTime() - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time.getTime() - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'negative values';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var statb  = provider.statResolvedRead( routinePath );
  provider.fileTimeSet( filePath, -1, -1 );
  var stata  = provider.statResolvedRead( routinePath );
  test.ge( statb.mtime, stata.mtime );
  test.ge( statb.atime, stata.atime );

  test.case = 'zero values';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var statb  = provider.statResolvedRead( routinePath );
  provider.fileTimeSet( filePath, 0, 0 );
  var stata  = provider.statResolvedRead( routinePath );
  test.ge( statb.mtime, stata.mtime );
  test.ge( statb.atime, stata.atime );

  if( process )
  if( process.platform === 'win32' )
  {
    test.case = 'number, milliseconds';
    provider.filesDelete( filePath );
    provider.fileWrite( filePath, filePath );
    var time = new Date().getTime();
    var statb  = provider.statResolvedRead( filePath );
    test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet( filePath, time, time ) );
    var stata  = provider.statResolvedRead( filePath );
    test.identical( statb.atime, stata.atime );
    test.identical( statb.mtime, stata.mtime );
  }
  else
  {
    test.case = 'number, sec';
    provider.filesDelete( filePath );
    provider.fileWrite( filePath, filePath );
    var time = new Date().getTime();
    provider.fileTimeSet( filePath, time, time );
    var stat  = provider.statResolvedRead( filePath );
    test.is( stat.isTerminal() );
    var adiff = time - stat.atime.getTime();
    testDiff( adiff );
    var mdiff = time - stat.mtime.getTime();
    testDiff( mdiff );
  }

  test.case = 'number, sec';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date().getTime();
  provider.fileTimeSet( filePath, time / 1000, time / 1000 );
  var stat  = provider.statResolvedRead( filePath );
  test.is( stat.isTerminal() );
  var adiff = time - stat.atime.getTime();
  testDiff( adiff );
  var mdiff = time - stat.mtime.getTime();
  testDiff( mdiff );

  test.case = 'incorrect atime type';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet( filePath, {}, time ) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  test.case = 'two args, second file does not exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  var filePath2 = test.context.pathFor( 'written/fileTimeSet/dir' );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet( filePath, filePath2 ) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  test.case = 'only atime';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet({ filePath, atime : time }) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  test.case = 'only mtime';
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var time = new Date();
  var statb  = provider.statResolvedRead( filePath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet({ filePath, mtime : time }) );
  var stata  = provider.statResolvedRead( filePath );
  test.identical( statb.atime, stata.atime );
  test.identical( statb.mtime, stata.mtime );

  if( !Config.debug )
  return;

  var time = new Date();
  test.case = 'invalid arguments'
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet( 1 ) );
  test.shouldThrowErrorOfAnyKind( () => provider.fileTimeSet({ filePath : 1, atime : time, mtime : time } ) );
}

//

function writeAsyncThrowingError( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var consequence = new _.Consequence().take( null );

  consequence
  .ifNoErrorThen( function( arg )
  {

    test.case = 'async, try to rewrite dir';

    var path = test.context.pathFor( 'dir' );
    provider.dirMake( path );
    test.identical( provider.isDir( path ), true )
    var data1 = 'data1';
    var con = provider.fileWrite
    ({
      filePath : path,
      data : data1,
      sync : 0,
    });

    return test.shouldThrowErrorAsync( con );
  })

  return consequence;
}

//

function fileCopyActSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );

  //

  test.case = 'use terminal as parent directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath2 = path.join( srcPath,'dst' );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    sync : 1,
    breakingDstHardLink : 0,
  }
  test.shouldThrowErrorSync( () => provider.fileCopyAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })

  //

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  //

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  //

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  //

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  //

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] )

  //

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] )

  //

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  //

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 0
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  //

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  //

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 1,
      // breakingDstSoftLink : 1
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );

  //

  test.case = 'simple copy';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 0,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple copy';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 1,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple copy';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 0,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple copy';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 1,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 0,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 1,
    // breakingDstSoftLink : 0
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 0,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'simple, rewrite';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopyAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    breakingDstHardLink : 1,
    // breakingDstSoftLink : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst', 'src' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  var routinePath = test.context.pathFor( 'written/' + test.name );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );

  /* hardLink */

  test.case = 'dst is a hard link, breaking disabled';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'dst is a hard link, breakingDstSoftLink : 1 ,breakingDstHardLink : 0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'dst is a hard link, breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  debugger
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 1
  });
  test.is( !provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  test.is( srcFile !== dstFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );
  test.is( srcFile !== dstFile );

  //

  test.case = 'dst is a hard link, breakingDstSoftLink : 1, breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 1
  });
  test.is( !provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  test.is( srcFile !== dstFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );
  test.is( srcFile !== dstFile );

  /* links */

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'dst is a soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 0
  });
  test.is( provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'dst is a soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 0
  });
  test.is( provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'dst is a soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopyAct
  ({
    dstPath,
    srcPath : otherPath,
    relativeSrcPath : otherPath,
    relativeDstPath : dstPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  })
  test.is( !provider.fileExists( dstPath ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.fileCopyAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0,
    sync : 1
  }

  var expected = _.mapExtend( null, o );

  provider.fileCopyAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  //

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './dst';
  var dstPath = path.join( routinePath,'dst' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct
    ({
      dstPath,
      srcPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
      breakingDstHardLink : 0
    });
  })

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );;
  var dstPath = path.join( routinePath,'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0,
    sync : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  });

  //

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = routinePath + '\\src';
  provider.fileWrite( srcPath, srcPath );
  var dstPath = routinePath + '\\dst';
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0,
    sync : 1
  }
  if( !self.providerIsInstanceOf( _.FileProvider.System ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopyAct( o ) );
  else
  test.mustNotThrowError( () => provider.fileCopyAct( o ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingDstHardLink : 0,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopyAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );

}

//

function fileCopySync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileCopy' );

  self.provider.filesDelete( routinePath );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'src not exist';

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 0,
    });
  });
  test.identical( got, null );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 0,
    });
  });
  test.identical( got, null );

  //

  test.case = 'dst path not exist';
  var srcPath = test.context.pathFor( 'written/fileCopy/src.txt' );
  var dstPath = test.context.pathFor( 'written/fileCopy/dst.txt' );
  provider.fileWrite( srcPath, ' ' );

  /**/

  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  //

  test.case = 'dst path exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  provider.fileWrite( dstPath, ' ' );

  /**/

  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst.txt', 'src.txt' ] );

  //

  test.case = 'src is equal to dst';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src.txt' ] );

  //

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  return;

  test.case = 'src is not a terminal, dst present, check if nothing changed';

  /* rewritin & throwing on */

  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( dstPath, ' ' );
  var srcStatExpected = provider.statResolvedRead( srcPath );
  var dstBefore = provider.fileRead( dstPath );
  var dirBefore = provider.dirRead( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  var srcStat = provider.statResolvedRead( srcPath );
  var dstNow = provider.fileRead( dstPath );
  test.is( srcStat.isDirectory() );
  test.identical( srcStat.size, srcStatExpected.size );
  test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
  test.identical( dstNow, dstBefore );
  var dirAfter = provider.dirRead( routinePath );
  test.identical( dirAfter, dirBefore );

  /* rewritin on & throwing off */

  var srcPath = test.context.pathFor( 'written/fileCopy/src.txt' );
  var dstPath = test.context.pathFor( 'written/fileCopy/dst.txt' );

  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( dstPath, ' ' );
  var srcStatExpected = provider.statResolvedRead( srcPath );
  var dstBefore = provider.fileRead( dstPath );
  var dirBefore = provider.dirRead( routinePath );
  var got = provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, null );
  var srcStat = provider.statResolvedRead( srcPath );
  var dstNow = provider.fileRead( dstPath );
  test.is( srcStat.isDirectory() );
  test.identical( srcStat.size, srcStatExpected.size );
  test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
  test.identical( dstNow, dstBefore );
  var dirAfter = provider.dirRead( routinePath );
  test.identical( dirAfter, dirBefore );

  // debugger; return; xxx

  /* rewritin & throwing off */

  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( dstPath, ' ' );
  var srcStatExpected = provider.statResolvedRead( srcPath );
  var dstBefore = provider.fileRead( dstPath );
  var dirBefore = provider.dirRead( routinePath );
  var got = provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, null );
  var srcStat = provider.statResolvedRead( srcPath );
  var dstNow = provider.fileRead( dstPath );
  test.is( srcStat.isDirectory() );
  test.identical( srcStat.size, srcStatExpected.size );
  test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
  test.identical( dstNow, dstBefore );
  var dirAfter = provider.dirRead( routinePath );
  test.identical( dirAfter, dirBefore );

  //

  test.case = 'makingDirectory creates routinePath for a file, dstPath structure not exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    makingDirectory : 1,
    throwing : 1
  });
  test.is( !!provider.statResolvedRead( dstPath ) );

  //

  test.case = 'rewriting off, dstPath structure not exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  test.shouldThrowErrorOfAnyKind( () =>
  {
     provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  })
  test.is( !provider.statResolvedRead( dstPath ) );

  //

  test.case = 'rewriting off, dstPath structure not exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  test.mustNotThrowError( () =>
  {
     provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  })
  test.is( !provider.statResolvedRead( dstPath ) );

  //

  test.case = 'rewriting on, parentDir is a terminal file'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var terminalFilePath = path.join( routinePath, 'folder/structure' );
  provider.fileWrite( terminalFilePath, dstPath );
  var dstPath = path.join( routinePath, 'folder/structure/dst' );
  test.is( !!provider.statResolvedRead( terminalFilePath ) );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    makingDirectory : 1,
    throwing : 1
  });
  test.is( provider.isDir( terminalFilePath ) );
  test.is( !!provider.statResolvedRead( dstPath ) );

  //

  test.case = 'rewriting on, parentDir is a directory with files, routinePath must be preserved'
  provider.filesDelete( routinePath );
  var file1 = path.join( routinePath, 'dir', 'file1' );
  var file2 = path.join( routinePath, 'dir', 'file2' );
  provider.fileWrite( file1, file1 );
  provider.fileWrite( file2, file2 );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dir', 'dst', 'src.txt' ];
  test.identical( files, expected );

  //

  test.case = 'rewriting off, parentDir is a directory with files, routinePath must be preserved'
  provider.filesDelete( routinePath );
  var file1 = path.join( routinePath, 'dir', 'file1' );
  var file2 = path.join( routinePath, 'dir', 'file2' );
  provider.fileWrite( file1, file1 );
  provider.fileWrite( file2, file2 );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath, 'dst' );
  test.is( !provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dir', 'dst', 'src.txt' ];
  test.identical( files, expected );

  /* relative paths */

  test.case = 'relative path, dst path not exist';
  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );

  //

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy
  ({
    srcPath,
    dstPath : test.context.globalFromPreferred( '../dst' ),
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy
  ({
    srcPath : test.context.globalFromPreferred( '../src' ),
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  if( !Config.debug )
  return;

  /* both relative, throwing : 1 */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath : test.context.globalFromPreferred( '../src' ),
      dstPath : test.context.globalFromPreferred( '../dst' ),
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcPath, srcFile );

  /* both relative, throwing : 0 */

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      srcPath : path.relative( routinePath, srcPath ),
      dstPath : path.relative( routinePath, dstPath ),
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcPath, srcFile );

  //

  test.case = 'dst - terminal, rewrite by src - terminal'
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  test.is( !!provider.statResolvedRead( srcPath ) );
  test.is( !!provider.statResolvedRead( dstPath ) );
  provider.fileCopy
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  var srcFile = provider.fileRead( srcPath );
  var dstFile = provider.fileRead( dstPath );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] )
  test.identical( srcFile, srcPath );
  test.identical( dstFile, srcPath );
}

//

function fileCopyRelativePath( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileCopyRelativePath' );
  let pathToDir = test.context.pathFor( 'written/fileCopyRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/fileCopyRelativePath/file' );

  test.open( 'src - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( pathToFile, dstPath ) );

  var srcPath = './../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( pathToFile, dstPath ) );

  var srcPath = '../../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( pathToFile, dstPath ) );


  var srcPath = './../../file';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( pathToFile, dstPath ) );


  var srcPath = './../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileCopyRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( pathToFile2, dstPath ) );

  var srcPath = '../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileCopyRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( pathToFile2, dstPath ) );

  test.close( 'src - relative path to a file' );

  //

  test.open( 'dst - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath,dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = './../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath,dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = '../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath,dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath,dstPath );
  provider.filesDelete( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( srcPath, dstPathResolved ) );

  var srcPath = pathToFile;
  var dstPath = './../a/b/dstFile';
  var dstPathResolved = provider.path.resolve( srcPath,dstPath );
  provider.filesDelete( dstPathResolved );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileCopy( dstPath, srcPath );
  test.is( provider.filesAreSame( srcPath, dstPathResolved ) );

  test.close( 'dst - relative path to a file' );

  //

  test.open( 'src - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = '../dir';
  var dstPath = test.context.pathFor( 'written/fileCopyRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( dstPath, srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'src - relative path to a dir' );

  //

  test.open( 'dst - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = pathToDir;
  var dstPath = '../copyOfDir';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( dstPath, srcPath ) );
  test.is( !provider.fileExists( dstPathResolved ) );

  test.close( 'dst - relative path to a dir' );

  test.open( 'same paths' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile,pathToFile );

  var srcPath = '../file';
  var dstPath = pathToFile;
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileCopy( dstPath, srcPath );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( got, true );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  var srcPath = pathToFile;
  var dstPath = '../file';
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileCopy( dstPath, srcPath );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( got, true );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  test.close( 'same paths' );
}

//

function fileCopyLinksSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/' + test.name );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );
  var dstLinkPath = path.join( dstPath, 'link' );
  var srcLinkPath = path.join( srcPath, 'link' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  /* hardLink */

  test.case = 'dst is a hard link, breaking disabled';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'dst is a hard link, breakingDstSoftLink : 1 ,breakingDstHardLink : 0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 0
  });
  test.is( provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, srcFile );
  test.identical( otherFile, srcFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, srcFile );
  test.is( srcFile !== otherFile );

  //

  test.case = 'dst is a hard link, breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 1
  });
  test.is( !provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  test.is( srcFile !== dstFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );
  test.is( srcFile !== dstFile );

  //

  test.case = 'dst is a hard link, breakingDstSoftLink : 1, breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 1,
    breakingDstHardLink : 1
  });
  test.is( !provider.isHardLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  test.is( srcFile !== dstFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );
  test.is( srcFile !== dstFile );

  //

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 1,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

   //

  test.case = 'src - not terminal, dst - hard link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.hardLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
    //  breakingDstSoftLink : 1,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isHardLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'dst is a soft link, breaking disabled';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 0
  });
  test.is( !provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );
  test.identical( otherFile, otherFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'dst is a soft link, breakingDstSoftLink : 0 ,breakingDstHardLink : 1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, srcPath );
  provider.fileCopy
  ({
    dstPath,
    srcPath : otherPath,
    sync : 1,
    // breakingDstSoftLink : 0,
    breakingDstHardLink : 1
  });
  test.is( !provider.isSoftLink( dstPath ) );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );
  test.identical( otherFile, otherFile );
  provider.fileWrite( srcPath, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 1,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 0
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src - not terminal, dst - soft link';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileWrite( otherPath, otherPath );
  provider.softLink( dstPath, otherPath );
  test.mustNotThrowError( () =>
  {
    provider.fileCopy
    ({
      dstPath,
      srcPath,
      sync : 1,
      throwing  : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 1
    });
  })
  test.is( !!provider.isSoftLink( dstPath ) );
  test.is( provider.isDir( srcPath ) );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( otherFile, dstFile );
  provider.fileWrite( otherFile, srcPath );
  var dstFile = provider.fileRead( dstPath );
  var otherFile = provider.fileRead( otherPath );
  test.identical( dstFile, otherFile );

  //

  test.case = 'src link is broken, src resolving is on'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 1,
    resolvingSrcSoftLink : 2,
  });

  test.is( !provider.fileExists( dstLinkPath ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  test.case = 'src link is broken, src resolving is on'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 1,
    resolvingSrcSoftLink : 1,
  });

  test.is( provider.isSoftLink( dstLinkPath ) );
  test.identical( provider.pathResolveSoftLink( dstLinkPath ), path.join( srcPath, 'fileNotExists' ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  test.case = 'src link is broken, src resolving is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 0,
    resolvingSrcSoftLink : 0,
  });

  test.is( provider.fileExists( dstLinkPath ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  test.case = 'src link is broken, src resolving is on, allowingMissed is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : path.join( srcPath, 'fileNotExists' ),
    dstPath : srcLinkPath,
    allowingMissed : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })

  test.shouldThrowErrorSync( () =>
  {
    var records = provider.fileCopy
    ({
      srcPath : srcLinkPath,
      dstPath : dstLinkPath,
      allowingMissed : 0,
      resolvingSrcSoftLink : 1,
    });
  });

  test.is( provider.fileExists( dstLinkPath ) );
  test.is( !provider.fileExists( path.join( dstPath, 'fileNotExists' ) ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  test.case = 'src link is cycled, src resolving is on'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : srcLinkPath,
    dstPath : srcLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    makingDirectory : 1
  });
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1
  });
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    resolvingSrcSoftLink : 1,
  });

  test.identical( provider.pathResolveSoftLink( dstLinkPath ), srcLinkPath );
  test.is( provider.fileExists( dstLinkPath ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  test.case = 'src link is cycled, src resolving is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : srcLinkPath,
    dstPath : srcLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })
  var records = provider.fileCopy
  ({
    srcPath : srcLinkPath,
    dstPath : dstLinkPath,
    allowingMissed : 0,
    allowingCycled : 0,
    resolvingSrcSoftLink : 0,
  });

  test.identical( provider.pathResolveSoftLink( dstLinkPath ), srcLinkPath );
  test.is( provider.fileExists( dstLinkPath ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  test.case = 'src link is cycled, src resolving is on, allowingMissed is off'
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : srcLinkPath,
    dstPath : srcLinkPath,
    allowingMissed : 1,
    allowingCycled : 1,
    makingDirectory : 1,
  })
  provider.fileWrite( path.join( dstPath, 'terminal' ), 'file' );
  provider.softLink
  ({
    srcPath : path.join( dstPath, 'terminal' ),
    dstPath : dstLinkPath,
    makingDirectory : 1,
  })

  test.shouldThrowErrorSync( () =>
  {
    var records = provider.fileCopy
    ({
      srcPath : srcLinkPath,
      dstPath : dstLinkPath,
      allowingMissed : 1,
      allowingCycled : 0,
      resolvingSrcSoftLink : 1,
    });
  });

  test.identical( provider.pathResolveSoftLink( dstLinkPath ), path.join( dstPath, 'terminal' ) );
  test.is( provider.fileExists( dstLinkPath ) );
  test.is( provider.fileExists( path.join( dstPath, 'terminal' ) ) );

  //

  debugger; return; xxx
}

//

function fileCopyAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/fileCopyAsync' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var srcPath = test.context.pathFor( 'written/fileCopyAsync/src.txt' );
  var dstPath = test.context.pathFor( 'written/fileCopyAsync/dst.txt' );

  var consequence = new _.Consequence().take( null );

  //

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'src not exist';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    debugger
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 1,
    });
    return test.shouldThrowErrorOfAnyKind( con )
  })

  /**/

  .finally( function()
  {
    var con = provider.fileCopy
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'copy bigger file';
    var data = _.strDup( 'Lorem Ipsum is simply text', 10000 );
    provider.fileWrite( srcPath, data );
    provider.filesDelete( dstPath );
    var srcStat = provider.statResolvedRead( srcPath );
    return provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      var dstStat = provider.statResolvedRead( dstPath );
      test.identical( srcStat.size, dstStat.size );
      var dstFile = provider.fileRead( dstPath );
      test.is( dstFile === data );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dst path not exist';
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dst path exist';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    provider.fileWrite( dstPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    })
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst.txt', 'src.txt' ] );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileCopy
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src.txt' ] );
      return null;
    });
  });

  //

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  return consequence;

  consequence.finally( () =>
  {
    test.case = 'src is not a terminal, dst present, check if nothing changed';
    return true;
  })

  /* rewritin & throwing on */

  .finally( () =>
  {
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    provider.fileWrite( dstPath, ' ' );
    var srcStatExpected = provider.statResolvedRead( srcPath );
    var dstBefore = provider.fileRead( dstPath );
    var dirBefore = provider.dirRead( routinePath );
    return test.shouldThrowErrorOfAnyKind( () =>
    {
      return provider.fileCopy
      ({
        srcPath,
        dstPath,
        sync : 0,
        rewriting : 1,
        throwing : 1
      });
    })
    .finally( () =>
    {
      var srcStat = provider.statResolvedRead( srcPath );
      var dstNow = provider.fileRead( dstPath );
      test.is( srcStat.isDirectory() );
      test.identical( srcStat.size, srcStatExpected.size );
      test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
      test.identical( dstNow, dstBefore );
      var dirAfter = provider.dirRead( routinePath );
      test.identical( dirAfter, dirBefore );
      return true;
    })

  })

  /* rewritin on & throwing off */

  .finally( () =>
  {
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    provider.fileWrite( dstPath, ' ' );
    var srcStatExpected = provider.statResolvedRead( srcPath );
    var dstBefore = provider.fileRead( dstPath );
    var dirBefore = provider.dirRead( routinePath );
    return provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    })
    .finally( ( err, got ) =>
    {
      test.identical( got, null );
      var srcStat = provider.statResolvedRead( srcPath );
      var dstNow = provider.fileRead( dstPath );
      test.is( srcStat.isDirectory() );
      test.identical( srcStat.size, srcStatExpected.size );
      test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
      test.identical( dstNow, dstBefore );
      var dirAfter = provider.dirRead( routinePath );
      test.identical( dirAfter, dirBefore );
      return got;
    })

  })

  /* rewritin & throwing off */

  .finally( () =>
  {
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    provider.fileWrite( dstPath, ' ' );
    var srcStatExpected = provider.statResolvedRead( srcPath );
    var dstBefore = provider.fileRead( dstPath );
    var dirBefore = provider.dirRead( routinePath );
    return provider.fileCopy
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    })
    .finally( ( err, got ) =>
    {
      test.identical( got, null );
      var srcStat = provider.statResolvedRead( srcPath );
      var dstNow = provider.fileRead( dstPath );
      test.is( srcStat.isDirectory() );
      test.identical( srcStat.size, srcStatExpected.size );
      test.identical( srcStat.mtime.getTime(), srcStatExpected.mtime.getTime() );
      test.identical( dstNow, dstBefore );
      var dirAfter = provider.dirRead( routinePath );
      test.identical( dirAfter, dirBefore );
      return got;
    })

  })

  return consequence;
}

//

function fileCopyLinksAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  // !!!needs adjusting

  if( !_.routineIs( provider.fileCopyAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/' + test.name );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );

  var con = new _.Consequence().take( null )

  //

  /* hardLink */

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breaking disabled';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( dstFile, srcFile );
      test.identical( otherFile, srcFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, srcFile );
      test.is( srcFile !== otherFile );
      return null;
    })
  })

  //

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breakingDstSoftLink : 1 ,breakingDstHardLink : 0';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( dstFile, srcFile );
      test.identical( otherFile, srcFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, srcFile );
      test.is( srcFile !== otherFile );
      return null;
    })
  })

  //

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breakingDstHardLink : 1';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( !provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( otherFile, dstFile );
      test.is( srcFile !== dstFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, otherFile );
      test.is( srcFile !== dstFile );
      return null;
    })
  })

  //

  .ifNoErrorThen( () =>
  {
    test.case = 'dst is a hard link, breakingDstSoftLink : 1, breakingDstHardLink : 1';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.hardLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 1,
      breakingDstHardLink : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( !provider.isHardLink( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( otherFile, dstFile );
      test.is( srcFile !== dstFile );
      provider.fileWrite( srcPath, srcPath );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      test.identical( dstFile, otherFile );
      test.is( srcFile !== dstFile );
      return null;
    })
  });

  //

  if( !test.context.softLinkIsSupported() )
  return con;

  /* soft links */

  con.finally( () =>
  {
    test.case = 'dst is a soft link, breaking disabled';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.softLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isTerminal( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( srcPath, srcFile );
      test.identical( otherFile, dstFile );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'dst is a soft link, breakingDstSoftLink : 0 ,breakingDstHardLink : 1';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( otherPath, otherPath );
    provider.softLink( dstPath, srcPath );
    return provider.fileCopy
    ({
      dstPath,
      srcPath : otherPath,
      sync : 0,
      // breakingDstSoftLink : 0,
      breakingDstHardLink : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.is( provider.isTerminal( dstPath ) );
      var dstFile = provider.fileRead( dstPath );
      var srcFile = provider.fileRead( srcPath );
      var otherFile = provider.fileRead( otherPath );
      test.identical( srcPath, srcFile );
      test.identical( otherFile, dstFile );
      return null;
    })
  })

  return con;
}

//

function fileCopySoftLinkResolving( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1,1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0,1 ]
  resolvingDstSoftLink : [ 0,1 ]
  link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]

  */

  function fileCopy( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.fileCopy( o );
  }

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  /**/

  test.open( 'normal' );

  // provider.filesDelete( routinePath );
  // provider.fileWrite( srcPathTerminal, srcPathTerminal );
  // provider.fileWrite( dstPathTerminal, dstPathTerminal );
  // provider.softLink( srcPath, srcPathTerminal );
  // provider.softLink( dstPath, dstPathTerminal );
  // var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  // fileCopy( o );
  // test.identical( o.srcPath, srcPath );
  // test.identical( o.dstPath, dstPath );
  // test.is( provider.isSoftLink( srcPath ) );
  // test.is( provider.isSoftLink( dstPath ) );
  // test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  // test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  // test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  // test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  debugger
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  fileCopy( o )
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  // /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  fileCopy( o )
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath2 ).absolutePath, dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'self cycled' );

  /* dst does not exist */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( o.srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  // test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  // test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );

  /* both are self links */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  //

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0, allowingMissed : 0,  throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, null );
  test.identical( o.srcPath, null );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0, allowingMissed : 1, allowingCycled : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  //

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1, allowingMissed : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  //

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, null );
  test.identical( o.srcPath, null );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1, allowingCycled : 1, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 0, throwing : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1, allowingCycled : 1, throwing : 1 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'self cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileCopy( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 2, resolvingDstSoftLink : 1 };
  var statSrcPathTerminal1 = provider.statRead( srcPathTerminal );
  fileCopy( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  var statSrcPathTerminal2 = provider.statRead( srcPathTerminal );
  test.will = 'terminal must not be changed';
  test.identical( statSrcPathTerminal1.mtime.getTime(),statSrcPathTerminal2.mtime.getTime()  )

  test.close( 'links to same file' );
}

fileCopySoftLinkResolving.timeOut = 30000;

//

function fileCopyLinks( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  /*
    resolving off
    link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]
  */

  function fileCopy( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      resolvingDstSoftLink : 0,
      resolvingDstTextLink : 0,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.fileCopy( o );
  }

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  test.case = 'src normal link'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'both normal links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src double link'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'both double links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveLinkFull( srcPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src broken link'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'both broken links'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src self link';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );

  test.case = 'both are self links';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0, allowingMissed : 0, throwing : 0 };
  var got = fileCopy( o );
  test.identical( got, true );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );

  test.case = 'src cycled';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );

  test.case = 'cycled';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileCopy( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );

  test.case = 'links to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  var dstStatBefore = provider.statRead( dstPath );
  _.timeOut( 1000 ).deasync();
  fileCopy( o );
  var dstStatAfter = provider.statRead( dstPath );
  test.is( dstStatBefore.mtime.getTime() !== dstStatAfter.mtime.getTime() );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
}

//

function fileCopyError( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyError' );
  let srcPath = test.context.pathFor( 'written/fileCopyError/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyError/dst' );
  let missingPath = test.context.pathFor( 'written/fileCopyError/missing' );

  /**/

  test.case = 'missing';
  provider.filesDelete( routinePath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  //

  test.case = 'missing';
  provider.filesDelete( routinePath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  //

  test.case = 'try to copy dir';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  var o =
  {
    srcPath,
    dstPath,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  //

  test.case = 'try to copy dir';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  var o =
  {
    srcPath,
    dstPath,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.identical( got, null );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  //

  test.case = 'try to copy soft link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink( srcPath, routinePath );
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 1
  }
  var got = provider.fileCopy( o );
  test.identical( got, true );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  //

  test.case = 'try to copy soft link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink( srcPath, routinePath );
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 1,
    throwing : 1
  }
  provider.fileCopy( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );

  //

  test.case = 'try to copy soft link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink( srcPath, routinePath );
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 1,
    throwing : 0
  }
  provider.fileCopy( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );

  test.case = 'rewriting terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

  //

  test.case = 'rewriting terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

  //

  test.case = 'rewriting routinePath by terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.dirRead( dstPath ), [] );

  //

  test.case = 'rewriting routinePath by terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  var o =
  {
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.dirRead( dstPath ), [] );

  //

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), dstPath );

  //

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), dstPath );

  //

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 1,
    allowingMissed : 0,
  }
  test.mustNotThrowError( () => provider.fileCopy( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  //

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 0,
    allowingMissed : 0,
  }
  test.mustNotThrowError( () => provider.fileCopy( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  //

  test.case = 'error on fileCopy missed link should not be throwen';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 1,
    allowingMissed : 0,
  }
  var r = provider.fileCopy( o );
  test.is( r );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );

  //

  test.case = 'error on fileCopy missed link should not be throwen';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    resolvingSrcSoftLink : 0,
    throwing : 0,
    allowingMissed : 0,
  }
  var r = provider.fileCopy( o );
  test.is( r );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );

  //

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    resolvingSrcSoftLink : 1,
    throwing : 1
  }
  test.shouldThrowErrorOfAnyKind( () => provider.fileCopy( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

  //

  test.case = 'error on resolve src';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
  var o =
  {
    srcPath,
    dstPath,
    allowingMissed : 0,
    resolvingSrcSoftLink : 1,
    throwing : 0
  }
  var got = provider.fileCopy( o );
  test.identical( got, null );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
  test.identical( provider.fileRead( dstPath ), dstPath );

}

//

function fileCopySoftLinkExtended( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkExtended' );
  let srcPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/src' );
  let dstPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/dst' );
  let terminalPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/terminal' );
  let dirPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/dir/terminal' );
  let missingPath = test.context.pathFor( 'written/fileCopySoftLinkExtended/missing' );

  /* */

  test.open( 'src soft link to terminal, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), terminalPath );

  test.close( 'src soft link to terminal, dst missing' );

  /* */

  test.open( 'src soft link to terminal, dst terminal' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( srcPath, terminalPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), terminalPath );

  test.close( 'src soft link to terminal, dst terminal' );

  /* */

  test.open( 'src soft link to dir, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( srcPath, dirPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( srcPath, dirPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.identical( provider.pathResolveSoftLink( dstPath ), dirPath )

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( srcPath, dirPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), dirPath );
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isDir( dstPath ) );

  test.close( 'src soft link to dir, dst missing' );

  /* */

  test.open( 'src dir, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( provider.isDir( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  test.is( provider.isDir( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );

  test.close( 'src dir, dst missing' );

  /* */

  test.open( 'src missing, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'src missing, dst missing' );

  /* */

  test.open( 'src missing, dst terminal' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1 '
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 })
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'src missing, dst terminal' );

  /* */

  test.open( 'src missing, dst empty directory' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );

  test.close( 'src missing, dst empty directory' );

  /* */

  test.open( 'src missing, dst directory' );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1  })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1  })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath : dirPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1  })
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isDir( dirPath ) );

  test.close( 'src missing, dst directory' );

  /* */

  test.open( 'src soft link to missing, dst missing' );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.close( 'src soft link to missing, dst missing' );

  /* */

  test.open( 'src soft link to missing, dst terminal' );

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), terminalPath );

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 0 });
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.case = 'resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : srcPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.fileCopy({ srcPath, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), terminalPath )

  test.close( 'src soft link to missing, dst terminal' );
}

//

function fileCopySoftLinkBasic( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopySoftLinkBasic' );
  let src1Path = test.context.pathFor( 'written/fileCopySoftLinkBasic/src1' );
  let src2Path = test.context.pathFor( 'written/fileCopySoftLinkBasic/src2' );
  let src3Path = test.context.pathFor( 'written/fileCopySoftLinkBasic/src3' );
  let dstPath = test.context.pathFor( 'written/fileCopySoftLinkBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      fileCopy
        - link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      fileCopy
        - link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      fileCopy
        - copy src3 -> dst
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );
}

//

function fileCopyRelativeLinking( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileCopy ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileCopyRelativeLinking' );
  let src1Path = test.context.pathFor( 'written/fileCopyRelativeLinking/src1' );
  let src2Path = test.context.pathFor( 'written/fileCopyRelativeLinking/src2' );
  let src3Path = test.context.pathFor( 'written/fileCopyRelativeLinking/src3' );
  let dstPath = test.context.pathFor( 'written/fileCopyRelativeLinking/dst' );

  /*
    src1 -> ../src2
    fileCopy dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    fileCopy dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    fileCopy dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    fileCopy dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.fileCopy
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : test.context.globalFromPreferred( '../src1' ), dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileCopy
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileCopy({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.fileRead( dstPath ), src3Path );
}


//

function fileCopyGlobal( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1,1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileCopyGlobal' );
  let srcPath = test.context.pathFor( 'written/fileCopyGlobal/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  test.identical( provider.protocols, [ 'current', 'second' ] )

  /*  */

  test.open( 'with system' )

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileCopy( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' )

  /* */

  test.open( 'without system' )

  self.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileCopy( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileCopy( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  self.system.providerRegister( provider );

  test.close( 'without system' )

}

//

function fileCopyAsyncThrowingError( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyAsyncThrowingError' );
  let srcPath = test.context.pathFor( 'written/fileCopyAsyncThrowingError/src' );
  let dstPath = test.context.pathFor( 'written/fileCopyAsyncThrowingError/dst' );
  let missingPath = test.context.pathFor( 'written/fileCopyAsyncThrowingError/missing' );

  let con = new _.Consequence().take( null )

  /**/

  .then( () =>
  {
    test.case = 'missing';
    provider.filesDelete( routinePath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( !provider.fileExists( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'missing';
    provider.filesDelete( routinePath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( !provider.fileExists( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'try to copy dir';
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.isDir( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })

  })

  //

  .then( () =>
  {
    test.case = 'try to copy dir';
    provider.filesDelete( routinePath );
    provider.dirMake( srcPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.isDir( srcPath ) );
      test.is( !provider.fileExists( dstPath ) );
      return true;
    })

  })

  //

  .then( () =>
  {
    test.case = 'try to copy soft link to dir';
    provider.filesDelete( routinePath );
    provider.dirMake( routinePath );
    provider.softLink( srcPath, routinePath );
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      sync : 0,
      throwing : 1
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'try to copy soft link to dir';
    provider.filesDelete( routinePath );
    provider.dirMake( routinePath );
    provider.softLink( srcPath, routinePath );
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      sync : 0,
      throwing : 1
    }
    return provider.fileCopy( o )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'try to copy soft link to dir';
    provider.filesDelete( routinePath );
    provider.dirMake( routinePath );
    provider.softLink( srcPath, routinePath );
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), routinePath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'rewriting terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'rewriting terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })

  })

  //

  .then( () =>
  {
    test.case = 'rewriting routinePath by terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.dirMake( dstPath );
    var o =
    {
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 0,
      sync : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isDir( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.dirRead( dstPath ), [] );
      return true;
    })

  })

  //

  .then( () =>
  {
    test.case = 'rewriting routinePath by terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    provider.dirMake( dstPath );
    var o =
    {
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 0,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isDir( dstPath ) );
      test.identical( provider.fileRead( srcPath ), srcPath );
      test.identical( provider.dirRead( dstPath ), [] );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( !provider.fileExists( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( !provider.fileExists( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })

  })



  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 1,
    }
    return provider.fileCopy( o )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.pathResolveSoftLink( dstPath ), missingPath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 0,
    }
    return test.shouldThrowErrorAsync( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( !provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'error on fileCopy missed link should not be throwen';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 0,
      throwing : 1,
      sync : 0,
      allowingMissed : 0,
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.is( got );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      return true;
    })

  })

  //

  .then( () =>
  {
    test.case = 'error on fileCopy missed link should not be throwen';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      resolvingSrcSoftLink : 0,
      sync : 0,
      throwing : 0,
      allowingMissed : 0,
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.is( got );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      resolvingSrcSoftLink : 1,
      throwing : 1
    }
    return test.shouldThrowErrorOfAnyKind( provider.fileCopy( o ) )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })
  })

  //

  .then( () =>
  {
    test.case = 'error on resolve src';
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, dstPath );
    provider.softLink({ dstPath : srcPath, srcPath : missingPath, allowingMissed : 1 });
    var o =
    {
      srcPath,
      dstPath,
      allowingMissed : 0,
      sync : 0,
      resolvingSrcSoftLink : 1,
      throwing : 0
    }
    return provider.fileCopy( o )
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isTerminal( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), missingPath );
      test.identical( provider.fileRead( dstPath ), dstPath );
      return true;
    })

  })

  return con;
}

//

// function fileCopyAsyncThrowingError( test )
// {
//   let self = this;
//   let provider = self.provider;

//   if( !_.routineIs( provider.fileCopy ) )
//   return;

//   var routinePath = test.context.pathFor( 'written/fileCopyAsync' );

//   if( !provider.statResolvedRead( routinePath ) )
//   provider.dirMake( routinePath );

//   var consequence = new _.Consequence().take( null );

//   consequence
//   .ifNoErrorThen( function( arg )
//   {
//     test.case = 'async, throwing error';
//     var con = provider.fileCopy
//     ({
//       srcPath : test.context.pathFor( 'invalid.txt' ),
//       dstPath : test.context.pathFor( 'dstPath.txt' ),
//       sync : 0,
//     });

//     return test.shouldThrowErrorOfAnyKind( con );
//   })
//   .ifNoErrorThen( function( arg )
//   {
//     test.case = 'async,try rewrite dir';
//     var con = provider.fileCopy
//     ({
//       srcPath : test.context.pathFor( 'invalid.txt' ),
//       dstPath : test.context.pathFor( 'tmp' ),
//       sync : 0,
//     });

//     return test.shouldThrowErrorAsync( con );
//   })
//   .ifNoErrorThen( function( arg )
//   {
//     test.case = 'async copy dir';
//     try
//     {
//       provider.dirMake
//       ({
//         filePath : test.context.pathFor( 'written/fileCopyAsync/copydir' ),
//         sync : 1
//       });
//       provider.fileWrite
//       ({
//         filePath : test.context.pathFor( 'written/fileCopyAsync/copydir/copyfile.txt' ),
//         data : 'Lorem',
//         sync : 1
//       });
//     } catch ( err ) { }

//     debugger;
//     var con = provider.fileCopy
//     ({
//         srcPath : test.context.pathFor( 'written/fileCopyAsync/copydir' ),
//         dstPath : test.context.pathFor( 'written/fileCopyAsync/copydir2' ),
//         sync : 0,
//     });

//     return test.shouldThrowErrorAsync( con );
//   });

//   return consequence;
// }

//

function fileRenameSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var got;
  var srcPath = test.context.pathFor( 'written/fileRename/src' );
  var dstPath = test.context.pathFor( 'written/fileRename/dst' );
  var routinePath  = self.provider.path.dir( srcPath );

  //

  test.case = 'src not exist';

  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 1,
      throwing : 0,
    });
  });
  test.identical( got, null );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 1,
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 1,
      rewriting : 0,
      throwing : 0,
    });
  });
  test.identical( got, null );

  //

  test.case = 'rename in same directory,dst not exist';

  /**/

  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  //

  test.case = 'rename with rewriting in same directory';

  /**/

  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.fileWrite( srcPath, ' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.fileWrite( srcPath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null );

  //

  test.case = 'rename routinePath, dst not exist';
  provider.filesDelete( routinePath );

  /**/

  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( dstPath );
  provider.dirMake( srcPath );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  //

  test.case = 'rename moving to other existing dir';

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( self.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( self.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( self.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( self.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( self.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( self.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.dirMake( self.provider.path.dir( dstPath ) );
  got = provider.fileRename
  ({
    srcPath,
    dstPath,
    sync : 1,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( self.provider.path.dir( dstPath ) );
  test.identical( files, [ 'dst' ] );

  //

  test.case = 'rename moving to not existing dir';

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, null )
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null )
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'dst is not empty dir';

  /**/

  debugger
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath,' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath : self.provider.path.dir( dstPath ),
    sync : 1,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath,' ' );
  got = provider.fileRename
  ({
    srcPath,
    dstPath : self.provider.path.dir( dstPath ),
    sync : 1,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 0
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath,' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileRename
    ({
      srcPath,
      dstPath : self.provider.path.dir( dstPath ),
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );
  dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
  provider.fileWrite( dstPath,' ' );
  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : self.provider.path.dir( dstPath ),
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, null );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath', 'src' ] );

  //src is equal to dst

  test.case = 'src is equal to dst';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath,' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

}

//

function fileRenameSync2( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var got;
  var srcPath = test.context.pathFor( 'written/fileRename/src' );
  var dstPath = test.context.pathFor( 'written/fileRename/dst' );
  var routinePath  = self.provider.path.dir( srcPath );

  test.open( 'rewriting terminal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  //

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  //

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  var dstRead = provider.fileRead( dstPath );
  test.identical( srcRead, srcPath );
  test.identical( dstRead, dstPath );

  //

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 0,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  //

  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  test.close( 'rewriting terminal' );

  /**/

  test.open( 'rewriting directory' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 0,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      rewritingDirs : 1,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.isDir( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  test.close( 'rewriting directory' );

  /**/

  test.open( 'making directory' );

  dstPath = provider.path.join( dstPath, 'dstFile' );
  provider.filesDelete( routinePath );

  //

  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 1,
      makingDirectory : 0,
      throwing : 1
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  provider.fileWrite( srcPath, srcPath );
  test.mustNotThrowError( () =>
  {
    provider.fileRename
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      rewritingDirs : 1,
      makingDirectory : 0,
      throwing : 0
    })
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );
  var srcRead = provider.fileRead( srcPath );
  test.identical( srcRead, srcPath );

  //

  provider.fileWrite( srcPath, srcPath );
  provider.fileRename
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    rewritingDirs : 1,
    makingDirectory : 1,
    throwing : 1
  })
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  var dstRead = provider.fileRead( dstPath );
  test.identical( dstRead, srcPath );

  test.close( 'making directory' );
}

//

function fileRenameRelativePath( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameRelativePath' );
  let pathToDir = test.context.pathFor( 'written/fileRenameRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/fileRenameRelativePath/file' );

  test.open( 'src - relative path to a file' );

  var srcPath = '../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );

  var srcPath = './../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );


  var srcPath = '../../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );

  var srcPath = './../../file';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath/dstFile' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile );

  var srcPath = './../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileRenameRelativePath/a/file' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/c/dstFile' );
  provider.dirMakeForFile( dstPath )
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile2 ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile2 );

  var srcPath = '../../../file';
  var pathToFile2 = test.context.pathFor( 'written/fileRenameRelativePath/a/file' );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/c/dstFile' );
  provider.dirMakeForFile( dstPath )
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile2 ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.fileRead( dstPath );
  test.identical( got, pathToFile2 );

  test.close( 'src - relative path to a file' );

  //

  test.open( 'dst - relative path to a file' );

  pathToFile = test.context.pathFor( 'written/fileRenameRelativePath/a/b/c/file' );

  var srcPath = pathToFile;
  var dstPath = '../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../../../dstFile';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToFile ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.fileRead( dstPathResolved );
  test.identical( got, pathToFile );

  test.close( 'dst - relative path to a file' );

  //

  test.open( 'src - relative path to a dir' );

  var srcPath = '../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = './../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = '../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dst/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = './../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/dst/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = '../../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = './../../../dir';
  var dstPath = test.context.pathFor( 'written/fileRenameRelativePath/a/b/dstPath' );
  var fileInDirPath = provider.path.join( routinePath, 'dir', 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( pathToDir ) )
  test.is( provider.fileExists( dstPath ) );
  var got = provider.dirRead( dstPath );
  test.identical( got, [ 'fileInDir' ] );

  test.close( 'src - relative path to a dir' );

  //

  test.open( 'dst - relative path to a dir' );

  pathToDir = test.context.pathFor( 'written/fileRenameRelativePath/1/2/3/dir' )

  var srcPath = pathToDir;
  var dstPath = '../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = '../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = '../../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../../../dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = '../a/b/dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = './../a/b/dstPath';
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  var fileInDirPath = provider.path.join( pathToDir, 'fileInDir' );
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDirPath, fileInDirPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.fileRename( dstPath, srcPath );
  test.is( !provider.fileExists( srcPath ) )
  test.is( provider.fileExists( dstPathResolved ) );
  var got = provider.dirRead( dstPathResolved );
  test.identical( got, [ 'fileInDir' ] );

  test.close( 'dst - relative path to a dir' );

  test.open( 'same paths' );

  pathToFile =  test.context.pathFor( 'written/fileRenameRelativePath/file' )

  var srcPath = pathToFile;
  var dstPath = '../file';
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileRename( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  var srcPath = '../file';
  var dstPath = pathToFile;
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.fileRename( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.mtime.getTime(), statNow.mtime.getTime() );

  test.close( 'same paths' );

}

fileRenameRelativePath.timeOut = 30000;

//

function fileRenameAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var got;
  var srcPath = test.context.pathFor( 'written/fileRenameAsync/src' );
  var dstPath = test.context.pathFor( 'written/fileRenameAsync/dst' );
  var routinePath  = self.provider.path.dir( srcPath );


  var consequence = new _.Consequence().take( null );

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'src not exist';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 1,
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  consequence
  .finally( function()
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 1,
      throwing : 0,
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  /**/

  consequence
  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 1,
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.fileRename
    ({
      srcPath : test.context.pathFor( 'not_existing_path' ),
      dstPath : ' ',
      sync : 0,
      rewriting : 0,
      throwing : 0,
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename in same directory,dst not exist';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename with rewriting in same directory';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });

  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });

  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, ' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename routinePath, dst not exist';
    provider.filesDelete( routinePath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( dstPath );
    provider.dirMake( srcPath );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename moving to other existing dir';
    dstPath = test.context.pathFor( 'written/fileRenameAsync/routinePath/dst' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.dirMake( self.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( self.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.dirMake( self.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( self.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.dirMake( self.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( self.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.dirMake( self.provider.path.dir( dstPath ) );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( self.provider.path.dir( dstPath ) );
      test.identical( files, [ 'dst' ] );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'rename moving to not existing dir';
    dstPath = test.context.pathFor( 'written/fileRename/routinePath/dst' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function( err, got )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function( err, got )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dst is not empty dir';
    dstPath = test.context.pathFor( 'written/fileRenameAsync/routinePath/dst' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.fileWrite( dstPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : self.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 1,
      rewritingDirs : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.fileWrite( dstPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : self.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 1,
      rewritingDirs : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true )
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.fileWrite( dstPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : self.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    provider.fileWrite( dstPath,' ' );
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : self.provider.path.dir( dstPath ),
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .finally( function( err,got )
    {
      test.identical( got, null );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath', 'src' ] );
      return got;
    });
  })

  //src is equal to dst

  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath,' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileRename
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return got;
    });
  })

  return consequence;
}

//

function fileRenameActSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRenameAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var got;

  var routinePath = test.context.pathFor( 'written/fileCopy' );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  //

  test.case = 'no src';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })

  //

  test.case = 'no src, dst exists';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );

  //

  test.case = 'src : directory, no dst';
  provider.filesDelete( routinePath );
  provider.dirMake( srcPath );
  provider.fileRenameAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] )

  //

  test.case = 'no structure before dst';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  //

  test.case = 'src - terminal, dst - directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dstPath', 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.dirMake( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    })
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dstPath', 'src' ] );
  var files = provider.dirRead( dstPath );
  test.identical( files, [] );
  //

  test.case = 'simple rename';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRenameAct
  ({
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
  });
  var files = provider.dirRead( routinePath );
  var expected = [ 'dst' ];
  test.identical( files, expected );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );

  //

  test.case = 'dst exists';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    provider.fileRenameAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    });
    var files = provider.dirRead( routinePath );
    var expected = [ 'dst' ];
    test.identical( files, expected );
    var dstFile = provider.fileRead( dstPath );
    test.identical( srcPath, dstFile );
  }
  else
  {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.fileRenameAct
      ({
        srcPath,
        dstPath,
        relativeSrcPath : srcPath,
        relativeDstPath : dstPath,
        sync : 1,
      });
    })
    var files = provider.dirRead( routinePath );
    var expected = [ 'dst','src' ];
    test.identical( files, expected );
    var srcFile = provider.fileRead( srcPath );
    test.identical( srcFile, srcPath );
    var dstFile = provider.fileRead( dstPath );
    test.identical( dstFile, dstPath );
  }

  //

  var routinePath = test.context.pathFor( 'written/' + test.name );
  var srcPath = path.join( routinePath, 'src' );
  var dstPath = path.join( routinePath, 'dst' );
  var otherPath = path.join( routinePath, 'other' );

  //

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  })
  test.is( !provider.fileExists( dstPath ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.fileRenameAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1
  }

  var expected = _.mapExtend( null, o );

  provider.fileRenameAct( o );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );
  var dstFile = provider.fileRead( dstPath );
  test.identical( srcPath, dstFile );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'use terminal as parent directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath2 = path.join( srcPath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    sync : 1
  }
  test.shouldThrowErrorSync( () => provider.fileRenameAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  //

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './dst';
  var dstPath = path.join( routinePath,'dst' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct
    ({
      dstPath,
      srcPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      sync : 1,
    });
  })

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );;
  var dstPath = path.join( routinePath,'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  });

  //

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = routinePath + '\\src';
  provider.fileWrite( srcPath, srcPath );
  var dstPath = routinePath + '\\dst';
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1
  }
  if( !self.providerIsInstanceOf( _.FileProvider.System ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRenameAct( o ) );
  else
  test.mustNotThrowError( () => provider.fileRenameAct( o ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileRenameAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );
}

//

function fileRenameSoftLinkResolving( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1,1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0,1 ]
  resolvingDstSoftLink : [ 0,1 ]
  link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]

  */

  function fileRename( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.fileRename( o );
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath2 );
  test.identical( provider.pathResolveLinkFull( srcPath2 ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPathTerminal );
  test.identical( provider.pathResolveLinkFull( dstPath2 ).absolutePath, dstPathTerminal );
  test.identical( provider.fileRead( srcPath2 ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( !provider.fileExists( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'self cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'self cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  test.identical( provider.pathResolveLinkFull( dstPath2 ).absolutePath, srcPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => fileRename( o ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  fileRename( o );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );

  test.close( 'links to same file' );
}

//

function fileRenameSoftLinkBasic( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkBasic' );
  let src1Path = test.context.pathFor( 'written/fileRenameSoftLinkBasic/src1' );
  let src2Path = test.context.pathFor( 'written/fileRenameSoftLinkBasic/src2' );
  let src3Path = test.context.pathFor( 'written/fileRenameSoftLinkBasic/src3' );
  let dstPath = test.context.pathFor( 'written/fileRenameSoftLinkBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      fileRename
        - link dst -> src2
        - delete src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      fileRename
        - link dst -> src3
        - delete src1
        - delete src2

    src1 -> src2 -> src3
    resolvingSrcSoftLink : 2
    fileRename
      - copy src3 -> dst
      - delete src1
      - delete src2
      - delete src3
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src2Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );
}

//

function fileRenameGlobal( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1,1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameGlobal' );
  let srcPath = test.context.pathFor( 'written/fileRenameGlobal/src' );
  let dstPath = test.context.pathFor( 'written/fileRenameGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  /* */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathDefault, srcPathDefault );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathSecond, srcPathSecond );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileRename( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /* */

  test.open( 'without system' );

  self.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathDefault, srcPathDefault );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileRename( dstPathSecond, srcPathSecond );
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.fileRename( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  self.system.providerRegister( provider );

  test.close( 'without system' );
}

//

function fileRenameRelativeLinking( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRename ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/fileRenameRelativeLinking' );
  let src1Path = test.context.pathFor( 'written/fileRenameRelativeLinking/src1' );
  let src2Path = test.context.pathFor( 'written/fileRenameRelativeLinking/src2' );
  let src3Path = test.context.pathFor( 'written/fileRenameRelativeLinking/src3' );
  let dstPath = test.context.pathFor( 'written/fileRenameRelativeLinking/dst' );

  /*
    src1 -> ../src2
    fileRename dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    fileRename dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    fileRename dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    fileRename dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /*  */

  test.case = 'relative link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.fileRename
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src2Path );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename
  ({
    srcPath : src1Path,
    dstPath,
    resolvingSrcSoftLink : 2,
    resolvingSrcTextLink : 0,
    rewriting : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileRename
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.fileRename
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 2,
    resolvingSrcTextLink : 0,
    rewriting : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.fileRename({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.identical( provider.fileRead( dstPath ), src3Path );
}

//

function fileDeleteSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var isExtract = false;

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  isExtract = true;

  var routinePath = test.context.pathFor( 'written/fileDelete' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'removing not existing path';

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 1,
      throwing : 1
    })
  });

  /**/

  test.mustNotThrowError( function()
  {
    var got = provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 1,
      throwing : 0
    });
    test.identical( got, null );
  });

  //

  test.case = 'removing existing file';
  var filePath = test.context.pathFor( 'written/fileDelete/file.txt');

  /**/

  provider.fileWrite( filePath, ' ' );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 0
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  /**/

  provider.fileWrite( filePath, ' ' );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 1
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  //

  test.case = 'removing empty folder';
  var filePath = test.context.pathFor( 'written/fileDelete/folder');

  /**/

  provider.dirMake( filePath );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 0
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  /**/

  provider.dirMake( filePath );
  provider.fileDelete
  ({
    filePath,
    sync : 1,
    throwing : 1
  });
  var stat = provider.statResolvedRead( filePath );
  test.identical( stat, null );

  //

  test.case = 'try removing folder with file';
  var filePath = test.context.pathFor( 'written/fileDelete/folder/file.txt');
  var folder = self.provider.path.dir( filePath );

  /**/

  provider.fileWrite( filePath,' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileDelete
    ({
      filePath : folder,
      sync : 1,
      throwing : 1
    })
  });
  var stat = provider.statResolvedRead( folder );
  test.is( !!stat );

  /**/

  test.mustNotThrowError( () =>
  {
    provider.fileDelete
    ({
      filePath : folder,
      sync : 1,
      throwing : 0
    });
  })

  var stat = provider.statResolvedRead( folder );
  test.is( !!stat );

  if( provider.constructor.name === 'wFileProviderExtract' )
  {
    test.case = 'try to remove filesTree';

    //

    // test.shouldThrowErrorSync( function()
    // {
    //   provider.fileDelete
    //   ({
    //     filePath : '.',
    //     sync : 1,
    //     throwing : 1
    //   });
    // })

    /**/

    test.shouldThrowErrorSync( function()
    {
      provider.filesTree = {};
      provider.fileDelete
      ({
        filePath : '/',
        sync : 1,
        throwing : 1
      });
    })

    /**/

    // test.mustNotThrowError( function()
    // {
    //   var got = provider.fileDelete
    //   ({
    //     filePath : '.',
    //     sync : 1,
    //     throwing : 0
    //   });
    //   test.identical( got, null );
    // })
    // var stat = provider.statResolvedRead( '.' );
    // test.is( !!stat );

    /**/

    test.shouldThrowErrorSync( function()
    {
      provider.filesTree = {};
      provider.fileDelete
      ({
        filePath : '/',
        sync : 1,
        throwing : 1
      });
    })
    var stat = provider.statResolvedRead( '/' );
    test.is( !!stat );
  }

  //

  var filePath = path.join( routinePath, 'file' );

  //

  // test.case = 'delete soft link, resolvingHardLink 1';
  // provider.filesDelete( routinePath );
  // provider.fieldPush( 'resolvingHardLink', 1 );
  // var dst = path.join( routinePath, 'link' );
  // provider.fileWrite( filePath, ' ');
  // provider.hardLink( dst, filePath );
  // provider.fileDelete( dst )
  // var stat = provider.statResolvedRead( dst );
  // test.identical( stat, null );
  // var stat = provider.statResolvedRead( filePath );
  // test.is( !!stat );
  // provider.fieldPop( 'resolvingHardLink', 1 );

  // test.case = 'delete soft link, resolvingHardLink 0';
  // provider.filesDelete( routinePath );
  // provider.fieldPush( 'resolvingHardLink', 0 );
  // var dst = path.join( routinePath, 'link' );
  // provider.fileWrite( filePath, ' ');
  // provider.hardLink( dst, filePath );
  // provider.fileDelete( dst )
  // var stat = provider.statResolvedRead( dst );
  // test.identical( stat, null );
  // var stat = provider.statResolvedRead( filePath );
  // test.is( !!stat );
  // provider.fieldPop( 'resolvingHardLink', 0 );

  //

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'delete soft link, resolvingSoftLink 1';
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var dst = path.join( routinePath, 'link' );
  provider.fileWrite( filePath, ' ');
  provider.softLink( dst, filePath );
  provider.fileDelete( dst )
  var stat = provider.statResolvedRead( dst );
  test.identical( stat, null );
  var stat = provider.statResolvedRead( filePath );
  test.is( !!stat );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  test.case = 'delete soft link, resolvingSoftLink 0';
  provider.filesDelete( routinePath );
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var dst = path.join( routinePath, 'link' );
  provider.fileWrite( filePath, ' ');
  provider.softLink( dst, filePath );
  provider.fileDelete( dst )
  var stat = provider.statResolvedRead( dst );
  test.identical( stat, null );
  var stat = provider.statResolvedRead( filePath );
  test.is( !!stat );
  provider.fieldPop( 'resolvingSoftLink', 0 );
}

//

function fileDeleteActSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.case = 'fileDeleteAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'fileDeleteActSync' );

  //

  test.case = 'basic usage';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  provider.fileDeleteAct( o );
  test.identical( o, expected );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  //

  test.case = 'no src';
  var srcPath = path.join( routinePath,'src' );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  })
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );

  //

  test.case = 'src is empty dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.dirMake( srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  provider.fileDeleteAct( o );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  //

  test.case = 'src is empty dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : routinePath,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  })
  var stat = provider.statResolvedRead( routinePath );
  test.is( !!stat );
  provider.filesDelete( routinePath );

  //

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  provider.fileDeleteAct( o );
  test.identical( o, expected );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.fileDeleteAct( o );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  var stat = provider.statResolvedRead( srcPath );
  test.is( !stat );
  provider.filesDelete( routinePath );

  //

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './src';

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct
    ({
      filePath : srcPath,
      sync : 1
    });
  })

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );

  /* sync option is missed */

  var o =
  {
    filePath : srcPath,
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  });

  /* redundant option */

  var o =
  {
    filePath : srcPath,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  });

  //

  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.case = 'should expect normalized path, but not nativized';
    var srcPath = path.join( routinePath,'src' );
    provider.fileWrite( srcPath, srcPath );
    var o =
    {
      filePath : srcPath,
      sync : 1
    }
    var originalPath = o.filePath;
    o.filePath = provider.path.nativize( o.filePath );
    if( o.filePath !== originalPath )
    {
      test.shouldThrowErrorOfAnyKind( () =>
      {
        provider.fileDeleteAct( o );
      })
    }
    else
    {
      test.mustNotThrowError( () =>
      {
        provider.fileDeleteAct( o );
      })
    }
    provider.filesDelete( routinePath );
  }

  //

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath,'src' );
  var o =
  {
    filePath : [ srcPath ],
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.fileDeleteAct( o );
  })
  test.identical( o.filePath, expected.filePath );
}

//

function fileDeleteAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileDeleteAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var isExtract = false;

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  isExtract = true;

  var filePath,folder;

  var routinePath = test.context.pathFor( 'written/fileDeleteAsync' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing not existing path';
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.fileDelete
    ({
      filePath : test.context.pathFor( 'not_existing_path' ),
      sync : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( ( got ) => test.identical( got, null ) );

  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing file';
    filePath = test.context.pathFor( 'written/fileDeleteAsync/file.txt');
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath,' ' );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath,' ' );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 1
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing existing empty folder';
    filePath = test.context.pathFor( 'written/fileDeleteAsync/folder');
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( filePath );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.dirMake( filePath );
    var con = provider.fileDelete
    ({
      filePath,
      sync : 0,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var stat = provider.statResolvedRead( filePath );
      test.identical( stat, null );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'removing existing folder with file';
    filePath = test.context.pathFor( 'written/fileDeleteAsync/folder/file.txt');
    return null;

  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    folder = self.provider.path.dir( filePath );
    provider.fileWrite( filePath,' ' );
    var con = provider.fileDelete
    ({
      filePath : folder,
      sync : 0,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function( err, arg )
    {
      var stat = provider.statResolvedRead( folder );
      test.is( !!stat );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.fileDelete
    ({
      filePath : folder,
      sync : 0,
      throwing : 0
    });

    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      var stat = provider.statResolvedRead( folder );
      test.is( !!stat );
      test.identical( got, null )
      return got;
    });
  })
  .ifNoErrorThen( function( arg )
  {
    if( provider.constructor.name !== 'wFileProviderExtract' )
    return null;

    test.case = 'try to remove filesTree';

    //

    return test.shouldThrowErrorOfAnyKind( function()
    {
      return provider.fileDelete
      ({
        filePath : '.',
        sync : 0,
        throwing : 1
      });
    })
    .finally( function()
    {
      return test.shouldThrowErrorOfAnyKind( function()
      {
        provider.filesTree = {};
        return provider.fileDelete
        ({
          filePath : '/',
          sync : 0,
          throwing : 1
        });
      })
    })
    .finally( function()
    {
      return test.shouldThrowErrorOfAnyKind( function()
      {
        return provider.fileDelete
        ({
          filePath : '.',
          sync : 0,
          throwing : 1
        });
      })
    })
    .finally( function()
    {
      provider.filesTree = {};
      let con = provider.fileDelete
      ({
        filePath : '/',
        sync : 0,
        throwing : 1
      });
      return test.shouldThrowErrorOfAnyKind( con );
    })
  })
  .finally( () =>
  {
    filePath = path.join( routinePath, 'file' );
    return null;
  })
  // .ifNoErrorThen( ( arg ) =>
  // {
  //   test.case = 'delete hard link, resolvingHardLink 1';
  //   provider.filesDelete( routinePath );
  //   provider.fieldPush( 'resolvingHardLink', 1 );
  //   var dst = path.join( routinePath, 'link' );
  //   provider.fileWrite( filePath, ' ');
  //   provider.hardLink( dst, filePath );
  //   return provider.fileDelete
  //   ({
  //     filePath : dst,
  //     sync : 0,
  //     throwing : 1
  //   })
  //   .ifNoErrorThen( ( arg ) =>
  //   {
  //     var stat = provider.statResolvedRead( dst );
  //     test.identical( stat, null );
  //     var stat = provider.statResolvedRead( filePath );
  //     test.is( !!stat );
  //     provider.fieldPop( 'resolvingHardLink', 1 );
  //   })
  // })
  // .ifNoErrorThen( ( arg ) =>
  // {
  //   test.case = 'delete hard link, resolvingHardLink 0';
  //   provider.filesDelete( routinePath );
  //   provider.fieldPush( 'resolvingHardLink', 0 );
  //   var dst = path.join( routinePath, 'link' );
  //   provider.fileWrite( filePath, ' ');
  //   provider.hardLink( dst, filePath );
  //   return provider.fileDelete
  //   ({
  //     filePath : dst,
  //     sync : 0,
  //     throwing : 1
  //   })
  //   .ifNoErrorThen( ( arg ) =>
  //   {
  //     var stat = provider.statResolvedRead( dst );
  //     test.identical( stat, null );
  //     var stat = provider.statResolvedRead( filePath );
  //     test.is( !!stat );
  //     provider.fieldPop( 'resolvingHardLink', 0 );
  //   })
  // });

  if( !test.context.softLinkIsSupported() )
  return consequence;

  consequence.ifNoErrorThen( ( arg ) =>
  {
    var filePath = path.join( routinePath, 'file' );
    test.case = 'delete soft link, resolvingSoftLink 1';
    provider.fieldPush( 'resolvingSoftLink', 1 );
    var dst = path.join( routinePath, 'link' );
    provider.fileWrite( filePath, ' ');
    provider.softLink( dst, filePath );
    return provider.fileDelete
    ({
      filePath : dst,
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      var stat = provider.statResolvedRead( dst );
      test.identical( stat, null );
      var stat = provider.statResolvedRead( filePath );
      test.is( !!stat );
      provider.fieldPop( 'resolvingSoftLink', 1 );
      return null;
    })

  })
  .ifNoErrorThen( ( arg ) =>
  {
    test.case = 'delete soft link, resolvingSoftLink 0';
    provider.filesDelete( routinePath );
    provider.fieldPush( 'resolvingSoftLink', 0 );
    var dst = path.join( routinePath, 'link' );
    provider.fileWrite( filePath, ' ');
    provider.softLink( dst, filePath );
    return provider.fileDelete
    ({
      filePath : dst,
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( ( arg ) =>
    {
      var stat = provider.statResolvedRead( dst );
      test.identical( stat, null );
      var stat = provider.statResolvedRead( filePath );
      test.is( !!stat );
      provider.fieldPop( 'resolvingSoftLink', 0 );
      return null;
    })
  })

  return consequence;

}

//

function fileDeleteLocked( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let skip = !self.providerIsInstanceOf( _.FileProvider.HardDrive ) || self.providerIsInstanceOf( _.FileProvider.System );

  if( skip )
  {
    test.identical( 1,1 );
    return;
  }

  if( process.platform != 'win32' )
  {
    test.identical( 1,1 );
    return;
  }

  //

  let fs = require( 'fs' );
  let routinePath = self.pathFor( 'write/fileDeleteLocked' );
  let terminalPath = path.join( routinePath, 'terminal' );

  test.case = 'try to delete opened file, using fs.openSync';
  provider.fileWrite( terminalPath, terminalPath );
  var fd = fs.openSync( provider.path.nativize( terminalPath ), 'r' );
  var got = fs.unlinkSync( path.nativize( terminalPath ) );
  test.will = 'no errors from fs module';
  test.identical( got, undefined );
  test.will = 'test dir can`t be deleted because is not empty';
  test.shouldThrowErrorSync( () => fs.rmdirSync( path.nativize( routinePath ) ) );
  test.will = 'terminal still exists';
  test.is( provider.fileExists( terminalPath ) );
  test.will = 'can`t be read';
  test.shouldThrowErrorSync( () => provider.fileRead( terminalPath ) );
  test.will = 'can`t be written';
  test.shouldThrowErrorSync( () => provider.fileWrite( terminalPath, terminalPath ) );
  fs.closeSync( fd );
  test.will = 'terminal is closed and removed';
  test.is( !provider.fileExists( terminalPath ) );

  //

  test.case = 'try to delete opened file, using fileDelete';
  provider.fileWrite( terminalPath, terminalPath );
  var fd = fs.openSync( provider.path.nativize( terminalPath ), 'r' );
  var got = provider.fileDelete( terminalPath );
  test.will = 'terminal should be removed';
  test.is( !provider.fileExists( terminalPath ) );
  var read = provider.dirRead( routinePath );
  test.identical( read, [] );
  provider.fileDelete( routinePath );
  test.is( !provider.fileExists( routinePath ) );
  test.will = 'file is still available through fd';
  var buffer = BufferNode.alloc( 50 );
  fs.readSync( fd, buffer, 0, buffer.byteLength );
  var got =  buffer.toString();
  test.is( got.length )
  test.is( _.strHas( terminalPath, got ) )
  fs.closeSync( fd );
  test.will = 'terminal is closed and removed';
  test.is( !provider.fileExists( terminalPath ) );

  //

  // for( let i = 0; i < 1000; i++ )
  // {
  //   provider.fileWrite( terminalPath, terminalPath );
  //   var fd = fs.openSync( provider.path.nativize( terminalPath ), 'r' );
  //   provider.fileDelete( terminalPath );
  //   test.is( !provider.fileExists( terminalPath ) );
  //   fs.closeSync( fd );
  // }

  //

  test.case = 'try to delete opened file using fs.createReadStream';
  provider.fileWrite( terminalPath, terminalPath );
  var stream = provider.streamRead( terminalPath );
  var got = fs.unlinkSync( path.nativize( terminalPath ) );
  test.will = 'no errors from fs module';
  test.identical( got, undefined );
  test.will = 'test dir can`t be deleted because is not empty';
  test.shouldThrowErrorSync( () => fs.rmdirSync( path.nativize( routinePath ) ) );
  test.will = 'terminal still exists';
  test.is( provider.fileExists( terminalPath ) );
  test.will = 'can`t be read';
  test.shouldThrowErrorSync( () => provider.fileRead( terminalPath ) );
  test.will = 'can`t be written';
  test.shouldThrowErrorSync( () => provider.fileWrite( terminalPath, terminalPath ) );
  stream.close();
  return _.timeOut( 1000, () =>
  {
    test.will = 'terminal is closed and removed';
    test.is( stream.closed );
    test.is( !provider.fileExists( terminalPath ) );
  })


}

//

function fileDeletePerfomance( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;
  let routinePath = self.pathFor( 'write/fileDeletePerfomance' );
  let files = 1;

  var data = _.strDup( 'terminal', 1000000 );
  data = _.strDup( data, 1000 );
  var filePaths = [];

  for( var i = 0; i < files; i++ )
  {
    let filePath = path.join( routinePath, 'terminal' + i );
    filePaths.push( filePath );
    provider.fileWrite( filePath, data )
  }

  var t = _.timeNow();
  for( var i = 0; i < files; i++ )
  provider.fileDeleteAct({ filePath : filePaths[ i ], sync : 1 });
  var spent = _.timeSpent( t );
  console.log( spent, 'for', files, 'files' );

}

fileDeletePerfomance.experimental = 1;

//

function statResolvedReadSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/statResolvedRead' );
  var filePath,expected;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  filePath = test.context.pathFor( 'read/statResolvedRead/src.txt' );
  provider.fileWrite( filePath, 'Excepteur sint occaecat cupidatat non proident' );
  test.case = 'synchronous file stat default options';
  expected = 46;

  /**/

  var got = provider.statResolvedRead( filePath );
  if( _.bigIntIs( got.size ) )
  expected = BigInt( expected );
  test.identical( got.size, expected );

  /**/

  var got = provider.statResolvedRead
  ({
    sync : 1,
    filePath,
    throwing : 1
  });
  if( _.bigIntIs( got.size ) )
  expected = BigInt( expected );
  test.identical( got.size, expected );

  //

  test.case = 'invalid path';
  filePath = test.context.pathFor( '///bad path///test.txt' );

  /**/

  var got = provider.statResolvedRead
  ({
    sync : 1,
    filePath,
    throwing : 0
  });
  var expected = null;
  test.identical( got, expected );

  /**/

  test.shouldThrowErrorSync( function()
  {
    var got = provider.statResolvedRead
    ({
      sync : 1,
      filePath,
      throwing : 1
    });
  });
}

//

function statReadActSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.statReadAct ) )
  {
    test.case = 'statReadAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'statReadActSync' );

  let expectedNlinkDir = 1;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  if( process.platform != 'win32' )
  expectedNlinkDir = 2;

  provider.fieldPush( 'usingTextLink', 1 );

  /* - */

  test.case = 'regular terminal';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.fileWrite( file2Path, '' );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 0 ) );
  else
  test.identical( stat.size, 0 );

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'hard link';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.hardLink( file2Path, file1Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 2 ) )
  else
  test.identical( stat.nlink, 2 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 2 ) )
  else
  test.identical( stat.nlink, 2 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'soft link';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.softLink( file2Path, file1Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( !stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  // test.identical( stat.size, null );

  test.description = 'file2, resolving';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  provider.filesDelete( routinePath );

  // /* - */

  test.case = 'text link';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.fileWrite( file1Path, 'file1' );
  provider.textLink( file2Path, file1Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  if( provider.UsingBigIntForStat )
  test.identical( stat.size, BigInt( 5 ) );
  else
  test.identical( stat.size, 5 );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = self.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size , BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  //

  provider.fieldPush( 'usingTextLink', 0 );

  test.description = 'file2, usingTextLink off';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = self.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size , BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  test.description = 'file2, resolving, , usingTextLink off';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = self.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size , BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  provider.fieldPop( 'usingTextLink', 0 );

  //

  test.description = 'file2, resolving';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( !stat.isDir() );
  test.is( stat.isTerminal() );
  test.is( stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( 1 ) )
  else
  test.identical( stat.nlink, 1 );
  var read = self.provider.fileRead( file2Path );
  if( provider.UsingBigIntForStat )
  test.ge( stat.size , BigInt( read.length ) );
  else
  test.identical( stat.size, read.length );

  provider.filesDelete( routinePath );

  /* - */

  test.case = 'directory';
  var file1Path = path.join( routinePath, 'file1' );
  var file2Path = path.join( routinePath, 'file2' );
  provider.dirMake( file1Path );
  provider.dirMake( file2Path );

  test.description = 'file1';
  var o =
  {
    filePath : file1Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( stat.isDir() );
  test.is( !stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( expectedNlinkDir ) )
  else
  test.identical( stat.nlink, expectedNlinkDir );
  if( provider.UsingBigIntForStat )
  test.is( stat.size >= BigInt( 0 ) || stat.size === null );
  else
  test.is( stat.size >= 0 || stat.size === null );

  test.description = 'file2';
  var o =
  {
    filePath : file2Path,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var o2 = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, o2 );
  test.is( !!stat );
  test.is( stat.isDir() );
  test.is( !stat.isTerminal() );
  test.is( !stat.isTextLink() );
  test.is( !stat.isSoftLink() );
  test.is( !stat.isHardLink() );
  test.is( !stat.isLink() );
  test.is( !stat.isBlockDevice() );
  test.is( !stat.isCharacterDevice() );
  test.is( !stat.isFIFO() );
  test.is( !stat.isSocket() );
  if( provider.UsingBigIntForStat )
  test.identical( stat.nlink, BigInt( expectedNlinkDir ) )
  else
  test.identical( stat.nlink, expectedNlinkDir );
  if( provider.UsingBigIntForStat )
  test.is( stat.size >= BigInt( 0 ) || stat.size === null );
  else
  test.is( stat.size >= 0 || stat.size === null );

  /* - */

  test.case = 'basic usage, should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var expected = _.mapExtend( null, o );
  // expected.filePath = provider.path.nativize( o.filePath );
  var stat = provider.statReadAct( o );
  test.identical( o, expected );
  test.is( !!stat );
  provider.filesDelete( routinePath );

  //

  test.case = 'no src';
  var srcPath = path.join( routinePath,'src' );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1
  }
  var expected = _.mapExtend( null, o );
  var stat = provider.statReadAct( o );
  test.identical( o, expected );
  test.is( !stat );
  provider.filesDelete( routinePath );

  //

  test.case = 'no src';
  var srcPath = path.join( routinePath,'src' );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 1,
    resolvingSoftLink : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () => provider.statReadAct( o ) );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1
  }
  var expected = _.mapOwnKeys( o );
  // expected.filePath = provider.path.nativize( o.filePath );
  var stat = provider.statReadAct( o );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  test.is( !!stat );
  provider.filesDelete( routinePath );

  //

  if( test.context.softLinkIsSupported() )
  {
    test.case = 'src is a soft link';
    var srcPath = path.join( routinePath,'src' );
    var dstPath = path.join( routinePath,'dst' );
    provider.fileWrite( srcPath, srcPath );
    provider.softLink( dstPath, srcPath );
    var o =
    {
      filePath : dstPath,
      sync : 1,
      throwing : 0,
      resolvingSoftLink : 1
    }
    var stat = provider.statReadAct( o );
    test.is( !!stat );
    test.is( !stat.isSoftLink() );
    provider.filesDelete( routinePath );

    //

    test.case = 'src is a soft link';
    var srcPath = path.join( routinePath,'src' );
    var dstPath = path.join( routinePath,'dst' );
    provider.fileWrite( srcPath, srcPath );
    provider.softLink( dstPath, srcPath );
    var o =
    {
      filePath : dstPath,
      sync : 1,
      throwing : 0,
      resolvingSoftLink : 0
    }
    var stat = provider.statReadAct( o );
    test.is( !!stat );
    test.is( stat.isSoftLink() );
    provider.filesDelete( routinePath );
  }

  //

  if( !Config.debug )
  return;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.case = 'should assert that path is absolute';
    var srcPath = './src';

    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.statReadAct
      ({
        filePath : srcPath,
        sync : 1,
        throwing : 0,
        resolvingSoftLink : 1
      });
    })
  }



  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct
    ({
      filePath : srcPath,
      sync : 1,
      throwing : 1,
      resolvingSoftLink : 1
    });
  })

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );

  /* sync option is missed */

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct
    ({
      filePath : srcPath,
      throwing : 0,
      resolvingSoftLink : 1
    });
  });

  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct
    ({
      filePath : srcPath,
      throwing : 1,
      resolvingSoftLink : 1
    });
  });

  /* redundant option */

  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  });

  //

  var o =
  {
    filePath : srcPath,
    sync : 1,
    throwing : 1,
    resolvingSoftLink : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  });

  //

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );

  //

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    var o =
    {
      filePath : srcPath,
      sync : 1,
      throwing : 0,
      resolvingSoftLink : 1,
    }
    var originalPath = o.filePath;
    o.filePath = provider.path.nativize( o.filePath );
    if( o.filePath !== originalPath )
    {
      test.shouldThrowErrorOfAnyKind( () =>
      {
        provider.statReadAct( o );
      })
    }
    else
    {
      test.mustNotThrowError( () =>
      {
        provider.statReadAct( o );
      })
    }
    provider.filesDelete( routinePath );

    //

    var o =
    {
      filePath : srcPath,
      sync : 1,
      throwing : 1,
      resolvingSoftLink : 1,
    }
    o.filePath = provider.path.nativize( o.filePath );
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.statReadAct( o );
    })
    provider.filesDelete( routinePath );
  }

  //

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath,'src' );

  //

  var o =
  {
    filePath : [ srcPath ],
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  })
  test.identical( o.filePath, expected.filePath );

  //

  var o =
  {
    filePath : [ srcPath ],
    sync : 1,
    throwing : 1,
    resolvingSoftLink : 1,
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.statReadAct( o );
  })
  test.identical( o.filePath, expected.filePath );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function statResolvedReadAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/statResolvedReadAsync' );
  var filePath,expected;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  //

  consequence
  .ifNoErrorThen( function( arg )
  {
    filePath = test.context.pathFor( 'read/statResolvedReadAsync/src.txt' );
    provider.fileWrite( filePath, 'Excepteur sint occaecat cupidatat non proident' );
    test.case = 'synchronous file stat default options';
    expected = 46;
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    debugger
    return provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      if( _.bigIntIs( got.size ) )
      expected = BigInt( expected );
      test.identical( got.size, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      if( _.bigIntIs( got.size ) )
      expected = BigInt( expected );
      test.identical( got.size, expected );
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'invalid path';
    filePath = test.context.pathFor( '///bad path///test.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = null;
      test.identical( got, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.statResolvedRead
    ({
      sync : 0,
      filePath,
      throwing : 1
    });

    return test.shouldThrowErrorOfAnyKind( con )
  });

  return consequence;
}

//

function statReadActLinkedHead( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var routinePath = test.context.pathFor( 'written/statReadActLinkedHead' )
  var dirPath = path.join( routinePath, 'dir' );
  var dirPath2 = path.join( routinePath, 'dir2' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var terminalLinkPath = path.join( dirPath, 'terminalLink' );
  var linkPath = path.join( routinePath, 'link' );
  var linkPath2 = path.join( dirPath2, 'link2' );

  /**/

  test.case = 'intermediate soft link to directory with terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'intermediate soft link to directory with terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'intermediate soft link to directory with soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'intermediate soft link to directory with soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'intermediate soft link to directory with missing file';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'intermediate soft link to directory with missing file';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath, dirPath );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'intermediate soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, terminalPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'intermediate soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath, terminalPath );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'soft->soft->dir/terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'soft->soft->dir/terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'soft->soft->dir/soft->terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'soft->soft->dir/soft->terminal';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'soft->soft->dir/missing';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'soft->soft->dir/missing';
  var linkPath2 = path.join( routinePath, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToRead = path.join( routinePath, 'link/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'two intermediate links in path, soft/soft/terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminal' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'two intermediate links in path, soft/soft/missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/missing' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->terminal';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( terminalLinkPath, terminalPath );
  provider.dirMake( dirPath2 );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isTerminal() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink({ dstPath : terminalLinkPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 0,
  }
  var got = provider.statReadAct( o );
  test.is( _.fileStatIs( got ) );
  test.is( got.isSoftLink() );

  /**/

  test.case = 'two intermediate links in path, soft/soft/soft->missing';
  var linkPath2 = path.join( dirPath2, 'link2' );
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.dirMake( dirPath2 );
  provider.softLink({ dstPath : terminalLinkPath, srcPath : terminalPath, allowingMissed : 1 });
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, dirPath2 );
  var pathToRead = path.join( routinePath, 'link/link2/terminalLink' );
  var o =
  {
    filePath : pathToRead,
    sync : 1,
    throwing : 0,
    resolvingSoftLink : 1,
  }
  var got = provider.statReadAct( o );
  test.identical( got, null );

}

//

function dirMakeSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirMakeAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  if( Config.interpreter === 'browser' )
  if( provider.filesTree )
  provider.filesTree = {};

  var routinePath = test.context.pathFor( 'written/dirMake' );
  var filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'synchronous mkdir';
  filePath = test.context.pathFor( 'written/dirMake/make_dir' );

  /**/

  provider.dirMake( filePath );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'make_dir' ] );

  //

  test.case = 'synchronous mkdir force';
  provider.filesDelete( filePath );
  filePath = test.context.pathFor( 'written/dirMake/make_dir/dir1' );

  /**/
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1
  });
  var files = provider.dirRead( self.provider.path.dir( filePath ) );
  test.identical( files, [ 'dir1' ] );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.filesDelete( self.provider.path.dir( filePath ) );
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0
    });
  })

  //

  test.case = 'try to rewrite terminal file';
  filePath = test.context.pathFor( 'written/dirMake/terminal.txt' );
  provider.fileWrite( filePath, ' ' );

  /**/

  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( self.provider.path.dir( filePath ) );
  test.identical( files, [ 'terminal.txt' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 1,
      rewritingTerminal : 0
    });
  })

  //

  test.case = 'try to rewrite empty dir';
  filePath = test.context.pathFor( 'written/dirMake/empty' );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( self.provider.path.dir( filePath ) );
  test.identical( files, [ 'empty' ] );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'empty' ] );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  provider.dirMake
  ({
    filePath,
    sync : 1,
    recursive : 1,
    rewritingTerminal : 0
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'empty' ] );

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 1
    });
  });

  /**/

  provider.filesDelete( routinePath )
  provider.dirMake( filePath );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  //

  test.case = '/dir exists, no rewritingTerminal, no force';
  filePath = test.context.pathFor( 'written/dirMake/make_dir/' );

  /**/

  // provider.filesDelete( filePath );
  provider.dirMake( filePath );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath,
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  //

  test.case = 'try to rewrite folder with files';
  filePath = test.context.pathFor( 'written/dirMake/make_dir/file' );
  provider.filesDelete( routinePath );

  /**/

  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 1,
      recursive : 0,
      rewritingTerminal : 1
    });
  });

  /**/

  provider.fileWrite( filePath, ' ' );
  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 1,
      recursive : 0,
      rewritingTerminal : 0
    });
  });

  /**/

  provider.fileWrite( filePath, ' ' );
  provider.dirMake
  ({
    filePath : self.provider.path.dir( filePath ),
    sync : 1,
    recursive : 1,
    rewritingTerminal : 1
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'make_dir' ] );


  //

  test.case = 'folders structure not exist';
  provider.filesDelete( routinePath );
  filePath = test.context.pathFor( 'written/dirMake/routinePath' );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
        filePath,
        sync : 1,
        recursive : 0,
        rewritingTerminal : 0
    });
  });

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.dirMake
    ({
        filePath,
        sync : 1,
        recursive : 0,
        rewritingTerminal : 1
    });
  });

  /**/

  provider.dirMake
  ({
      filePath,
      sync : 1,
      recursive : 1,
      rewritingTerminal : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );

  /**/

  provider.filesDelete( routinePath );
  provider.dirMake
  ({
      filePath,
      sync : 1,
      recursive : 1,
      rewritingTerminal : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'routinePath' ] );
}

//

function dirMakeLinksSync( test )
{
  let self = this;
  let provider = self.provider;

  let routinePath = self.pathFor( 'written/dirMakeLinksSync' );
  let dirPath = self.pathFor( 'written/dirMakeLinksSync/dir' );
  let filePath = self.pathFor( 'written/dirMakeLinksSync/file' );
  let fileInDir = self.pathFor( 'written/dirMakeLinksSync/dir/file' );
  let linkToDir = self.pathFor( 'written/dirMakeLinksSync/link' );

  test.case = 'link to missing';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath, allowingMissed : 1, makingDirectory : 1 });
  provider.dirMake({ filePath : linkToDir, recursive : 1 });
  test.is( provider.isDir( dirPath ) );

  test.case = 'link to missing';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath, allowingMissed : 1, makingDirectory : 1 });
  provider.dirMake({ filePath : linkToDir, recursive : 0 });
  test.is( provider.isDir( dirPath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  provider.dirMake({ filePath : linkToDir, recursive : 1, rewritingTerminal : 1 });
  test.is( provider.isDir( filePath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 1,
      rewritingTerminal : 0
    });
  })
  test.is( provider.isTerminal( filePath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  provider.dirMake({ filePath : linkToDir, recursive : 0, rewritingTerminal : 1 });
  test.is( provider.isDir( filePath ) );

  test.case = 'link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkToDir, srcPath : filePath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 0,
      rewritingTerminal : 0
    });
  })
  test.is( provider.isTerminal( filePath ) );

  test.case = 'link to empty dir';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  provider.dirMake({ filePath : linkToDir, recursive : 1 });
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [] )

  test.case = 'link to empty dir';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 0,
    });
  })
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [] )

  test.case = 'link to dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDir,fileInDir );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  provider.dirMake({ filePath : linkToDir, recursive : 1 });
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [ 'file' ] )

  test.case = 'link to dir';
  provider.filesDelete( routinePath );
  provider.fileWrite( fileInDir,fileInDir );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : linkToDir,
      recursive : 0,
    });
  })
  test.is( provider.isDir( dirPath ) );
  test.is( provider.isSoftLink( linkToDir ) );
  test.identical( provider.dirRead( dirPath ), [ 'file' ] )

  test.case = 'intermediate link, one dir to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory' );
  provider.dirMake({ filePath : path, recursive : 1 })
  test.is( provider.isDir( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

  test.case = 'intermediate link, one dir to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory' );
  provider.dirMake({ filePath : path, recursive : 0 })
  test.is( provider.isDir( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

  test.case = 'intermediate link, severals dirs to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory/directory2/directory3' );
  provider.dirMake({ filePath : path, recursive : 1 })
  test.is( provider.isDir( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

  test.case = 'intermediate link, severals dirs to create';
  provider.filesDelete( routinePath );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkToDir, srcPath : dirPath });
  var path = provider.path.join( linkToDir, 'directory/directory2/directory3' );
  test.shouldThrowErrorSync( () =>
  {
    provider.dirMake
    ({
      filePath : path,
      recursive : 0,
    });
  })
  test.is( !provider.fileExists( path ) );
  test.is( provider.isSoftLink( linkToDir ) );

}

//

function dirMakeAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirMakeAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  if( Config.interpreter === 'browser' )
  if( provider.filesTree )
  provider.filesTree = {};

  var routinePath = test.context.pathFor( 'written/dirMakeAsync' );
  var filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  //

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous mkdir';
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'make_dir' ] );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous mkdir force';
    provider.filesDelete( filePath );
    filePath = tes
    t.context.pathFor( 'written/dirMakeAsync/make_dir/dir1/' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( self.provider.path.dir( filePath ) );
      test.identical( files, [ 'dir1' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( self.provider.path.dir( filePath ) );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  //

  .finally( function()
  {
    test.case = 'try to rewrite terminal file';
    filePath = test.context.pathFor( 'written/dirMakeAsync/terminal.txt' );
    provider.fileWrite( filePath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( self.provider.path.dir( filePath ) );
      test.identical( files, [ 'terminal.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( filePath, ' ' );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  //

  .finally( function()
  {
    test.case = 'try to rewrite empty dir';
    filePath = test.context.pathFor( 'written/dirMakeAsync/empty' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( self.provider.path.dir( filePath ) );
      test.identical( files, [ 'empty' ] );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    return provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 1,
      rewritingTerminal : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'empty' ] );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    provider.filesDelete( routinePath )
    provider.dirMake( filePath );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  //

  .finally( function()
  {
    test.case = '/dir exists, no rewritingTerminal, no force';
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir/' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( filePath );
    provider.dirMake( filePath );
    var con = provider.dirMake
    ({
      filePath,
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  //

  .finally( function()
  {
    test.case = 'try to rewrite folder with files';
    filePath = test.context.pathFor( 'written/dirMakeAsync/make_dir/file' );
    provider.filesDelete( routinePath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, ' ' );
    var con = provider.dirMake
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 0,
      recursive : 0,
      rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    provider.fileWrite( filePath, ' ' );
    var con = provider.dirMake
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 0,
      recursive : 0,
      rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    provider.fileWrite( filePath, ' ' );
    return provider.dirMake
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 0,
      recursive : 1,
      rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'make_dir' ] );
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'folders structure not exist';
    provider.filesDelete( routinePath );
    filePath = test.context.pathFor( 'written/dirMakeAsync/routinePath' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.dirMake
    ({
        filePath,
        sync : 0,
        recursive : 0,
        rewritingTerminal : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.dirMake
    ({
        filePath,
        sync : 0,
        recursive : 0,
        rewritingTerminal : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    return provider.dirMake
    ({
        filePath,
        sync : 0,
        recursive : 1,
        rewritingTerminal : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    return provider.dirMake
    ({
        filePath,
        sync : 0,
        recursive : 1,
        rewritingTerminal : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'routinePath' ] );
      return null;
    });
  })

  return consequence;
}



function hashReadSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileReadAct ) ||  !_.routineIs( provider.statReadAct ) || self.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    test.identical( 1, 1 );
    return;
  }

  if( Config.interpreter === 'browser' )
  return;

  var routinePath = test.context.pathFor( 'read/hashRead' );
  var got,filePath,data;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'synchronous filehash';
  data = 'Excepteur sint occaecat cupidatat non proident';
  filePath = test.context.pathFor( 'read/hashRead/src.txt' );

  /**/

  provider.fileWrite( filePath, data );
  got = provider.hashRead( filePath );
  var md5sum = crypto.createHash( 'md5' );
  md5sum.update( data );
  var expected = md5sum.digest( 'hex' );
  test.identical( got, expected );

  //

  test.case = 'invalid path';
  filePath = test.context.pathFor( 'invalid.txt' );

  /**/

  got = provider.hashRead
  ({
     filePath,
     throwing : 0
  });
  var expected = NaN;
  test.identical( got, expected );

  /*invalid path throwing enabled*/

  test.shouldThrowErrorSync( function( )
  {
    provider.hashRead
    ({
      filePath,
      sync : 1,
      throwing : 1
    });
  });

  /*invalid path throwing disabled*/

  test.mustNotThrowError( function( )
  {
    got = provider.hashRead
    ({
      filePath,
      sync : 1,
      throwing : 0
    });
    var expected = NaN;
    test.identical( got, expected );
  });

  /*is not terminal file*/

  test.shouldThrowErrorSync( function( )
  {
    provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 1,
      throwing : 1
    });
  });

  /*is not terminal file, throwing disabled*/

  test.mustNotThrowError( function( )
  {
    got = provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 1,
      throwing : 0
    });
    var expected = NaN;
    test.identical( got, expected );
  });

}

//

function hashReadAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileReadAct ) || !_.routineIs( provider.statReadAct ) || self.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    test.identical( 1, 1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/hashReadAsync' );
  var got,filePath,data;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  if( Config.interpreter === 'browser' )
  return;

  var consequence = new _.Consequence().take( null );

  consequence

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'async filehash';
    data = 'Excepteur sint occaecat cupidatat non proident';
    filePath = test.context.pathFor( 'read/hashReadAsync/src.txt' );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath, data );
    return provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var md5sum = crypto.createHash( 'md5' );
      md5sum.update( data );
      var expected = md5sum.digest( 'hex' );
      test.identical( got, expected );
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'invalid path';
    filePath = test.context.pathFor( 'invalid.txt' );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = NaN;
      test.identical( got, expected );
    });
  })

  /*invalid path throwing enabled*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*invalid path throwing disabled*/

  .finally( function()
  {
    var con = provider.hashRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      var expected = NaN;
      test.identical( got, expected );
    });
  })

  /*is not terminal file*/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*is not terminal file, throwing disabled*/
  .finally( function()
  {
    var con = provider.hashRead
    ({
      filePath : test.context.pathFor( '/' ),
      sync : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      var expected = NaN;
      test.identical( got, expected );
      return null;
    })

  })

  return consequence;
}

//

function dirReadSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirReadAct ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/dirReadAct' );
  var got,filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'synchronous read';
  filePath = test.context.pathFor( 'read/dirRead/1.txt' ),

  /**/

  provider.fileWrite( filePath,' ' );
  var got = provider.dirRead( self.provider.path.dir( filePath ) );
  var expected = [ "1.txt" ];
  test.identical( got.sort(), expected.sort() );

  /**/

  provider.fileWrite( filePath,' ' );
  var got = provider.dirRead
  ({
    filePath : self.provider.path.dir( filePath ),
    sync : 1,
    throwing : 1
  })
  var expected = [ "1.txt" ];
  test.identical( got.sort(), expected.sort() );

  //

  test.case = 'synchronous, filePath points to file';
  filePath = test.context.pathFor( 'read/dirRead/1.txt' );

  /**/

  provider.fileWrite( filePath,' ' )
  var got = provider.dirRead( filePath );
  var expected = [ '1.txt' ];
  test.identical( got, expected );

  /**/

  provider.fileWrite( filePath,' ' )
  var got = provider.dirRead
  ({
    filePath,
    sync : 1,
    throwing : 1
  })
  var expected = [ '1.txt' ];
  test.identical( got, expected );

  //

  test.case = 'path not exist';
  filePath = test.context.pathFor( 'non_existing_folder' );

  /**/

  var got = provider.dirRead( filePath );
  var expected = null;
  test.identical( got, expected );

  /**/

  test.shouldThrowErrorSync( function( )
  {
    provider.dirRead
    ({
      filePath,
      sync : 1,
      throwing : 1
    });
  })
}

//

function dirReadSyncOutputFormats( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirReadAct ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/dirReadSyncOutputFormats' );
  var filePath = path.join( routinePath, 'file' );

  /* absolute */

  test.case = 'missing path';
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'absolute'
  })
  test.identical( got, null );

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'absolute'
  })
  test.identical( got, [ filePath ] );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'absolute'
  })
  test.identical( got, [ filePath ] );

  /* record */

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'record'
  })
  test.identical( got, null);

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'record'
  })
  test.identical( got.length, 1 );
  test.is( got[ 0 ] instanceof _.FileRecord );
  test.identical( got[ 0 ].absolute, filePath );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'record'
  })
  test.identical( got.length, 1 );
  test.is( got[ 0 ] instanceof _.FileRecord );
  test.identical( got[ 0 ].absolute, filePath );

  /* relative */

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative'
  })
  test.identical( got, null );

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative'
  })
  test.identical( got, [ 'file' ] );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'relative'
  })
  test.identical( got, [ 'file' ] );

  /* relative, diff basePath */

  var basePath = path.join( routinePath, 'baseDir' );

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative',
    basePath
  })
  test.identical( got, null );

  test.case = 'terminal';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath,
    outputFormat : 'relative',
    basePath
  })
  test.identical( got, [ test.context.globalFromPreferred( '../file' ) ] );

  test.case = 'directory';
  provider.fileWrite( filePath, filePath );
  var got = provider.dirRead
  ({
    filePath : routinePath,
    outputFormat : 'relative',
    basePath
  })
  test.identical( got, [ test.context.globalFromPreferred( '../file' ) ] );

}

//

function dirReadAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.dirReadAct ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'read/dirReadAsync' );
  var got,filePath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  consequence

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous read';
    filePath = test.context.pathFor( 'read/dirReadAsync/1.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath,' ' );
    return provider.dirRead
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = [ "1.txt" ];
      test.identical( got.sort(), expected.sort() );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath,' ' );
    return provider.dirRead
    ({
      filePath : self.provider.path.dir( filePath ),
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      var expected = [ "1.txt" ];
      test.identical( got.sort(), expected.sort() );
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'synchronous, filePath points to file';
    filePath = test.context.pathFor( 'read/dirReadAsync/1.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath,' ' );
    return provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var got = provider.dirRead( filePath );
      var expected = [ '1.txt' ];
      test.identical( got, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( filePath,' ' );
    return provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      var got = provider.dirRead( filePath );
      var expected = [ '1.txt' ];
      test.identical( got, expected );
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'path not exist';
    filePath = test.context.pathFor( 'non_existing_folder' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      var expected = null;
      test.identical( got, expected );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.dirRead
    ({
      filePath,
      sync : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
  })

  return consequence;
}

//

function fileWriteSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var isHd = test.context.providerIsInstanceOf( _.FileProvider.HardDrive );

  /*writeMode rewrite*/
  try
  {
    provider.dirMake
    ({
      filePath : test.context.pathFor( 'write_test' ),
      sync : 1
    })
  }
  catch ( err ) { }

  /*writeMode rewrite*/
  var data = "LOREM"
  test.case ='rewrite, file not exist ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected )

  test.case ='rewrite existing file ';
  data = "LOREM LOREM";
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );

  test.case = 'encoding : original.type, data: string';
  data = "LOREM LOREM";
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1,
    encoding : 'original.type'
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    encoding : 'original.type',
    sync : 1
  });
  var expected = data;
  if( isHd )
  expected = _.bufferBytesFrom( data );
  test.identical( got, expected );

  test.case = 'encoding : original.type, data: bytes buffer';
  data = new U8x( [ 97,98,99 ] );
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1,
    encoding : 'original.type'
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    encoding : 'original.type',
    sync : 1
  });
  var expected = data;
  if( isHd )
  expected = _.bufferBytesFrom( data );
  test.identical( got, expected );

  test.case = 'encoding : original.type, data: array buffer';
  data = new U8x( [ 97,98,99 ] ).buffer;
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    data,
    sync : 1,
    encoding : 'original.type'
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/dst.txt' ),
    encoding : 'original.type',
    sync : 1
  });
  var expected = data;
  if( isHd )
  expected = _.bufferBytesFrom( data );
  test.identical( got, expected );

  if( isHd )
  {
    test.case = 'encoding : original.type, data: node buffer';
    data = BufferNode.from( [ 97,98,99 ] );
    provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      data,
      sync : 1,
      encoding : 'original.type'
    });
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      encoding : 'original.type',
      sync : 1
    });
    expected = _.bufferBytesFrom( data );
    test.identical( got, expected );
  }

  //

  if( Config.debug )
  {
    test.case ='try write to non existing folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'unknown/dst.txt' ),
        data,
        sync : 1,
        makingDirectory : 0,
      });
    });

    test.case ='try to rewrite folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'write_test' ),
        data,
        sync : 1
      });
    });
  }

  /*writeMode append*/

  provider.filesDelete( test.context.pathFor( 'write_test/append.txt' ) );
  var data = 'APPEND';
  test.case ='append, file not exist ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );

  test.case ='append, to file ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/append.txt' ),
    sync : 1
  });
  var expected = 'APPENDAPPEND';
  test.identical( got, expected );

  //

  if( Config.debug )
  {
    test.case ='try append to non existing folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'unknown/dst.txt' ),
        data,
        writeMode : 'append',
        sync : 1,
        makingDirectory : 0
      });
    });

    test.case ='try to append to folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'write_test' ),
        data,
        writeMode : 'append',
        sync : 1
      });
    });
  }
  /*writeMode prepend*/

  provider.filesDelete( test.context.pathFor( 'write_test/prepend.txt' ) )
  var data = 'Lorem';
  test.case ='prepend, file not exist ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );

  data = 'new text';
  test.case ='prepend to file ';
  provider.fileWrite
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : test.context.pathFor( 'write_test/prepend.txt' ),
    sync : 1
  });
  var expected = 'new textLorem';
  test.identical( got, expected );

  //

  if( Config.debug )
  {
    test.case ='try prepend to non existing folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'unknown/dst.txt' ),
        data,
        writeMode : 'prepend',
        sync : 1,
        makingDirectory : 0
      });
    });

    test.case ='try to prepend to folder';
    test.shouldThrowErrorSync( function()
    {
      provider.fileWrite
      ({
        filePath : test.context.pathFor( 'write_test' ),
        data,
        writeMode : 'prepend',
        sync : 1
      });
    });
  }
}

//

function fileWriteLinksSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var mp = _.routineJoin( test.context, test.context.pathFor );

  var dirPath = mp( 'write_test' );
  var srcPath = mp( 'write_test/src.txt' );
  var dstPath = mp( 'write_test/dst.txt' );
  var data;

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /*writeMode rewrite*/

  //

  provider.filesDelete( dirPath )

  test.case ='rewrite link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.hardLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data : data + data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isHardLink( dstPath ) );
  data = 'rewrite';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data );
  test.is( provider.isHardLink( dstPath ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );

  //

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.hardLink( dstPath, srcPath );
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isHardLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isHardLink( dstPath ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );

  //

  provider.filesDelete( dirPath )

  test.case ='prepend link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.hardLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isHardLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isHardLink( dstPath ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );

  if( !test.context.softLinkIsSupported() )
  return;

  /* soft link */

  provider.filesDelete( dirPath )

  test.case ='rewrite link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data : data + data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isSoftLink( dstPath ) );
  data = 'rewrite';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data );
  test.is( provider.isSoftLink( dstPath ) );

  //

  provider.filesDelete( dirPath )

  test.case ='rewrite link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fieldPush( 'resolvingSoftLink', 0 );
  provider.fileWrite
  ({
    filePath : dstPath,
    data : data + data,
    sync : 1
  });
  provider.fieldPop( 'resolvingSoftLink', 0 );
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );
  data = 'rewrite';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );

  //

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fieldPush( 'resolvingSoftLink', 0 );
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  provider.fieldPop( 'resolvingSoftLink', 0 );
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );
  data = 'append';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );

  //

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fieldPush( 'resolvingSoftLink', 0 );
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  provider.fieldPop( 'resolvingSoftLink', 0 );
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );
  data = 'prepend';
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, expected );
  test.is( !provider.isSoftLink( dstPath ) );

  //

  provider.filesDelete( dirPath )

  test.case ='append link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isSoftLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'append',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isSoftLink( dstPath ) );

  //

  provider.filesDelete( dirPath )

  test.case ='prepend link file ';
  data = "LOREM";
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    sync : 1
  });
  provider.softLink( dstPath, srcPath )
  provider.fileWrite
  ({
    filePath : dstPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : srcPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  var expected = data + data;
  test.identical( got, expected );
  test.is( provider.isSoftLink( dstPath ) );
  provider.fileWrite
  ({
    filePath : srcPath,
    data,
    writeMode : 'prepend',
    sync : 1
  });
  var got = provider.fileRead
  ({
    filePath : dstPath,
    sync : 1
  });
  test.identical( got, data + data + data );
  test.is( provider.isSoftLink( dstPath ) );

}

//

function fileWriteAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var consequence = new _.Consequence().take( null )
  /*writeMode rewrite*/

  .finally( () =>
  {
    provider.filesDelete( test.context.pathFor( 'write_test' ) )
    return provider.dirMake( test.context.pathFor( 'write_test' ) )
  })

  /*writeMode rewrite*/
  var data = "LOREM"
  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case ='rewrite, file not exist ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      data,
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .finally( function( err, got )
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected )
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='rewrite existing file ';
    data = "LOREM LOREM";
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      data,
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .finally( function( err, got )
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/dst.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected );
    return null;
  })
  .finally( function()
  {
    test.case ='try to rewrite folder';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test' ),
      data,
      sync : 0,
      makingDirectory : 0
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })
  /*writeMode append*/
  .finally( function()
  {
    return provider.filesDelete( test.context.pathFor( 'write_test/append.txt' ) );
  })
  .finally( function()
  {
    data = 'APPEND';
    test.case ='append, file not exist ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      data,
      writeMode : 'append',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .finally( function( err, got )
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='append, to file ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      data,
      writeMode : 'append',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .finally( function( err, got )
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/append.txt' ),
      sync : 1
    });
    var expected = 'APPENDAPPEND';
    test.identical( got, expected );
    return null;
  })
  .finally( function()
  {
    test.case ='try to append to folder';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test' ),
      data,
      writeMode : 'append',
      sync : 0
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*writeMode prepend*/
  .finally( function()
  {
    return provider.filesDelete( test.context.pathFor( 'write_test/prepend.txt' ) );
  })
  .finally( function()
  {
    data = 'Lorem';
    test.case ='prepend, file not exist ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      data,
      writeMode : 'prepend',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .finally( function( err, got )
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      sync : 1
    });
    var expected = data;
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    data = 'new text';
    test.case ='prepend to file ';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      data,
      writeMode : 'prepend',
      sync : 0
    });

    return test.returnsSingleResource( con );
  })
  .finally( function( err, got )
  {
    var got = provider.fileRead
    ({
      filePath : test.context.pathFor( 'write_test/prepend.txt' ),
      sync : 1
    });
    var expected = 'new textLorem';
    test.identical( got, expected );
    return null;
  })
  .finally( function()
  {
    test.case ='try prepend to folder';
    var con = provider.fileWrite
    ({
      filePath : test.context.pathFor( 'write_test' ),
      data,
      writeMode : 'prepend',
      sync : 0
    });

    return test.shouldThrowErrorOfAnyKind( con );
  })

  return consequence;
}

fileWriteAsync.timeOut = 30000;

//

function fileWriteLinksAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileWrite ) )
  return;

  var mp = _.routineJoin( test.context, test.context.pathFor );

  var dirPath = mp( 'write_test' );
  var srcPath = mp( 'write_test/src.txt' );
  var dstPath = mp( 'write_test/dst.txt' );
  var data;

  var softLinkIsSupported = test.context.softLinkIsSupported();

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var con = new _.Consequence().take( null )

  //

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )

    test.case ='rewrite link file ';
    data = "LOREM";
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data : data + data,
        sync : 0
      })
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'rewrite';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  //

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )
    var expected;

    test.case ='rewrite link file ';
    data = "LOREM";
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      provider.fieldPush( 'resolvingSoftLink', 0 );
      return provider.fileWrite
      ({
        filePath : dstPath,
        data : data + data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      expected = data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      expected = data + data;
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'rewrite';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  //

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )
    var expected;

    test.case ='rewrite link file ';
    data = "LOREM";
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      provider.fieldPush( 'resolvingSoftLink', 0 );
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'append',
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      expected = data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      expected = data + data;
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'append';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  //

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath )
    var expected;

    test.case ='rewrite link file ';
    data = "LOREM";
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      provider.fieldPush( 'resolvingSoftLink', 0 );
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'prepend',
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.fieldPop( 'resolvingSoftLink', 0 );
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      expected = data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      expected = data + data;
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'prepend';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, expected );
      test.is( !provider.isSoftLink( dstPath ) );
      return null;
    })
  })

  //

  .finally( function()
  {
    provider.filesDelete( dirPath )

    test.case ='rewrite link file ';
    data = "LOREM";
    return provider.fileWrite
    ({
      filePath : srcPath,
      data,
      sync : 0
    })
    .finally( () =>
    {
      provider.hardLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data : data + data,
        sync : 0
      })
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isHardLink( dstPath ) );
      return null;
    })
    .finally( () =>
    {
      data = 'rewrite';
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data );
      test.is( provider.isHardLink( dstPath ) );
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
      return null;
    })
  })

  //append

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath );

    var data;

    return _.timeOut( 2000 )
    .finally( () =>
    {
      test.case ='append link file ';
      data = "LOREM";
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isSoftLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })

  })
  .finally( function()
  {
    provider.filesDelete( dirPath );

    var data;

    return _.timeOut( 2000 )
    .finally( () =>
    {
      test.case ='append link file ';
      data = "LOREM";
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.hardLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isHardLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'append',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isHardLink( dstPath ) );
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
      return null;

    })

  })

  //prepend

  .finally( function()
  {
    if( !softLinkIsSupported )
    return null;

    provider.filesDelete( dirPath );

    var data;

    return _.timeOut( 2000 )
    .finally( () =>
    {
      test.case ='append link file ';
      data = "LOREM";
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.softLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isSoftLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isSoftLink( dstPath ) );
      return null;
    })

  })
  .finally( function()
  {
    provider.filesDelete( dirPath );

    var data;

    return _.timeOut( 2000 )
    .finally( () =>
    {
      test.case ='prepend link file ';
      data = "LOREM";
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        sync : 0
      })
    })
    .finally( () =>
    {
      provider.hardLink( dstPath, srcPath )
      return provider.fileWrite
      ({
        filePath : dstPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : srcPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      var expected = data + data;
      test.identical( got, expected );
      test.is( provider.isHardLink( dstPath ) );
      return provider.fileWrite
      ({
        filePath : srcPath,
        data,
        writeMode : 'prepend',
        sync : 0
      });
    })
    .finally( () =>
    {
      var got = provider.fileRead
      ({
        filePath : dstPath,
        sync : 1
      });
      test.identical( got, data + data + data );
      test.is( provider.isHardLink( dstPath ) );
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
      return null;

    })

  })


  return con;
}

fileWriteLinksAsync.timeOut = 30000;

//

function softLinkSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var routinePath = test.context.pathFor( 'written/softLink' );
  var srcPath,dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'make link sync';
  srcPath  = test.context.pathFor( 'written/softLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/softLink/link.txt' );
  provider.fileWrite( srcPath, '000' );

  /**/

  provider.softLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  provider.fileWrite
  ({
    filePath : srcPath,
    writeMode : 'append',
    data : 'new text',
    sync : 1
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.fileRead( dstPath );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  var expected = '000new text';
  test.identical( got, expected );

  //

  test.case = 'make for file that not exist';
  provider.filesDelete( routinePath );
  srcPath  = test.context.pathFor( 'written/softLink/no_file.txt' );
  dstPath = test.context.pathFor( 'written/softLink/link2.txt' );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, null );

  //

  test.case = 'link already exists';
  srcPath = test.context.pathFor( 'written/softLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/softLink/link.txt' );
  provider.fileWrite( srcPath, 'abc' );
  provider.softLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
  });

  /**/

  test.mustNotThrowError( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  test.mustNotThrowError( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  test.shouldThrowErrorSync( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  });

  /**/

  test.mustNotThrowError( function( )
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  });

  //

  test.case = 'src is equal to dst';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/softLink/link_test.txt' );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.fileDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.fileDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.fileDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  test.is( provider.isSoftLink( srcPath ) );

  /**/

  provider.filesDelete( srcPath );
  test.shouldThrowErrorOfAnyKind( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 1
    });
  });
  test.is( !provider.isSoftLink( srcPath ) );

  /**/

  provider.filesDelete( srcPath );
  test.mustNotThrowError( function()
  {
    got = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 0
    });
  });
  test.is( !provider.isSoftLink( srcPath ) );

  //

  test.case = 'try make softLink to folder';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/softLink/link_test' );
  dstPath = test.context.pathFor( 'written/softLink/link' );
  provider.dirMake( srcPath );

  /**/

  provider.softLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link_test' ]  );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  })

  /**/

  debugger
  provider.softLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 0,
    sync : 1,
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link_test' ]  );

  //

  test.open( 'allowingMissed' );

  provider.softLink
  ({
    srcPath : '../link_test',
    dstPath : srcPath,
    rewriting : 1,
    rewritingDirs : 1,
    throwing : 1,
    sync : 1,
    allowingMissed : 1
  });

  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
  //   test.shouldThrowErrorOfAnyKind(() =>
  //   {
  //     provider.pathResolveLinkFull({ filePath : srcPath, resolvingSoftLink : 1 });
  //   })
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : srcPath, resolvingSoftLink : 1 });
  //   test.identical( got, srcPath )
  // }
  test.mustNotThrowError(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 1,
      throwing : 1
    });
  })

  test.mustNotThrowError(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 1,
      throwing : 0
    });
  })

  test.mustNotThrowError(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 0
    });
  })

  test.shouldThrowErrorOfAnyKind(() =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : srcPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 1
    });
  })

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 1,
    throwing : 0,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      });
    })

    provider.fileWrite( notExistingPath, notExistingPath );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
    test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }


  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 0,
    throwing : 1,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
 // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      });
    })
    provider.fileWrite( notExistingPath, notExistingPath );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
    test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 0,
    throwing : 0,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
 // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      });
    })
    provider.fileWrite( notExistingPath, notExistingPath );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
    test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  provider.softLink
  ({
    srcPath : notExistingPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
// if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      });
    })
    provider.fileWrite( notExistingPath, notExistingPath );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 }).absolutePath;
    test.identical( got, notExistingPath );
  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got, notExistingPath );
  // }

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  //

  var notExistingPath = test.context.pathFor( 'written/softLink/notExisting' );
  provider.filesDelete( notExistingPath );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath : notExistingPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.is( !provider.isSoftLink( dstPath ) );

  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
      allowingMissed : 1
    });
  })

  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  //

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
      allowingMissed : 0
    });
  })

  //

  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
      allowingMissed : 0
    });
  })

  test.close( 'allowingMissed' );

  /**/

  test.mustNotThrowError( function()
  {
    provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  })
}

//

function softLinkAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var routinePath = test.context.pathFor( 'written/softLinkAsync' );
  var srcPath,dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );
  consequence

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make link async';
    srcPath  = test.context.pathFor( 'written/softLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link.txt' );
    provider.fileWrite( srcPath, '000' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite
      ({
        filePath : srcPath,
        writeMode : 'append',
        data : 'new text',
        sync : 1
      });
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      provider.fieldPush( 'resolvingSoftLink', 1 );
      var got = provider.fileRead( dstPath );
      provider.fieldPop( 'resolvingSoftLink', 1 );
      var expected = '000new text';
      test.identical( got, expected );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make for file that not exist';
    provider.filesDelete( routinePath );
    srcPath  = test.context.pathFor( 'written/softLinkAsync/no_file.txt' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link2.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function( )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, null );
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'link already exists';
    srcPath = test.context.pathFor( 'written/softLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link.txt' );
    provider.fileWrite( srcPath, 'abc' );
    return provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  //
  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/softLinkAsync/link_test.txt' );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      allowingMissed : 1,
      rewriting : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      test.is( provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      allowingMissed : 0,
      rewriting : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, false );
      test.is( !provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( srcPath );
    var con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      allowingMissed : 0,
      rewriting : 0,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con )
    .ifNoErrorThen( function( got )
    {
      test.is( !provider.isSoftLink( srcPath ) );
      return null;
    })
  })

  //

  .finally( function()
  {
    test.case = 'try make hardLink for folder';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/softLinkAsync/link_test' );
    dstPath = test.context.pathFor( 'written/softLinkAsync/link' );
    provider.dirMake( srcPath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link', 'link_test' ]  );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .finally( function()
  {
    return provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link', 'link_test' ]  );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.open( 'allowingMissed' );
    return null;
  })

  //

  .finally( () =>
  {

    return provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 1
    })
    .finally( () =>
    {
      var got = provider.pathResolveLinkFull({ filePath : srcPath, resolvingSoftLink : 1 });
      test.identical( got.absolutePath, srcPath )
      return null;
    })

  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
      allowingMissed : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );

  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
      allowingMissed : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
      allowingMissed : 0
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
      allowingMissed : 0
    });
    return test.mustNotThrowError( con );
  })

  .finally( () =>
  {
    let con = provider.softLink
    ({
      srcPath,
      dstPath : srcPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
      allowingMissed : 0
    });
    return test.mustNotThrowError( con );
  })

  .finally( () => test.close( 'allowingMissed' ) )

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.softLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  return consequence;
}

//

function softLinkRelativePath( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativePath' );
  let pathToDir = test.context.pathFor( 'written/softLinkRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/softLinkRelativePath/file' );

  test.open( 'src - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../../file' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../../file' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './.././a/b/c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.././z/b/c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/z/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.\\..\\.\\z\\b\\c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/z/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\.\\z\\b\\c' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/z/b/c' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../a/b/c/../..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../a/b/c/../..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.\\..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  test.shouldThrowErrorOfAnyKind( () => provider.softLink( dstPath, srcPath ) );
  test.is( !provider.isSoftLink( dstPath ) );

  test.close( 'src - relative path to a file' );

  //

  test.open( 'src - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = test.context.globalFromPreferred( '../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstDirLink' );
  provider.filesDelete( self.provider.path.dir( dstPath ) );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../dir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath/dstDirLink' );
  provider.filesDelete( self.provider.path.dir( dstPath ) );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../../../dir' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/dir' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( './../../../dir' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/dir' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/a/b/c/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  //

  var srcPath = test.context.globalFromPreferred( './.././a/b/c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.././a/b/c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '.\\..\\.\\a\\b\\c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\.\\a\\b\\c' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a/b/c' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );


  var srcPath = test.context.globalFromPreferred( './../a/b/c/../..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '../a/b/c/../..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );


  var srcPath = test.context.globalFromPreferred( '.\\..\\a\\b\\c\\..\\..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );


  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToDir2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( self.provider.path.dir( pathToDir2 ) );
  provider.dirMake( pathToDir2 );
  provider.fileWrite( path.join( pathToDir2, 'fileInDir' ) , 'fileInDir' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir2 );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.dirRead({ filePath : dstPath });
  test.identical( got,[ 'fileInDir' ] );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, path.normalize( srcPath ) );

  var srcPath = test.context.globalFromPreferred( '..\\a\\b\\c\\..\\..' );
  var pathToFile2 = test.context.pathFor( 'written/softLinkRelativePath/a' );
  provider.filesDelete( pathToFile2 );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath );
  test.shouldThrowErrorOfAnyKind( () => provider.softLink( dstPath, srcPath ) );
  test.is( !provider.isSoftLink( dstPath ) );

  test.close( 'src - relative path to a dir' );

  test.open( 'dst - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../../dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../a/b/dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( './../a/b/dstFile' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToFile );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  test.close( 'dst - relative path to a file' );

  //

  test.open( 'dst - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( '../dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got,[ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( './../dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got,[ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( '../../dstPath' )
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got,[ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( './../../dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got,[ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( '../a/b/dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.dirMakeForFile( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got,[ 'fileInDir' ] );

  var srcPath = pathToDir;
  var dstPath = test.context.globalFromPreferred( './../a/b/dstPath' );
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.dirMakeForFile( dstPathResolved );
  provider.softLink( dstPath, srcPath );
  var got = provider.pathResolveLinkFull({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got.absolutePath, pathToDir );
  test.is( provider.isSoftLink( dstPathResolved ) );
  var got = provider.dirRead({ filePath : dstPathResolved });
  test.identical( got,[ 'fileInDir' ] );

  test.close( 'dst - relative path to a dir' );

  //

  test.open( 'allowingMissed on, relative path to src' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      })
    });
    provider.fileWrite( pathToFile, pathToFile );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
    test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 0,
    throwing : 0,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
 // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      })
    });
    provider.fileWrite( pathToFile, pathToFile );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
    test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 0,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      })
    });
    provider.fileWrite( pathToFile, pathToFile );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
    test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  provider.dirMakeForFile( dstPath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 0,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  // if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  // {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.pathResolveLinkFull
      ({
        filePath : dstPath,
        resolvingSoftLink : 1,
        allowingMissed : 0,
        throwing : 1
      })
    });
    provider.fileWrite( pathToFile, pathToFile );
    var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
    test.identical( got.absolutePath, pathToFile );

  // }
  // else
  // {
  //   var got = provider.pathResolveLinkFull({ filePath : dstPath, resolvingSoftLink : 1 });
  //   test.identical( got.absolutePath, pathToFile );
  // }
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  test.close( 'allowingMissed on, relative path to src' );

  //

  test.open( 'allowingMissed on, same path' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = pathToFile;
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPath ) );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 1
    })
  });
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );

  //

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../file' );
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink
  ({
    dstPath,
    srcPath,
    rewriting : 1,
    throwing : 1,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( dstPathResolved ) );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : dstPath,
      resolvingSoftLink : 1,
      allowingCycled : 0,
      throwing : 1
    })
  });
  var got = provider.pathResolveSoftLink({ filePath : dstPathResolved/*, readLink : 1*/ });
  test.identical( got, srcPath );

  test.close( 'allowingMissed on, same path' );

  //

  test.open( 'allowingMissed off, relative path to src' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 0,
      throwing : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = test.context.pathFor( 'written/softLinkRelativePath/dstFile' );
  provider.filesDelete( routinePath );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 0,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  test.close( 'allowingMissed off, relative path to src' );

  test.open( 'allowingMissed off, same path' );

  var srcPath = test.context.globalFromPreferred( '../file' );
  var dstPath = pathToFile;
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPath ) );

  var srcPath = pathToFile;
  var dstPath = test.context.globalFromPreferred( '../file' );
  var dstPathResolved = provider.path.resolve( srcPath, dstPath );
  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLink
    ({
      dstPath,
      srcPath,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 0
    });
  })
  test.is( !provider.isSoftLink( dstPathResolved ) );

  test.close( 'allowingMissed off, same path' );
}

softLinkRelativePath.timeOut = 30000;

//

function fileReadAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileRead ) )
  {
    test.identical( 1,1 );
    return;
  }

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1,1 );
    return;
  }

  var consequence = new _.Consequence().take( null );

  if( Config.interpreter === 'browser' )
  {
    test.identical( 1,1 );
    return;
  }

  function encode( src, encoding )
  {
    return BufferNode.from( src ).toString( encoding );
  }

  function decode( src, encoding )
  {
    return BufferNode.from( src, encoding ).toString( 'utf8' );
  }

  var src = 'Excepteur sint occaecat cupidatat non proident';

  let testFile = test.context.pathFor( 'written/fileReadAsync/file' );
  provider.fileWrite( testFile, src );

  consequence
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
    });
    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = src;
    // why slice ???
    // var got = data.slice( 0, expected.length );
    var got = data;
    test.identical( got, expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : ascii';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'ascii'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = encode( src, 'ascii' )
    var got = data.slice( 0, expected.length );
    test.identical( got , expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : utf16le';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'utf16le'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = encode( src, 'utf16le' )
    var got = data.slice( 0, expected.length );
    test.identical( got , expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : ucs2';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'ucs2'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = encode( src, 'ucs2' )
    var got = data.slice( 0, expected.length );
    test.identical( got , expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : base64';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'base64'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = src;
    data = decode( data, 'base64' );
    var got = data.slice( 0, expected.length );
    test.identical( got , expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : arraybuffer';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'buffer.raw'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = [ true, src ];
    var result  = BufferNode.from( data ).toString().slice( 0, src.length );
    var got = [ _.bufferRawIs( data ), result ];
    test.identical( got , expected );
    return null;
  })
  .ifNoErrorThen( function( arg )
  {
    test.case ='read from file, encoding : buffer';
    var con = provider.fileRead
    ({
      filePath : testFile,
      sync : 0,
      encoding : 'buffer.node'
    });

    return test.returnsSingleResource( con );
  })
  .ifNoErrorThen( function( data )
  {
    var expected = [ true, src ];
    var result  = BufferNode.from( data ).toString().slice( 0, src.length );
    var got = [ _.bufferNodeIs( data ), result ];
    test.identical( got , expected );
    return null;
  })

  return consequence;
}

//

/*

/port/package/wMathSpace/node_modules/wmathspace -> /port/package/wMathSpace/
/port/package/wMathSpace/builder -> /repo/git/trunk/builder
/port/package/wMathSpace/node_modules/wmathspace/builder -> /repo/git/trunk/builder

/a/b -> ..
/a/c -> /x
/a/b/c -> /x
*/

function softLinkChain( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1,1 );
    return
  }

  // var routinePath = path.pathDirTempOpen();
  var routinePath = test.context.pathFor( 'written/softLinkChain' );

  debugger;

  provider.dirMake( path.join( routinePath, 'a' ) );
  provider.fileWrite( path.join( routinePath, 'x' ), 'x' );
  provider.softLink( path.join( routinePath, 'a/b' ), '..' );
  provider.softLink( path.join( routinePath, 'a/c' ), '../../x' );

  test.description = 'resolve path';

  var expected = path.join( routinePath, 'a' );
  var got = provider.pathResolveLinkFull( path.join( routinePath, 'a/b' ) ).absolutePath;
  var stat = provider.statResolvedRead( got );
  test.is( !!stat );
  test.identical( got, expected );

  var expected = path.join( routinePath, 'x' );
  var got = provider.pathResolveLinkFull( path.join( routinePath, 'a/c' ) ).absolutePath;
  var stat = provider.statResolvedRead( got );
  test.is( !!stat );
  test.identical( got, expected );

  var expected = path.join( routinePath, 'x' );
  var got = provider.pathResolveLinkFull({ filePath : path.join( routinePath, 'a/b/c' ) }).absolutePath;
  var stat = provider.statResolvedRead( got );
  test.is( !!stat );
  test.identical( got, expected );

  // test.description = 'get stat';

  // var abStat = provider.statResolvedRead({ filePath : path.join( routinePath, 'a/b' ), resolvingSoftLink : 1 });
  // var acStat = provider.statResolvedRead({ filePath : path.join( routinePath, 'a/c' ), resolvingSoftLink : 1 });
  // var abcStat = provider.statResolvedRead({ filePath : path.join( routinePath, 'a/b/c' ), resolvingSoftLink : 1 });

  // test.is( !!abStat );
  // test.is( !!acStat );
  // test.is( !!abcStat );

  debugger;
}

//

function softLinkActSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLinkAct ) )
  {
    test.case = 'softLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'hardLinkActSync' );

  var softLinkIsSupported = test.context.softLinkIsSupported();

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  if( !softLinkIsSupported )
  {
    test.case = 'symlinks are not allowed'
    test.identical( 1, 1 )
    return;
  }

  //

  test.case = 'basic usage';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'no src';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.dirMakeForFile( dstPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'src is a directory';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.dirMake( srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'src is a terminal, check link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcFile, dstPath );
  provider.filesDelete( routinePath );

  test.case = 'src is a hard link, check link';
  provider.filesDelete( routinePath );
  var filePath = path.join( routinePath,'file' );
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ srcPath : filePath, dstPath : srcPath, sync : 1 });
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  debugger
  provider.fileWrite( dstPath, dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcFile, dstPath );
  var file = provider.fileRead( filePath );
  test.identical( srcFile, file );

  //

  test.case = 'dst is a terminal';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o )
  });
  test.is( !provider.isSoftLink( dstPath ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'dst is a hard link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o )
  });
  test.is( !provider.isSoftLink( dstPath ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, srcPath );
  provider.filesDelete( routinePath );

  //

  test.case = 'dst is dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var filePath = path.join( dstPath, 'terminal' )
  var filePath2 = path.join( dstPath, 'file2' )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( filePath2, filePath2 );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o )
  });
  var files = provider.dirRead( dstPath );
  var expected = [ 'file2', 'terminal' ];
  test.identical( files, expected );
  var file1 = provider.fileRead( filePath );
  var file2 = provider.fileRead( filePath2 );
  test.identical( file1, filePath );
  test.identical( file2, filePath2 );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  })
  test.is( !provider.fileExists( dstPath ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }

  var expected = _.mapExtend( null, o );

  if( !( provider instanceof _.FileProvider.System ) )
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  if( process.platform === 'win32' )
  expected.type = 'file'

  provider.softLinkAct( o );
  test.identical( o, expected );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  expected.type = 'file'
  provider.softLinkAct( o );
  test.is( provider.isSoftLink( dstPath ) );
  var got = provider.pathResolveSoftLink({ filePath : dstPath/*, readLink : 1*/ });
  test.identical( got, srcPath );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'create link in not existing directory';
  provider.filesDelete( routinePath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  test.shouldThrowErrorSync( () => provider.softLinkAct( o ) );
  test.will = 'parent directory of dstPath must not be created';
  test.is( !provider.fileExists( path.dir( dstPath ) ) );

  //

  test.case = 'use terminal as parent directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath2 = path.join( srcPath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    type : null,
    sync : 1
  }
  test.shouldThrowErrorSync( () => provider.softLinkAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  //

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.dirMakeForFile( dstPath );
  dstPath = path.relative( routinePath, dstPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      type : null,
      sync : 1
    });
  })

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );;
  var dstPath = path.join( routinePath,'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  });

  //

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  var originalPath = o.srcPath;
  o.srcPath = provider.path.nativize( o.srcPath );
  o.dstPath = provider.path.nativize( o.dstPath );
  if( o.srcPath !== originalPath )
  {
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.softLinkAct( o );
    })
  }
  else
  {
    test.mustNotThrowError( () =>
    {
      provider.softLinkAct( o );
    })
  }

  provider.filesDelete( routinePath );

  //

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    type : null,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.softLinkAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );
}

//

function softLinkSoftLinkResolving( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0,1 ]
  resolvingDstSoftLink : [ 0,1 ]
  link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]

  */

  function softLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.softLink( o );
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  //

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'self cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'self cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPath )

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal )
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  test.close( 'links to same file' );
}

//

function softLinkRelativeLinkResolving( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  /*

  resolvingSrcSoftLink : [ 0,1 ]
  resolvingDstSoftLink : [ 0,1 ]
  link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]

  */

  function softLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.softLink( o );
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativeLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let srcPathRelative2 = provider.path.relative( srcPath, srcPath2 );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let dstPathRelative2 = provider.path.relative( dstPath, dstPath2 );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let srcPathRelativeTerminal = provider.path.relative( srcPath, srcPathTerminal );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );
  let dstPathRelativeTerminal = provider.path.relative( dstPath, dstPathTerminal );

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath2 ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathRelativeTerminal );
  provider.softLink( srcPath, srcPathRelative2 );
  provider.softLink( dstPath2, dstPathRelativeTerminal );
  provider.softLink( dstPath, dstPathRelative2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  //

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelativeTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelativeTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelativeTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'self cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'self cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  test.identical( provider.pathResolveLinkFull( dstPath ).absolutePath, srcPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathRelative2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => softLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelative2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathRelative2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathRelativeTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathRelativeTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathRelativeTerminal );
  provider.softLink( dstPath, srcPathRelativeTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1, allowingMissed : 1 };
  softLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( srcPath ) )
  test.shouldThrowErrorOfAnyKind( () => provider.fileRead( dstPath ) )

  test.close( 'links to same file' );
}

//

function softLinkMakeAndResolve( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = self.pathFor( 'written/softLinkMakeAndResolve' );
  let filePath = self.pathFor( 'written/softLinkMakeAndResolve/file' );
  let linkPath = self.pathFor( 'written/softLinkMakeAndResolve/link' );
  let linkPath2 = self.pathFor( 'written/softLinkMakeAndResolve/link' );

  test.case = 'absolute to missing'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, filePath );

  test.case = 'absolute to terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath,filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, filePath );

  test.case = 'absolute to absolute to terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath,filePath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, linkPath2 );

  test.case = 'absolute to dir'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  var dirPath = self.pathFor( 'written/softLinkMakeAndResolve/dir' );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : dirPath, allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, dirPath );

  test.case = 'relative to missing'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../file' ) );

  test.case = 'self link'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../link' ) );

  test.case = 'two relative links in chain'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath,filePath );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file', allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : '../link2', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../link2' ) );

  test.case = 'relative to dir'
  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  var dirPath = self.pathFor( 'written/softLinkMakeAndResolve/dir' );
  provider.dirMake( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../dir', allowingMissed : 1 });
  var resolved = provider.pathResolveSoftLink( linkPath );
  test.identical( resolved, test.context.globalFromPreferred( '../dir' ) );

  test.case = 'path contains link to empty dir'
  provider.filesDelete( routinePath );
  var dirPath = self.pathFor( 'written/softLinkMakeAndResolve/dir' );
  provider.dirMake( dirPath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : dirPath, allowingMissed : 1 });
  var pathToResolve = provider.path.join( routinePath, 'link/file' );
  var resolved = provider.pathResolveSoftLink( pathToResolve );
  var expected = provider.path.join( dirPath, 'file' );
  test.identical( resolved, pathToResolve );

  test.case = 'path contains link to dir with terminal'
  provider.filesDelete( routinePath );
  var dirPath = self.pathFor( 'written/softLinkMakeAndResolve/dir' );
  var fileInDir = self.pathFor( 'written/softLinkMakeAndResolve/dir/file' );
  provider.fileWrite( fileInDir, fileInDir );
  provider.softLink({ dstPath : linkPath, srcPath : dirPath, allowingMissed : 1 });
  var pathToResolve = provider.path.join( routinePath, 'link/file' );

  test.is( provider.fileExists( pathToResolve ) );

  var stat = provider.statRead( pathToResolve );
  test.is( stat.isFile() )

  var resolved = provider.pathResolveSoftLink( pathToResolve );
  var expected = pathToResolve;
  test.identical( resolved, expected );
}

//

function softLinkSoftLinkBasic( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkSoftLinkBasic' );
  let src1Path = test.context.pathFor( 'written/softLinkSoftLinkBasic/src1' );
  let src2Path = test.context.pathFor( 'written/softLinkSoftLinkBasic/src2' );
  let src3Path = test.context.pathFor( 'written/softLinkSoftLinkBasic/src3' );
  let dstPath = test.context.pathFor( 'written/softLinkSoftLinkBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      softLink
        - soft link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      softLink
        - soft link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      softLink
        - soft link dst -> src3
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );
}

//

function softLinkGlobal( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1,1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkGlobal' );
  let srcPath = test.context.pathFor( 'written/softLinkGlobal/src' );
  let dstPath = test.context.pathFor( 'written/softLinkGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  /*  */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.softLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /*  */

  test.open( 'without system' );

  self.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.softLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  self.system.providerRegister( provider );

  test.close( 'without system' );

}

//

function softLinkRelativeLinking( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.softLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/softLinkRelativeLinking' );
  let src1Path = test.context.pathFor( 'written/softLinkRelativeLinking/src1' );
  let src2Path = test.context.pathFor( 'written/softLinkRelativeLinking/src2' );
  let src3Path = test.context.pathFor( 'written/softLinkRelativeLinking/src3' );
  let dstPath = test.context.pathFor( 'written/softLinkRelativeLinking/dst' );

  /*
    src1 -> ../src2
    softLink dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    softLink dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    softLink dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    softLink dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.softLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.softLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );
}

//

function textLinkSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = self.pathFor( 'written/textLinkSync' )
  let filePath1 = self.pathFor( 'written/textLinkSync/file1' );
  let filePath2 = self.pathFor( 'written/textLinkSync/file2' );
  let linkPath1 = self.pathFor( 'written/textLinkSync/link1' );
  let linkPath2 = self.pathFor( 'written/textLinkSync/link2' );

  var got;

  self.provider.fieldPush( 'usingTextLink', 1 );

  //

  test.case = 'textlink to missing';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      allowingMissed : 0
    });
  });
  test.is( !provider.fileExists( filePath1 ) );
  test.is( !provider.fileExists( linkPath1 ) );

  test.case = 'textlink to missing';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    allowingMissed : 1,
    makingDirectory : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( !provider.fileExists( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'textlink to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'textlink to directory';
  provider.filesDelete( routinePath );
  provider.dirMake( filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( linkPath1 ) );
  test.is( provider.isDir( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'textlink to textlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  provider.textLink
  ({
    dstPath : linkPath2,
    srcPath : linkPath1,
  });
  test.is( provider.isTextLink( linkPath2 ) );
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath2 );
  test.identical( got, linkPath1 );

  /**/

  test.case = 'try to rewrite existing terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath1,linkPath1 );
  provider.fileWrite( filePath1,filePath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0
    });
  })
  test.is( provider.isTerminal( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  test.is( !provider.isTextLink( linkPath1 ) );

  test.case = 'try to rewrite existing terminal'
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath1,linkPath1 );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    rewriting : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  test.case = 'try to rewrite existing dir'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  provider.fileWrite( filePath1,filePath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 1,
      rewritingDirs : 0
    });
  })
  test.is( provider.isDir( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );

  test.case = 'try to rewrite existing dir'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    rewriting : 1,
    rewritingDirs : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );

  /**/

  test.case = 'equal path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      dstPath : filePath1,
      srcPath : filePath1,
      allowingMissed : 0
    });
  })
  test.is(!provider.isTextLink( filePath1 ) );
  test.is( provider.isTerminal( filePath1 ) );

  test.case = 'equal path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink
  ({
    dstPath : filePath1,
    srcPath : filePath1,
    allowingMissed : 1
  });
  test.is( provider.isTextLink( filePath1 ) );
  var got = provider.pathResolveTextLink( filePath1 );
  test.identical( got, filePath1 );

  test.case = 'textlinked';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink( linkPath1,filePath1 );
  var statBefore = provider.statRead( linkPath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
  });
  var statAfter = provider.statRead( linkPath1 );
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, filePath1 );
  test.identical( statAfter.mtime.getTime(), statBefore.mtime.getTime() );

  /*  */

  test.case = 'relative text link to missing';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : '../file1',
    allowingMissed : 1,
    makingDirectory : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( !provider.fileExists( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, test.context.globalFromPreferred( '../file1' ) );

  test.case = 'relative text link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : '../file1',
    allowingMissed : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  var got = provider.pathResolveTextLink( linkPath1 );
  test.identical( got, test.context.globalFromPreferred( '../file1' ) );

  /* */

  test.case = 'relative text link to missing, allowingMissed off throwing off';
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : '../file1',
      allowingMissed : 0,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( !provider.fileExists( filePath1 ) );

  test.case = 'rewrite existing, rewriting off throwing off';
  provider.filesDelete( routinePath );
  provider.fileWrite( linkPath1,linkPath1 );
  provider.fileWrite( filePath1,filePath1 );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isTerminal( filePath1 ) );
  test.is( provider.isTerminal( linkPath1 ) );

  /*  */

  test.open( 'link already exists' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  provider.textLink
  ({
    dstPath : linkPath1,
    srcPath : filePath1,
    rewriting : 0,
    throwing : 1
  });

  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  //alredy linked returns true
  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.mustNotThrowError( function( )
  {
    provider.textLink
    ({
      dstPath : linkPath1,
      srcPath : filePath1,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.close( 'link already exists' );

  test.case = 'src equal to dst, src exists'
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1,filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      throwing : 1,
      allowingMissed : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isTextLink( filePath1 ) );
  test.identical( provider.pathResolveTextLink( filePath1 ), filePath1 );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 0,
      allowingMissed : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  test.is( provider.isTextLink( filePath1 ) );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  test.is( provider.isTextLink( filePath1 ) );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.shouldThrowErrorOfAnyKind( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 1
    });
  });
  test.is( !provider.isTextLink( filePath1 ) );

  test.case = 'src equal to dst, src does not exist'
  provider.filesDelete( filePath1 );
  test.mustNotThrowError( function()
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 0,
      allowingMissed : 0,
      throwing : 0
    });
  });
  test.identical( got, null );
  test.is( !provider.isTextLink( filePath1 ) );

  test.case = 'makingDirectory off, throwing on'
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : linkPath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 1
    });
  })
  test.is( !provider.isTextLink(  linkPath1 ) );

  test.case = 'makingDirectory off, throwing off'
  provider.filesDelete( routinePath );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      srcPath : linkPath1,
      dstPath : filePath1,
      sync : 1,
      rewriting : 1,
      allowingMissed : 1,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink(  linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs off throwing on'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 1,
      rewritingDirs : 0,
      allowingMissed : 1,
      throwing : 1
    });
  })
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs off throwing off'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 1,
      rewritingDirs : 0,
      allowingMissed : 1,
      throwing : 0
    });
  })
  test.identical( got, null );
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs on throwing on'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  provider.textLink
  ({
    srcPath : filePath1,
    dstPath : linkPath1,
    sync : 1,
    rewriting : 1,
    rewritingDirs : 1,
    allowingMissed : 1,
    throwing : 1
  });
  test.is( provider.isTextLink( linkPath1 ) );
  test.identical( provider.pathResolveTextLink( linkPath1 ), filePath1 );

  test.case = 'rewrite dir, rewritingDirs on rewriting off throwing on'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 0,
      rewritingDirs : 1,
      allowingMissed : 1,
      throwing : 1
    });
  })
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  test.case = 'rewrite dir, rewritingDirs on rewriting off throwing off'
  provider.filesDelete( routinePath );
  provider.dirMake( linkPath1 );
  test.mustNotThrowError( () =>
  {
    got = provider.textLink
    ({
      srcPath : filePath1,
      dstPath : linkPath1,
      sync : 1,
      rewriting : 0,
      rewritingDirs : 1,
      allowingMissed : 1,
      throwing : 0
    });
  })
  test.identical( got, null )
  test.is( !provider.isTextLink( linkPath1 ) );
  test.is( provider.isDir( linkPath1 ) );

  self.provider.fieldPop( 'usingTextLink', 1 );
}

function textLinkSoftLinkBasic( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.textLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkSoftLinkBasic' );
  let src1Path = test.context.pathFor( 'written/textLinkSoftLinkBasic/src1' );
  let src2Path = test.context.pathFor( 'written/textLinkSoftLinkBasic/src2' );
  let src3Path = test.context.pathFor( 'written/textLinkSoftLinkBasic/src3' );
  let dstPath = test.context.pathFor( 'written/textLinkSoftLinkBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      textLink
        - soft link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      textLink
        - soft link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      textLink
        - soft link dst -> src3
  */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src3Path );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function textLinkGlobal( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1,1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkGlobal' );
  let srcPath = test.context.pathFor( 'written/textLinkGlobal/src' );
  let dstPath = test.context.pathFor( 'written/textLinkGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  provider.fieldPush( 'usingTextLink', 1 )

  /*  */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.textLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /*  */

  test.open( 'without system' );

  self.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), srcPath );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.textLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  provider.fieldPop( 'usingTextLink', 1 )

  self.system.providerRegister( provider );

  test.close( 'without system' );
}

//

function textLinkRelativeLinking( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.textLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/textLinkRelativeLinking' );
  let src1Path = test.context.pathFor( 'written/textLinkRelativeLinking/src1' );
  let src2Path = test.context.pathFor( 'written/textLinkRelativeLinking/src2' );
  let src3Path = test.context.pathFor( 'written/textLinkRelativeLinking/src3' );
  let dstPath = test.context.pathFor( 'written/textLinkRelativeLinking/dst' );

  /*
    src1 -> ../src2
    textLink dst src1
    resolvingSrcTextLink : 0
    - link dst -> src1

    src1 -> ../src2
    textLink dst src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    textLink dst ../src1
    resolvingSrcTextLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    textLink dst ../src1
    resolvingSrcTextLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  provider.fieldPush( 'usingTextLink', 1 );

  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  provider.textLink
  ({
    srcPath : '../src1',
    dstPath,
    resolvingSrcSoftLink : 0,
    resolvingSrcTextLink : 0,
    makingDirectory : 1,
    allowingMissed : 1
  });
  test.is( !provider.fileExists( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink :1, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink :2, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 1,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.textLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcTextLink : 2,
      resolvingSrcSoftLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isTextLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcTextLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink : 0, allowingMissed : 1 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src2' ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : src1Path, dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 0, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ),  test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 1, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcTextLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.textLink( src2Path, '../src3' );
  provider.textLink( src1Path, '../src2' );
  provider.textLink({ srcPath : '../src1', dstPath, resolvingSrcTextLink : 2, resolvingSrcSoftLink: 0 });
  test.is( provider.isTextLink( src1Path ) );
  test.is( provider.isTextLink( src2Path ) );
  test.is( provider.isTextLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveTextLink( dstPath ), test.context.globalFromPreferred( '../src3' ) );

  /*  */

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function hardLinkSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var routinePath = test.context.pathFor( 'written/hardLink' );
  provider.filesDelete( routinePath )
  var srcPath,dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'make link async';
  srcPath  = test.context.pathFor( 'written/hardLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/hardLink/link.txt' );
  provider.fileWrite( srcPath, '000' );

  /**/

  provider.hardLink
  ({
    srcPath,
    dstPath,
    sync : 1,
  });
  provider.fileWrite
  ({
    filePath : srcPath,
    sync : 1,
    data : 'new text',
    writeMode : 'append'
  });

  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )
  var got = provider.fileRead( dstPath );
  var expected = '000new text';
  test.identical( got, expected );

  //

  test.case = 'make for file that not exist';
  provider.filesDelete( routinePath );
  srcPath  = test.context.pathFor( 'written/hardLink/no_file.txt' );
  dstPath = test.context.pathFor( 'written/hardLink/link2.txt' );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  })
  var files = provider.dirRead( routinePath );
  test.identical( files, null );

  //

  test.case = 'link already exists';
  srcPath = test.context.pathFor( 'written/hardLink/link_test.txt' );
  dstPath = test.context.pathFor( 'written/hardLink/link.txt' );
  provider.fileWrite( srcPath, 'abc' );
  provider.hardLink
  ({
    srcPath,
    dstPath,
    rewriting : 1,
    throwing : 1,
    sync : 1,
  });

  /**/

  test.mustNotThrowError( function( )
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  test.mustNotThrowError( function( )
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link.txt', 'link_test.txt' ] )

  /**/

  // test.shouldThrowErrorSync( function( )
  // {
  //   provider.hardLink
  //   ({
  //     srcPath,
  //     dstPath,
  //     rewriting : 0,
  //     throwing : 1,
  //     sync : 1,
  //   });
  // });

  var got = provider.hardLink
  ({
    srcPath,
    dstPath,
    rewriting : 0,
    throwing : 1,
    sync : 1,
  });
  test.identical( got, true );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked )
  else
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), true )

  /**/

  test.mustNotThrowError( function( )
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  });

  //

  test.case = 'src is equal to dst';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/hardLink/link_test.txt' );
  provider.fileWrite( srcPath, ' ' );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 1
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 1,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  /**/

  test.mustNotThrowError( function()
  {
    got = provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 1,
      rewriting : 0,
      throwing : 0
    });
  });
  test.identical( got, true );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'link_test.txt' ] );

  //

  test.case = 'try make hardLink for folder';
  provider.filesDelete( routinePath );
  srcPath = test.context.pathFor( 'written/hardLink/link_test' );
  dstPath = test.context.pathFor( 'written/hardLink/link' );
  provider.dirMake( srcPath );

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 1,
    });
  })

  /**/

  test.shouldThrowErrorSync( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 1,
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    debugger
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 1,
    });
  })

  /**/

  test.mustNotThrowError( function()
  {
    provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 1,
    });
  })

  /**/

  test.case = 'try to link same file, srcPath has intermediate soft link to same dir';
  self.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  self.provider.fileWrite( terminalPath, terminalPath );
  self.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = self.provider.statRead( terminalPath );
  var got = self.provider.hardLink ///Vova : Extract.filesAreHardLinkedAct doesn't resolve intermediate directories
  ({
    dstPath : terminalPath,
    srcPath : srcPath2,
    throwing : 1,
    resolvingSrcSoftLink : 0,
    resolvingDstSoftLink : 0,
  });
  test.identical( got, true );
  var terminalStatAfter = self.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );

  test.case = 'try to link same file, srcPath has intermediate soft link to same dir';
  self.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  self.provider.fileWrite( terminalPath, terminalPath );
  self.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = self.provider.statRead( terminalPath );
  var got = self.provider.hardLink
  ({
    dstPath : terminalPath,
    srcPath : srcPath2,
    throwing : 1,
    resolvingSrcSoftLink : 1,
    resolvingDstSoftLink : 0,
  });
  test.identical( got, true );
  var terminalStatAfter = self.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );

  test.case = 'try to link same file, dstPath has intermediate soft link to same dir';
  self.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  self.provider.fileWrite( terminalPath, terminalPath );
  self.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = self.provider.statRead( terminalPath );
  var got = self.provider.hardLink
  ({
    dstPath : srcPath2,
    srcPath : terminalPath,
    throwing : 1,
    resolvingSrcSoftLink : 0,
    resolvingDstSoftLink : 1,
  });
  test.identical( got, true );
  var terminalStatAfter = self.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );

  test.case = 'try to link same file, srcPath and dstPath have intermediate soft link to same dir';
  self.provider.filesDelete( routinePath );
  var dirPath = path.join( routinePath, 'dir' );
  var terminalPath = path.join( dirPath, 'terminal' );
  var linkToDirPath = path.join( routinePath, 'linkToDir' );
  self.provider.fileWrite( terminalPath, terminalPath );
  self.provider.softLink( linkToDirPath, dirPath );
  var srcPath2 = path.join( linkToDirPath, 'terminal' );
  var terminalStatBefore = self.provider.statRead( terminalPath );
  var got = self.provider.hardLink
  ({
    dstPath : srcPath2,
    srcPath : srcPath2,
    throwing : 1,
    resolvingSrcSoftLink : 1,
    resolvingDstSoftLink : 1,
  });
  test.identical( got, true );
  var terminalStatAfter = self.provider.statRead( terminalPath );
  test.identical( terminalStatBefore.mtime.getTime(), terminalStatAfter.mtime.getTime() );
}

hardLinkSync.timeOut = 60000;

//

function hardLinkMultipleSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  function linkGroups( paths, groups )
  {
    groups.forEach( ( g ) =>
    {
      var filePathes = g.map( ( i ) => paths[ i ] );
      provider.hardLink({ dstPath : filePathes });
    })
  }

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var delay = 0.01;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  delay = provider.systemBitrateTimeGet() / 1000;

  function makeFiles( names, dirPath, sameTime )
  {
    var paths = names.map( ( name, i ) =>
    {
      var filePath = self.pathFor( path.join( dirPath, name ) );
      provider.fileWrite({ filePath, data : filePath, purging : 1 });

      if( sameTime )
      {
        var time = delay * 1000;
        provider.fileTimeSet( filePath, time, time );
      }
      else if( i > 0 )
      {
        waitSync( delay );
        provider.fileWrite({ filePath, data : path.name( filePath ) });
      }

      return filePath;
    });

    return paths;
  }

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( self.provider.path.dir( filePath ), _.idWithDate() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }

  function filesHaveSameTime( paths )
  {
    _.assert( paths.length > 1 );
    var srcStat = provider.statResolvedRead( paths[ 0 ] );

    for( var i = 1; i < paths.length; i++ )
    {
      var stat = provider.statResolvedRead( paths[ i ] );
      if( srcStat.atime.getTime() !== stat.atime.getTime() )
      {
        logger.log( srcStat.atime.getTime(), stat.atime.getTime() );
        return false;
      }

      if( srcStat.mtime.getTime() !== stat.mtime.getTime() )
      {
        logger.log( srcStat.mtime.getTime(), stat.mtime.getTime() )
        return false;
      }
    }

    return true;
  }

  var routinePath = test.context.pathFor( 'written/hardLink' );
  provider.filesDelete( routinePath )
  var srcPath,dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    //Vova: next section needs time stats from Extract.statResolvedRead, not implemented yet
    test.identical( 1,1 );
    return;
  }

  //

  var fileNames = [ 'a1', 'a2', 'a3' ];
  var currentTestDir = 'written/hardLink/';
  var data = ' ';

  /**/

  test.case = 'dstPath option, files are not linked';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths )
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath option, linking files from different dirs';
  paths = fileNames.map( ( n ) => path.join( 'dir_'+ n, n ) );
  paths = makeFiles( paths, currentTestDir );
  paths = provider.path.s.normalize( paths )

  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath option, try to link already linked files';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  // try to link again
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath, rewriting off, try to rewrite existing files';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      rewriting : 0,
      throwing : 1
    })
  });
  var got = provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 0,
    throwing : 0
  });
  test.identical( got, false );

  //

  test.case = 'dstPath option, groups of linked files ';
  var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
  provider.filesDelete( test.context.pathFor( currentTestDir ) );

  /**/

  var groups = [ [ 0,1 ],[ 2,3,4 ],[ 5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths,groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  var groups = [ [ 0,1 ],[ 1,2,3 ],[ 3,4,5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths,groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  var groups = [ [ 0,1,2,3 ],[ 4,5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths,groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  var groups = [ [ 0,1,2,3,4 ],[ 0,5 ] ];
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  linkGroups( paths,groups );
  provider.hardLink
  ({
    sync : 1,
    dstPath : paths,
    rewriting : 1,
    throwing : 1
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );

  /**/

  test.case = 'dstPath option, only first path exists';
  var fileNames = [ 'a1', 'a2', 'a3' ];
  provider.filesDelete( test.context.pathFor( currentTestDir ) );
  makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
  var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
  paths = provider.path.s.normalize( paths );
  test.mustNotThrowError( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      allowingMissed : 1,
      rewriting : 1,
      throwing : 1
    })
  })
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  provider.fileWrite( paths[ paths.length - 1 ], fileNames[ fileNames.length - 1 ] );
  test.identical( provider.fileRead( paths[ 0 ] ), provider.fileRead( paths[ paths.length - 1 ] ) );

  /**/

  test.case = 'dstPath option, only first path exists';
  var fileNames = [ 'a1', 'a2', 'a3' ];
  provider.filesDelete( test.context.pathFor( currentTestDir ) );
  makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
  var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
  paths = provider.path.s.normalize( paths );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      allowingMissed : 0,
      rewriting : 1,
      throwing : 1
    })
  })
  test.identical( provider.filesAreHardLinked( paths ), false );
  test.is( !provider.fileExists( paths[ 1 ] ) );
  test.is( !provider.fileExists( paths[ 2 ] ) );

  /**/

  test.case = 'dstPath option, all paths not exist';
  provider.filesDelete( test.context.pathFor( currentTestDir ) );
  var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
  paths = provider.path.s.normalize( paths );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
  });

  /* repair */

  /* test.case = 'dstPath option, same date but different content';
  var paths = makeFiles( fileNames, currentTestDir, true );
  paths = provider.path.s.normalize( paths );
  provider.hardLink({ dstPath : paths });
  var stat = provider.statResolvedRead( paths[ 0 ] );
  waitSync( delay );
  provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
  provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
  var files = provider.recordFactory().records( paths );
  files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
  files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLink({ dstPath : files, allowDiffContent : 0 });
  });
  test.is( !provider.filesAreHardLinked( paths ) ); */

  /* repair */

  /* test.case = 'dstPath option, same date but different content, allowDiffContent';
  var paths = makeFiles( fileNames, currentTestDir, true );
  paths = provider.path.s.normalize( paths );
  provider.hardLink({ dstPath : paths });
  var stat = provider.statResolvedRead( paths[ 0 ] );
  waitSync( delay );
  provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
  provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
  var files = provider.recordFactory().records( paths );
  files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
  files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
  provider.hardLink({ dstPath : files, allowDiffContent : 1 });
  test.identical( provider.filesAreHardLinked( paths ), null ); */

  /**/

  test.case = 'using srcPath as source for files from dstPath';
  var paths = makeFiles( fileNames, currentTestDir );
  paths = provider.path.s.normalize( paths );
  var srcPath = paths.pop();
  provider.hardLink({ srcPath, dstPath : paths });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst )

  /* sourceMode */

  test.case = 'sourceMode: src - newest file with minimal amount of links';
  var paths = makeFiles( fileNames, currentTestDir);
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked file
  makeHardLinksToPath( paths[ 1 ], 2 ); // #2 most linked file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  // logger.log( _.select( records, '*.relative' ) )
  // logger.log( _.select( records, '*/stat/mtime' ).map( ( t ) => t.getTime() ) )
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks<' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks<'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ 2 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 1 ] );
  test.identical( src, dst );

  //

  test.case = 'sourceMode: src - newest file with maximal amount of links';
  var paths = makeFiles( fileNames, currentTestDir );
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked file
  makeHardLinksToPath( paths[ paths.length - 1 ], 4 ); // #2 most linked+newest file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks>'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ paths.length - 1 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 0 ] );
  test.identical( src, dst );

  //

  test.case = 'sourceMode: src - oldest file with maximal amount of links';
  var paths = makeFiles( fileNames, currentTestDir );
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked+oldest file
  makeHardLinksToPath( paths[ paths.length - 1 ], 4 ); // #2 most linked+newest file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified<hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified<hardlinks>'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst );

  //

  test.case = 'sourceMode: src - oldest file with maximal amount of links';
  var paths = makeFiles( fileNames, currentTestDir );
  test.is( paths.length >= 3 );
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified<hardlinks<' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified<hardlinks<'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst );

  //

  test.case = 'sourceMode: src - same time, max amount of links';
  var paths = makeFiles( fileNames, currentTestDir, true );
  test.is( filesHaveSameTime( paths ) );
  test.is( paths.length >= 3 );
  paths = provider.path.s.normalize( paths );
  makeHardLinksToPath( paths[ 0 ], 2 );
  makeHardLinksToPath( paths[ 1 ], 3 );
  makeHardLinksToPath( paths[ 2 ], 5 );
  test.is( filesHaveSameTime( paths ) );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks>'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ 2 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 0 ] );
  test.identical( src, dst );

  //

  test.case = 'sourceMode: src - same time, min amount of links';
  var paths = makeFiles( fileNames, currentTestDir, true );
  test.is( filesHaveSameTime( paths ) );
  test.is( paths.length >= 3 );
  paths = provider.path.s.normalize( paths );
  makeHardLinksToPath( paths[ 0 ], 2 );
  makeHardLinksToPath( paths[ 1 ], 3 );
  makeHardLinksToPath( paths[ 2 ], 5 );
  test.is( filesHaveSameTime( paths ) );
  var records = provider.recordFactory().records( paths );
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks<' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified>hardlinks<'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ 2 ] );
  var ok = test.identical( src, dst );
}

hardLinkMultipleSync.timeOut = 60000;

//

function hardLinkRelativePath( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkRelativePath' );
  let pathToDir = test.context.pathFor( 'written/hardLinkRelativePath/dir' );
  let pathToFile = test.context.pathFor( 'written/hardLinkRelativePath/file' );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  test.open( 'src - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = './../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstFile' );
  provider.filesDelete( dstPath );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = '../../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = './../../file';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstPath/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
 if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = './../../../file';
  var pathToFile2 = test.context.pathFor( 'written/hardLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile2, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile2, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );

  var srcPath = '../../../file';
  var pathToFile2 = test.context.pathFor( 'written/hardLinkRelativePath/a/file' );
  provider.fileWrite( pathToFile2, pathToFile2 );
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/a/b/c/dstFile' );
  provider.filesDelete( dstPath );
  provider.dirMakeForFile( dstPath )
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile2, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile2, dstPath ] ), true );
  var got = provider.fileRead({ filePath : dstPath, resolvingSoftLink : 1 });
  test.identical( got,pathToFile2 );

  test.close( 'src - relative path to a file' );

  //

  test.open( 'src - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = '../dir';
  var dstPath = test.context.pathFor( 'written/hardLinkRelativePath/dstPath' );
  provider.filesDelete( dstPath );
  test.shouldThrowErrorOfAnyKind( () => provider.hardLink( dstPath, srcPath ) )
  test.is( !provider.filesAreHardLinked( [ pathToDir, dstPath ] ) );

  test.close( 'src - relative path to a dir' );

  test.open( 'dst - relative path to a file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );


  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../../dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = '../a/b/dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  var srcPath = pathToFile;
  var dstPath = './../a/b/dstFile';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.dirMakeForFile( dstPathResolved );
  provider.filesDelete( dstPathResolved );
  provider.hardLink( dstPath, srcPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ pathToFile, dstPathResolved ] ), true );
  var got = provider.fileRead({ filePath : dstPathResolved, resolvingSoftLink : 1 });
  test.identical( got,pathToFile );

  test.close( 'dst - relative path to a file' );

  //

  test.open( 'dst - relative path to a dir' );

  provider.filesDelete( routinePath );
  provider.fileWrite( path.join( pathToDir, 'fileInDir' ), 'fileInDir' );
  provider.dirMake( pathToDir );

  var srcPath = pathToDir;
  var dstPath = '../dstPath';
  var dstPathResolved = path.resolve( srcPath, dstPath );
  provider.filesDelete( dstPathResolved );
  test.shouldThrowErrorOfAnyKind( () => provider.hardLink( dstPath, srcPath ) )
  test.is( !provider.filesAreHardLinked( [ pathToDir, dstPathResolved ] ) );

  test.close( 'dst - relative path to a dir' );

  test.open( 'same paths' );

  provider.filesDelete( routinePath );
  provider.fileWrite( pathToFile, pathToFile );

  var srcPath = '../file';
  var dstPath = pathToFile;
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.hardLink( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.nlink, statNow.nlink );

  var srcPath = pathToFile;
  var dstPath = '../file';
  var statBefore = provider.statResolvedRead( pathToFile );
  var got = provider.hardLink( dstPath, srcPath );
  test.identical( got, true );
  var statNow = provider.statResolvedRead( pathToFile );
  test.identical( statBefore.nlink, statNow.nlink );

  test.close( 'same paths' );

}

//

function hardLinkExperiment( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var delay = 0.01;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  delay = provider.systemBitrateTimeGet() / 1000;

  function makeFiles( names, dirPath, sameTime )
  {
    var paths = names.map( ( name, i ) =>
    {
      var filePath = self.pathFor( path.join( dirPath, name ) );
      provider.fileWrite({ filePath, data : filePath, purging : 1 });

      if( sameTime )
      {
        var time = delay * 1000;
        provider.fileTimeSet( filePath, time, time );
      }
      else if( i > 0 )
      {
        waitSync( delay );
        provider.fileWrite({ filePath, data : path.name( filePath ) });
      }

      return filePath;
    });

    return paths;
  }

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( self.provider.path.dir( filePath ), _.idWithDate() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }


  var routinePath = test.context.pathFor( 'written/hardLink' );
  var srcPath,dstPath;

  var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
  test.case = 'sourceMode: src - oldest file with maximal amount of links';
  var paths = makeFiles( fileNames, routinePath );
  test.is( paths.length >= 3 );
  makeHardLinksToPath( paths[ 0 ], 3 ); // #1 most linked+oldest file
  makeHardLinksToPath( paths[ paths.length - 1 ], 4 ); // #2 most linked+newest file
  paths = provider.path.s.normalize( paths );
  var records = provider.recordFactory().records( paths );
  logger.log( _.select( records, '*/name' ) )
  logger.log( 'nlink: ', _.select( records, '*/stat/nlink' ) )
  logger.log( 'atime: ', _.select( records, '*/stat/atime' ).map( ( r ) => r.getTime() ) )
  logger.log( 'mtime: ', _.select( records, '*/stat/mtime' ).map( ( r ) => r.getTime() ) )
  logger.log( 'ctime: ', _.select( records, '*/stat/ctime' ).map( ( r ) => r.getTime() ) )
  logger.log( 'birthtime: ', _.select( records, '*/stat/birthtime' ).map( ( r ) => r.getTime() ) )
  var selectedFile = provider._recordsSort({ src : records, sorter : 'modified<hardlinks>' });
  provider.hardLink
  ({
    dstPath : paths,
    sourceMode : 'modified<hardlinks>'
  });
  test.identical( provider.filesAreHardLinked( paths ), hardLinked );
  var srcPath = paths[ 0 ];
  test.identical( selectedFile.absolute, srcPath );
  test.identical( selectedFile.stat.nlink, 4 );
  var src = provider.fileRead( srcPath );
  var dst = provider.fileRead( paths[ paths.length - 1 ] );
  test.identical( src, dst );
}

hardLinkExperiment.timeOut = 30000;

//

function hardLinkSoftlinked( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    /*
      qqq : statReadAct of Extract and HD handle links in head of path differently
      HD always resolve them
      add test routine statReadActLinkedHead
      aaa : done
    */
    // test.case = 'Not implemented for Extract';
    // test.identical( 1, 1 )
    // return;
  }

  if( !test.context.softLinkIsSupported() )
  {
    test.case = 'System does not allow to create soft links.';
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );

  test.case = 'files are already linked, must not throw an error'
  var routinePath = mp( 'hardLinkActSync/dir' );
  var fileInDir = mp( 'hardLinkActSync/dir/src' );
  var linkToDir = mp( 'hardLinkActSync/linkToDir' );
  var fileInLinkedDir = mp( 'hardLinkActSync/linkToDir/src' );
  provider.fileWrite( fileInDir, fileInDir );
  var statResolvedReadBefore = provider.statResolvedRead( fileInDir );
  provider.softLink( linkToDir, routinePath );
  var got = provider.hardLink( fileInLinkedDir, fileInDir );
  test.identical( got, true );
  var statResolvedReadAfter = provider.statResolvedRead( fileInDir );
  test.is( !!statResolvedReadAfter );
  if( statResolvedReadAfter )
  {
    // if( !self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
    // return;

    test.identical( statResolvedReadBefore.atime.getTime(), statResolvedReadAfter.atime.getTime() );
    test.identical( statResolvedReadBefore.ctime.getTime(), statResolvedReadAfter.ctime.getTime() );
    test.identical( statResolvedReadBefore.mtime.getTime(), statResolvedReadAfter.mtime.getTime() );
    test.identical( statResolvedReadBefore.birthtime.getTime(), statResolvedReadAfter.birthtime.getTime() );
  }

}

//

function hardLinkActSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  var mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'hardLinkActSync' );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var softLinkIsSupported = test.context.softLinkIsSupported();

  //

  test.case = 'basic usage';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.hardLinkAct( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'no src';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );

  //

  test.case = 'src is not a terminal';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.dirMake( srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'src is a terminal, check link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  provider.hardLinkAct( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  provider.fileWrite( dstPath, dstPath );
  var srcFile = provider.fileRead( srcPath );
  test.identical( srcFile, dstPath );
  provider.filesDelete( routinePath );

  test.case = 'src is hardLink';
  var filePath = path.join( routinePath,'file' );
  provider.fileWrite( filePath, filePath );
  var srcPath = path.join( routinePath,'src' );
  provider.hardLink( srcPath, filePath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.hardLinkAct( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.case = 'src is a hard link, check link';
    provider.filesDelete( routinePath );
    var filePath = path.join( routinePath,'file' );
    var srcPath = path.join( routinePath,'src' );
    provider.fileWrite( filePath, filePath );
    provider.hardLink({ srcPath : filePath, dstPath : srcPath, sync : 1 });
    if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, filePath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, filePath ] ), true );
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1
    }
    provider.hardLinkAct( o );
    if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
    provider.fileWrite( dstPath, dstPath );
    var srcFile = provider.fileRead( srcPath );
    test.identical( srcFile, dstPath );
    var file = provider.fileRead( filePath );
    test.identical( srcFile, file );
    provider.filesDelete( routinePath );
  }

  //

  if( softLinkIsSupported )
  {
    test.case = 'src is a soft link, check link';
    provider.filesDelete( routinePath );
    var filePath = path.join( routinePath,'file' );
    var srcPath = path.join( routinePath,'src' );
    provider.fileWrite( filePath, filePath );
    provider.softLink({ srcPath : filePath, dstPath : srcPath, sync : 1 });
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1
    }
    test.shouldThrowErrorOfAnyKind( () => provider.hardLinkAct( o ) )
    test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
    var srcFile = provider.fileRead( srcPath );
    test.identical( srcFile, filePath );
  }


  //

  test.case = 'dst is a terminal';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPath, dstPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o )
  });
  test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, dstPath );
  provider.filesDelete( routinePath );

  //

  test.case = 'dst is a hard link';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o )
  });
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  var dstFile = provider.fileRead( dstPath );
  test.identical( dstFile, srcPath );
  provider.filesDelete( routinePath );

  //

  if( softLinkIsSupported )
  {
    test.case = 'dst is a soft link';
    provider.filesDelete( routinePath );
    var srcPath = path.join( routinePath,'src' );
    var dstPath = path.join( routinePath,'dst' );
    provider.fileWrite( srcPath, srcPath );
    provider.softLink( dstPath, srcPath );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1
    }
    test.shouldThrowErrorOfAnyKind( () =>
    {
      provider.hardLinkAct( o )
    });
    test.is( provider.isSoftLink( dstPath ) );
    var dstFile = provider.fileRead( dstPath );
    test.identical( dstFile, srcPath );
    provider.filesDelete( routinePath );
  }

  //

  test.case = 'dst is dir';
  provider.filesDelete( routinePath );
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var filePath = path.join( dstPath, 'terminal' )
  var filePath2 = path.join( dstPath, 'file2' )
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( filePath2, filePath2 );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o )
  });
  var files = provider.dirRead( dstPath );
  var expected = [ 'file2', 'terminal' ];
  test.identical( files, expected );
  var file1 = provider.fileRead( filePath );
  var file2 = provider.fileRead( filePath2 );
  test.identical( file1, filePath );
  test.identical( file2, filePath2 );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not create folders structure for path';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'parent/dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should path nativize all paths in options map if needed by its own means';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }

  var expected = _.mapExtend( null, o );

  provider.hardLinkAct( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  test.identical( o, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );
  provider.fileWrite( srcPath, srcPath );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  var expected = _.mapOwnKeys( o );
  provider.hardLinkAct( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
  else
  test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
  var got = _.mapOwnKeys( o );
  test.identical( got, expected );
  provider.filesDelete( routinePath );

  //

  test.case = 'create link in not existing directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var dstMissingPath = path.join( routinePath,'dir/dst' );
  var o =
  {
    srcPath,
    dstPath : dstMissingPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstMissingPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 0,
    sync : 1
  }
  test.shouldThrowErrorSync( () => provider.hardLinkAct( o ) );
  test.will = 'parent directory of dstPath must not be created';
  test.is( !provider.fileExists( path.dir( dstMissingPath ) ) );

  //

  test.case = 'use terminal as parent directory';
  var srcPath = path.join( routinePath,'src' );
  var dstPath2 = path.join( srcPath, 'dst' );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o =
  {
    srcPath,
    dstPath : dstPath2,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath2,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 0,
    sync : 1
  }
  test.shouldThrowErrorSync( () => provider.hardLinkAct( o ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath2 ) );

  //

  if( !Config.debug )
  return;

  test.case = 'should assert that path is absolute';
  var srcPath = './src';
  var dstPath = path.join( routinePath,'dst' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct
    ({
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 1
    });
  })

  //

  test.case = 'should not extend or delete fields of options map, no _providerDefaultsApply, routineOptions';
  var srcPath = path.join( routinePath,'src' );;
  var dstPath = path.join( routinePath,'dst' );

  /* sync option is missed */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  });

  /* redundant option */

  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1,
    redundant : 'redundant'
  }
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  });

  //

  test.case = 'should expect normalized path, but not nativized';
  var srcPath = routinePath + '\\src';
  provider.fileWrite( srcPath, srcPath );
  var dstPath = routinePath + '\\dst';
  var o =
  {
    srcPath,
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  if( !self.providerIsInstanceOf( _.FileProvider.System ) )
  test.shouldThrowErrorOfAnyKind( () => provider.hardLinkAct( o ) );
  else
  test.mustNotThrowError( () => provider.hardLinkAct( o ) );
  provider.filesDelete( routinePath );

  //

  test.case = 'should expect ready options map, no complex arguments preprocessing';
  var srcPath = path.join( routinePath,'src' );
  var dstPath = path.join( routinePath,'dst' );
  var o =
  {
    srcPath : [ srcPath ],
    dstPath,
    relativeSrcPath : srcPath,
    relativeDstPath : dstPath,
    breakingSrcHardLink : 0,
    breakingDstHardLink : 1,
    sync : 1
  }
  var expected = _.mapExtend( null, o );
  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.hardLinkAct( o );
  })
  test.identical( o.srcPath, expected.srcPath );
}

//

function hardLinkAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  function linkGroups( paths, groups )
  {
    groups.forEach( ( g ) =>
    {
      var filePathes = g.map( ( i ) => paths[ i ] );
      provider.hardLink({ dstPath : filePathes });
    })
  }

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  var delay = 0.01;

  if( test.context.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  delay = provider.systemBitrateTimeGet() / 1000;

  function makeFiles( names, dirPath, sameTime )
  {
    var paths = names.map( ( name, i ) =>
    {
      var filePath = self.pathFor( path.join( dirPath, name ) );
      provider.fileWrite({ filePath, data : filePath, purging : 1 });

      if( sameTime )
      {
        var time = delay * 1000;
        provider.fileTimeSet( filePath, time, time );
      }
      else if( i > 0 )
      {
        waitSync( delay );
        provider.fileWrite({ filePath, data : path.name( filePath ) });
      }

      return filePath;
    });

    return paths;
  }

  function makeHardLinksToPath( filePath, amount )
  {
    let routinePath = path.join( self.provider.path.dir( filePath ), _.idWithDate() );
    provider.dirMake( routinePath )
    for( var i = 0; i < amount; i++ )
    provider.hardLink( path.join( routinePath, 'file' + i ), filePath );
  }

  var routinePath = test.context.pathFor( 'written/hardLinkAsync' );
  provider.filesDelete( routinePath );
  var srcPath,dstPath;

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var fileNames = [ 'a1', 'a2', 'a3' ];
  var currentTestDir = 'written/hardLink/';
  var data = ' ';
  var paths;

  var consequence = new _.Consequence().take( null );

  consequence

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make link async';
    srcPath  = test.context.pathFor( 'written/hardLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link.txt' );
    provider.fileWrite( srcPath, '000' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      provider.fileWrite
      ({
        filePath : srcPath,
        sync : 1,
        data : 'new text',
        writeMode : 'append'
      });
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      var got = provider.fileRead( dstPath );
      var expected = '000new text';
      test.identical( got, expected );
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'make for file that not exist';
    provider.filesDelete( routinePath );
    srcPath  = test.context.pathFor( 'written/hardLinkAsync/no_file.txt' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link2.txt' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, null );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'link already exists';
    srcPath = test.context.pathFor( 'written/hardLinkAsync/link_test.txt' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link.txt' );
    provider.fileWrite( srcPath, 'abc' );
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link.txt', 'link_test.txt' ] )
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    })
    .finally( ( err, got ) =>
    {
      test.identical( got, true );
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'src is equal to dst';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/hardLinkAsync/link_test.txt' );
    provider.fileWrite( srcPath, ' ' );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 1
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    return provider.hardLink
    ({
      srcPath,
      dstPath : srcPath,
      sync : 0,
      rewriting : 0,
      throwing : 0
    })
    .ifNoErrorThen( function( got )
    {
      test.identical( got, true );
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'link_test.txt' ] );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'try make hardLink for folder';
    provider.filesDelete( routinePath );
    srcPath = test.context.pathFor( 'written/hardLinkAsync/link_test' );
    dstPath = test.context.pathFor( 'written/hardLinkAsync/link' );
    provider.dirMake( srcPath );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 1,
      sync : 0,
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 1,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var con = provider.hardLink
    ({
      srcPath,
      dstPath,
      rewriting : 0,
      throwing : 0,
      sync : 0,
    });
    return test.mustNotThrowError( con );
  });

  //

  if( self.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    // next section needs time stats from Extract.statResolvedRead, not implemented yet
    return consequence;
  }

  /**/

  consequence.ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, files are not linked';
    var paths = makeFiles( fileNames, currentTestDir );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, linking files from different dirs';
    paths = fileNames.map( ( n ) => path.join( 'dir_'+ n, n ) );
    paths = makeFiles( paths, currentTestDir );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, try to link already linked files';
    var paths = makeFiles( fileNames, currentTestDir );
    provider.hardLink
    ({
      sync : 1,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    // try to link again
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath, rewriting off, try to rewrite existing files';
    var paths = makeFiles( fileNames, currentTestDir );
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( () =>
    {
      var got = provider.hardLink
      ({
        sync : 1,
        dstPath : paths,
        rewriting : 0,
        throwing : 0
      });
      test.identical( got, false );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, groups of linked files ';
    fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    return null;
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0,1 ],[ 2,3,4 ],[ 5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths,groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0,1 ],[ 1,2,3 ],[ 3,4,5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths,groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0,1,2,3 ],[ 4,5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths,groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    var groups = [ [ 0,1,2,3,4 ],[ 0,5 ] ];
    var paths = makeFiles( fileNames, currentTestDir );
    linkGroups( paths,groups );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      rewriting : 1,
      throwing : 1
    })
    .finally( () => test.identical( provider.filesAreHardLinked( paths ), hardLinked ) );
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, only first path exists';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
    var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
    return provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 1,
      rewriting : 1,
      throwing : 1
    })
    .finally( () =>
    {
      test.identical( provider.filesAreHardLinked( paths ), hardLinked );
      provider.fileWrite( paths[ paths.length - 1 ], fileNames[ fileNames.length - 1 ] );
      test.identical( provider.fileRead( paths[ 0 ] ), provider.fileRead( paths[ paths.length - 1 ] ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, only first path exists';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    makeFiles( fileNames.slice( 0, 1 ), currentTestDir );
    var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 0,
      rewriting : 1,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( () =>
    {
      test.identical( provider.filesAreHardLinked( paths ), false );
      test.is( provider.fileExists( paths[ 0 ] ) );
      test.is( !provider.fileExists( paths[ 1 ] ) );
      test.is( !provider.fileExists( paths[ 2 ] ) );
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, all paths not exist';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 1,
      rewriting : 1,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con );
  })

  .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, all paths not exist';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    var paths = fileNames.map( ( n )  => self.pathFor( path.join( currentTestDir, n ) ) );
    debugger
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : paths,
      allowingMissed : 0,
      rewriting : 1,
      throwing : 1
    })
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /* repair */

  /* .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, same date but different content';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    var paths = makeFiles( fileNames, currentTestDir, true );
    provider.hardLink({ dstPath : paths });
    var stat = provider.statResolvedRead( paths[ 0 ] );
    waitSync( delay );
    provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
    provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
    var files = provider.recordFactory().records( paths );
    files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
    files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
    var con = provider.hardLink
    ({
      sync : 0,
      dstPath : files,
      rewriting : 1,
      throwing : 1,
      allowDiffContent : 0
    })
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( () =>
    {
      test.is( !provider.filesAreHardLinked( paths ) );
    });
  })
 */
  /* repair */

  /* .ifNoErrorThen( function( arg )
  {
    test.case = 'dstPath option, same date but different content, allow different files';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    var paths = provider.path.s.normalize( makeFiles( fileNames, currentTestDir ) );
    provider.hardLink({ dstPath : paths });
    var stat = provider.statResolvedRead( paths[ 0 ] );
    waitSync( delay );
    provider.fileTouch({ filePath : paths[ paths.length - 1 ], purging : 1 });
    provider.fileWrite( paths[ paths.length - 1 ], 'different content' );
    var files = provider.recordFactory().records( paths );
    files[ files.length - 1 ].stat.mtime = files[ 0 ].stat.mtime;
    files[ files.length - 1 ].stat.birthtime = files[ 0 ].stat.birthtime;
    return provider.hardLink
    ({
      sync : 0,
      dstPath : files,
      rewriting : 1,
      throwing : 1,
      allowDiffContent : 1
    })
    .finally( () =>
    {
      test.identical( provider.filesAreHardLinked( paths ), null );
    });
  }) */

  /* sourceMode */

  .ifNoErrorThen( function( arg )
  {
    test.case = 'sourceMode: source newest file with min hardlinks count ';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    var paths = makeFiles( fileNames, currentTestDir );
    test.is( paths.length >= 3 );
    makeHardLinksToPath( paths[ 1 ], 3 );
    paths = provider.path.s.normalize( paths );
    var records = provider.recordFactory().records( paths );
    var selectedFile = provider._recordsSort({ src : records, sorter : 'modified>hardlinks<' });
    return provider.hardLink
    ({
      dstPath : paths,
      sourceMode : 'modified>hardlinks<',
      sync : 0
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.identical( provider.filesAreHardLinked( paths ), hardLinked );
      var srcPath = paths[ paths.length - 1 ];
      test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
      var src = provider.fileRead( srcPath );
      var dst = provider.fileRead( paths[ 1 ] );
      test.identical( src, dst )
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'sourceMode: source must be a file with max amount of links';
    var fileNames = [ 'a1', 'a2', 'a3', 'a4', 'a5', 'a6' ];
    provider.filesDelete( test.context.pathFor( currentTestDir ) );
    var paths = makeFiles( fileNames, currentTestDir );
    waitSync( delay );
    provider.fileWrite( paths[ 0 ], 'max links file' );
    test.is( paths.length >= 3 );
    makeHardLinksToPath( paths[ 0 ], 3 ); //3 links to a file
    makeHardLinksToPath( paths[ 1 ], 2 ); //2 links to a file
    paths = provider.path.s.normalize( paths );
    var records = provider.recordFactory().records( paths );
    var selectedFile = provider._recordsSort({ src : records, sorter : 'hardlinks>' });
    return provider.hardLink
    ({
      dstPath : paths,
      sync : 0,
      sourceMode : 'hardlinks>'
    })
    .ifNoErrorThen( ( arg ) =>
    {
      test.identical( provider.filesAreHardLinked( paths ), hardLinked );
      var srcPath = paths[ 0 ];
      test.identical( selectedFile.absolute, provider.path.preferredFromGlobal( srcPath ) );
      var dstPath = paths[ 1 ];
      var src = provider.fileRead( srcPath );
      var dst = provider.fileRead( dstPath );
      test.identical( src, 'max links file' );
      test.identical( dst, 'max links file' );
      var srcStat = provider.statResolvedRead( srcPath );
      var dstStat = provider.statResolvedRead( dstPath );
      test.identical( Number( srcStat.nlink ), 9 );
      test.identical( Number( dstStat.nlink ), 9 );
      return null;
    })

  })

  return consequence;
}
hardLinkAsync.timeOut = 60000;

//

function hardLinkActAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLinkAct ) )
  {
    test.case = 'hardLinkAct is not implemented'
    test.identical( 1, 1 )
    return;
  }

  let mp = _.routineJoin( test.context, test.context.pathFor );
  var routinePath = mp( 'hardLinkActSync' );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  let softLinkIsSupported = test.context.softLinkIsSupported();
  let con = new _.Consequence().take( null )

  //

  .finally( () =>
  {
    test.case = 'basic usage';
    var srcPath = path.join( routinePath,'src' );
    provider.fileWrite( srcPath, srcPath );
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.mustNotThrowError( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.identical( got, true );
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'src does not exist';
    var srcPath = path.join( routinePath,'src' );
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'src is not a terminal, but dir';
    var srcPath = path.join( routinePath,'src' );
    provider.dirMake( srcPath );
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'src is not a terminal, but softLink';
    var filePath = path.join( routinePath,'file' );
    provider.fileWrite( filePath, filePath )
    var srcPath = path.join( routinePath,'src' );
    provider.softLink( srcPath, filePath );
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'dst already exists';
    var srcPath = path.join( routinePath,'src' );
    var dstPath = path.join( routinePath,'dst' );
    provider.fileWrite( srcPath, srcPath );
    provider.fileWrite( dstPath, dstPath );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.shouldThrowErrorOfAnyKind( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.is( _.errIs( got ) );
      test.is( !provider.filesAreHardLinked( [ srcPath, dstPath ] ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'same path';
    var srcPath = path.join( routinePath,'src' );
    var dstPath = path.join( routinePath,'src' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.mustNotThrowError( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.identical( got, true );
      test.is( !provider.isHardLink( dstPath ) );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'src is hardLink';
    var filePath = path.join( routinePath,'file' );
    provider.fileWrite( filePath, filePath )
    var srcPath = path.join( routinePath,'src' );
    provider.hardLink( srcPath, filePath );
    var dstPath = path.join( routinePath,'dst' );
    var o =
    {
      srcPath,
      dstPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 1,
      sync : 0
    }
    var expected = _.mapOwnKeys( o );
    return test.mustNotThrowError( provider.hardLinkAct( o ) )
    .finally( ( err, got ) =>
    {
      test.identical( got, true );
      if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), hardLinked );
      else
      test.identical( provider.filesAreHardLinked( [ srcPath, dstPath ] ), true );
      got = _.mapOwnKeys( o );
      test.identical( got, expected );
      provider.filesDelete( routinePath );
      return null;
    })
  })

  .finally( () =>
  {
    test.case = 'create link in not existing directory';
    var srcPath = path.join( routinePath,'src' );
    var dstMissingPath = path.join( routinePath,'dir/dst' );
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    var o =
    {
      srcPath,
      dstPath : dstMissingPath,
      relativeSrcPath : srcPath,
      relativeDstPath : dstMissingPath,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 0,
      sync : 0
    }
    return test.shouldThrowErrorAsync( provider.hardLinkAct( o ) )
    .then( () =>
    {
      test.will = 'parent directory of dstPath must not be created';
      test.is( !provider.fileExists( path.dir( dstMissingPath ) ) );
      return null;
    })
  })

  //

  .finally( () =>
  {
    test.case = 'use terminal as parent directory';
    var srcPath = path.join( routinePath,'src' );
    var dstPath2 = path.join( srcPath, 'dst' );
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, srcPath );
    var o =
    {
      srcPath,
      dstPath : dstPath2,
      relativeSrcPath : srcPath,
      relativeDstPath : dstPath2,
      breakingSrcHardLink : 0,
      breakingDstHardLink : 0,
      sync : 0
    }
    return test.shouldThrowErrorAsync( provider.hardLinkAct( o ) )
    .then( () =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( !provider.fileExists( dstPath2 ) );
      return null;
    })
  })

  return con;
}

hardLinkActAsync.timeOut = 15000;

//

function fileExchangeSync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileExchange ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/fileExchange' );
  var srcPath,dstPath,src,dst,got;
  var srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  var dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  //

  test.case = 'swap two files content';
  srcPath = test.context.pathFor( 'written/fileExchange/src' );
  dstPath = test.context.pathFor( 'written/fileExchange/dst' );


  /*default setting*/

  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange( dstPath, srcPath );
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  src = provider.fileRead( srcPath );
  dst = provider.fileRead( dstPath );
  test.identical( [ src, dst ], [ 'dst', 'src' ] )

  /**/

  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    throwing : 0
  });
  var files = provider.dirRead( routinePath );
  test.identical( files, [ 'dst', 'src' ] );
  src = provider.fileRead( srcPath );
  dst = provider.fileRead( dstPath );
  test.identical( [ src, dst ], [ 'dst', 'src' ] )

  //

  test.case = 'swap two dirs content';
  srcPath = test.context.pathFor( 'written/fileExchange/src/src.txt' );
  dstPath = test.context.pathFor( 'written/fileExchange/dst/dst.txt' );

  /*throwing on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange
  ({
    srcPath : self.provider.path.dir( srcPath ),
    dstPath : self.provider.path.dir( dstPath ),
    sync : 1,
    throwing : 1
  });
  src = provider.dirRead( self.provider.path.dir( srcPath ) );
  dst = provider.dirRead( self.provider.path.dir( dstPath ) );
  test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
  src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
  dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
  test.identical( [ src, dst ], [ 'dst', 'src' ] );

  /*throwing off*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  provider.fileWrite( dstPath, 'dst' );
  provider.fileExchange
  ({
    srcPath : self.provider.path.dir( srcPath ),
    dstPath : self.provider.path.dir( dstPath ),
    sync : 1,
    throwing : 1
  });
  src = provider.dirRead( self.provider.path.dir( srcPath ) );
  dst = provider.dirRead( self.provider.path.dir( dstPath ) );
  test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
  src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
  dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
  test.identical( [ src, dst ], [ 'dst', 'src' ] );

  //

  test.case = 'path not exist';
  srcPath = test.context.pathFor( 'written/fileExchange/src' );
  dstPath = test.context.pathFor( 'written/fileExchange/dst' );

  /*src not exist, throwing on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, 'dst' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /*src not exist, throwing on, allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, 'dst' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*src not exist, throwing off,allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, 'dst' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*dst not exist, throwing on,allowingMissed off*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.shouldThrowErrorSync( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*dst not exist, throwing off,allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /*dst not exist, throwing on,allowingMissed on*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 1
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'dst' ] );

  /*dst not exist, throwing off,allowingMissed off*/

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, 'src' );
  test.mustNotThrowError( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 0
    });
  });
  var files  = provider.dirRead( routinePath );
  test.identical( files, [ 'src' ] );

  /*dst & src not exist, throwing on,allowingMissed on*/

  provider.filesDelete( routinePath );
  test.mustNotThrowError( function()
  {
    got = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 1
    });
  });
  test.identical( got, null );

  /*dst & src not exist, throwing off,allowingMissed off*/

  // provider.filesDelete( routinePath );
  test.mustNotThrowError( function()
  {
    got = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 1,
      throwing : 0
    });
  });
  test.identical( got, null );

  /*dst & src not exist, throwing on,allowingMissed off*/

  // provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( function()
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  });

  /*dst & src not exist, throwing off,allowingMissed off*/

  // provider.filesDelete( routinePath );
  test.mustNotThrowError( function()
  {
    got = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 0
    });
  });
  test.identical( got, null );

  //

  test.case = 'two soft links to terminals';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  var src = provider.fileRead( srcPath );
  test.identical( src, dstPathTerminal );
  var dst = provider.fileRead( dstPath );
  test.identical( dst, srcPathTerminal );

  //

  test.case = 'two text links to terminals';
  provider.fieldPush( 'resolvingTextLink', 1 );
  provider.fieldPush( 'usingTextLink', 1 );
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.textLink( srcPath, srcPathTerminal );
  provider.textLink( dstPath, dstPathTerminal );
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  var src = provider.fileRead( srcPath );
  test.identical( src, dstPathTerminal );
  var dst = provider.fileRead( dstPath );
  test.identical( dst, srcPathTerminal );
  provider.fieldPop( 'resolvingTextLink', 1 );
  provider.fieldPop( 'usingTextLink', 1 );

  //

  test.case = 'two soft links to missing, not allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      throwing : 1
    });
  })
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  test.is( !provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal )
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal )

  //

  test.case = 'two soft links to missing, allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 1,
    throwing : 1
  });
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  test.is( !provider.fileExists( srcPathTerminal ) );
  test.is( !provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );

  //

  test.case = 'soft link and terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal });
  provider.fileExchange
  ({
    srcPath,
    dstPath : dstPathTerminal,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), dstPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );

  test.case = 'terminal and soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink({ dstPath, srcPath : dstPathTerminal });
  provider.fileExchange
  ({
    srcPath : srcPathTerminal,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    throwing : 1
  });
  test.is( provider.fileExists( srcPathTerminal ) );
  test.is( provider.fileExists( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  // cycled links

  srcPath = path.join( routinePath, 'src' );
  dstPath = path.join( routinePath, 'dst' );

  test.case = 'two self cycled soft links, cycled allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    throwing : 1
  });
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../dst' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );

  test.case = 'two self cycled soft links, cycled not allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
  })
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );

  test.case = 'two self cycled soft links, cycled not allowed, throwing off';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  got = provider.fileExchange
  ({
    srcPath,
    dstPath,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    throwing : 0
  });
  test.identical( got, null );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );

  test.case = 'self cycled and terminal, cycled allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.fileWrite( dstPathTerminal, dstPathTerminal )
  provider.fileExchange
  ({
    srcPath,
    dstPath : dstPathTerminal,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 1,
    throwing : 1
  });
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.fileRead( srcPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), test.context.globalFromPreferred( '../src' ) );

  test.case = 'self cycled and terminal, cycled not allowed';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.fileWrite( dstPathTerminal, dstPathTerminal )
  test.shouldThrowErrorSync( () =>
  {
    provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 1,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
  })
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );

  test.case = 'self cycled and terminal, cycled not allowed, throwing off';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
  provider.fileWrite( dstPathTerminal, dstPathTerminal )
  got = provider.fileExchange
  ({
    srcPath,
    dstPath : dstPathTerminal,
    sync : 1,
    allowingMissed : 0,
    allowingCycled : 0,
    throwing : 0
  });
  test.identical( got, null );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( srcPath ) );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );

}

//

function fileExchangeAsync( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.fileExchange ) || !_.routineIs( provider.statReadAct ) )
  {
    test.identical( 1,1 );
    return;
  }

  var routinePath = test.context.pathFor( 'written/fileExchangeAsync' );
  var srcPath,dstPath,src,dst,got;
  var srcPathTerminal, dstPathTerminal;

  srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  if( !provider.statResolvedRead( routinePath ) )
  provider.dirMake( routinePath );

  var consequence = new _.Consequence().take( null );

  consequence

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'swap two files content';
    srcPath = test.context.pathFor( 'written/fileExchangeAsync/src' );
    dstPath = test.context.pathFor( 'written/fileExchangeAsync/dst' );
    return null;
  })

  /*default setting*/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst', 'src' ] );
      src = provider.fileRead( srcPath );
      dst = provider.fileRead( dstPath );
      test.identical( [ src, dst ], [ 'dst', 'src' ] )
      return null;
    })
  })

  /**/

  .ifNoErrorThen( function( arg )
  {
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( arg )
    {
      var files = provider.dirRead( routinePath );
      test.identical( files, [ 'dst', 'src' ] );
      src = provider.fileRead( srcPath );
      dst = provider.fileRead( dstPath );
      test.identical( [ src, dst ], [ 'dst', 'src' ] )
      return null;
    })
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'swap two dirs content';
    srcPath = test.context.pathFor( 'written/fileExchangeAsync/src/src.txt' );
    dstPath = test.context.pathFor( 'written/fileExchangeAsync/dst/dst.txt' );
    return null;
  })

  /*throwing on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath : self.provider.path.dir( srcPath ),
      dstPath : self.provider.path.dir( dstPath ),
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .ifNoErrorThen( function( arg )
    {
      src = provider.dirRead( self.provider.path.dir( srcPath ) );
      dst = provider.dirRead( self.provider.path.dir( dstPath ) );
      test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
      src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
      dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
      test.identical( [ src, dst ], [ 'dst', 'src' ] );
      return null;
    });
  })

  /*throwing off*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    provider.fileWrite( dstPath, 'dst' );
    return provider.fileExchange
    ({
      srcPath : self.provider.path.dir( srcPath ),
      dstPath : self.provider.path.dir( dstPath ),
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    })
    .ifNoErrorThen( function( arg )
    {
      src = provider.dirRead( self.provider.path.dir( srcPath ) );
      dst = provider.dirRead( self.provider.path.dir( dstPath ) );
      test.identical( [ src, dst ], [ [ 'dst.txt' ], [ 'src.txt' ] ] );
      src = provider.fileRead( _.strReplaceAll( srcPath, 'src.txt', 'dst.txt' ) );
      dst = provider.fileRead( _.strReplaceAll( dstPath, 'dst.txt', 'src.txt' ) );
      test.identical( [ src, dst ], [ 'dst', 'src' ] );
      return null;
    });
  })

  //

  .ifNoErrorThen( function( arg )
  {
    test.case = 'path not exist';
    srcPath = test.context.pathFor( 'written/fileExchangeAsync/src' );
    dstPath = test.context.pathFor( 'written/fileExchangeAsync/dst' );
    return null;
  })

  /*src not exist, throwing on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, 'dst' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return null;
    });
  })

  /*src not exist, throwing on, allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, 'dst' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*src not exist, throwing off,allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( dstPath, 'dst' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*dst not exist, throwing on,allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .finally( function()
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*dst not exist, throwing off,allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return null;
    });
  })

  /*dst not exist, throwing on,allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'dst' ] );
      return null;
    });
  })

  /*dst not exist, throwing off,allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPath, 'src' );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( arg )
    {
      var files  = provider.dirRead( routinePath );
      test.identical( files, [ 'src' ] );
      return null;
    });
  })

  /*dst & src not exist, throwing on,allowingMissed on*/

  .ifNoErrorThen( function( arg )
  {
    provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return null;
    });
  })

  /*dst & src not exist, throwing off,allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    // provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return null;
    });
  })

  /*dst & src not exist, throwing on,allowingMissed off*/

  .ifNoErrorThen( function( arg )
  {
    // provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con );
  })

  /*dst & src not exist, throwing off,allowingMissed off*/

  .finally( function()
  {
    // provider.filesDelete( routinePath );
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 0
    });
    return test.mustNotThrowError( con )
    .ifNoErrorThen( function( got )
    {
      test.identical( got, null );
      return null;
    })
  })

  .then( () =>
  {
    test.case = 'two soft links to terminals';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.softLink( srcPath, srcPathTerminal );
    provider.softLink( dstPath, dstPathTerminal );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      var src = provider.fileRead( srcPath );
      test.identical( src, dstPathTerminal );
      var dst = provider.fileRead( dstPath );
      test.identical( dst, srcPathTerminal );
      return got;
    })

  })

  //

  .then( () =>
  {
    test.case = 'two text links to terminals';
    provider.fieldPush( 'resolvingTextLink', 1 );
    provider.fieldPush( 'usingTextLink', 1 );
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.textLink( srcPath, srcPathTerminal );
    provider.textLink( dstPath, dstPathTerminal );
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      var src = provider.fileRead( srcPath );
      test.identical( src, dstPathTerminal );
      var dst = provider.fileRead( dstPath );
      test.identical( dst, srcPathTerminal );
      provider.fieldPop( 'resolvingTextLink', 1 );
      provider.fieldPop( 'usingTextLink', 1 );
      return got;
    })
  })

  //

  .then( () =>
  {
    test.case = 'two soft links to missing, not allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    var con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    });
    return test.shouldThrowErrorOfAnyKind( con )
    .then( () =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.fileExists( dstPath ) );
      test.is( !provider.fileExists( srcPathTerminal ) );
      test.is( !provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal )
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal )
      return null;
    })
  })

  //

  .then( () =>
  {
    test.case = 'two soft links to missing, allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1, makingDirectory : 1 });
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 1,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.fileExists( dstPath ) );
      test.is( !provider.fileExists( srcPathTerminal ) );
      test.is( !provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
      return got;
    })
  })

  //

  .then( () =>
  {
    test.case = 'soft link and terminal';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal });
    return provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.fileExists( srcPath ) );
      test.is( provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
      test.identical( provider.fileRead( srcPath ), dstPathTerminal );
      test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
      test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
      return got;
    })
  })

  //

  .then( () =>
  {
    test.case = 'terminal and soft link';
    provider.filesDelete( routinePath );
    provider.fileWrite( srcPathTerminal, srcPathTerminal );
    provider.fileWrite( dstPathTerminal, dstPathTerminal );
    provider.softLink({ dstPath, srcPath : dstPathTerminal });
    return provider.fileExchange
    ({
      srcPath : srcPathTerminal,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.fileExists( srcPathTerminal ) );
      test.is( provider.fileExists( dstPathTerminal ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
      test.identical( provider.fileRead( srcPathTerminal ), dstPathTerminal );
      test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );
      test.identical( provider.fileRead( dstPath ), srcPathTerminal );
      return got;
    })
  })

  //cycled links

  .then( () =>
  {
    test.case = 'two self cycled soft links, cycled allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 1,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../dst' ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src' ) );
      return got;
    })
  })

  //

  .then( () =>
  {
    test.case = 'two self cycled soft links, cycled not allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
    let con = provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
      return null;
    })

  })

  //

  .then( () =>
  {
    test.case = 'two self cycled soft links, cycled not allowed, throwing off';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
    return provider.fileExchange
    ({
      srcPath,
      dstPath,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isSoftLink( srcPath ) );
      test.is( provider.isSoftLink( dstPath ) );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
      return null;
    })
  })

  //

  .then( () =>
  {
    test.case = 'self cycled and terminal, cycled allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.fileWrite( dstPathTerminal, dstPathTerminal )
    return provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 1,
      throwing : 1
    })
    .then( ( got ) =>
    {
      test.is( provider.isTerminal( srcPath ) );
      test.is( provider.isSoftLink( dstPathTerminal ) );
      test.identical( provider.fileRead( srcPath ), dstPathTerminal );
      test.identical( provider.pathResolveSoftLink( dstPathTerminal ), test.context.globalFromPreferred( '../src' ) );
      return got;
    })

  })

  //

  .then( () =>
  {
    test.case = 'self cycled and terminal, cycled not allowed';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.fileWrite( dstPathTerminal, dstPathTerminal )
    let con = provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 1
    });
    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      test.is( provider.isTerminal( dstPathTerminal ) );
      test.is( provider.isSoftLink( srcPath ) );
      test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      return null;
    })
  })

  //

  .then( () =>
  {
    test.case = 'self cycled and terminal, cycled not allowed, throwing off';
    provider.filesDelete( routinePath );
    provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1, makingDirectory : 1 });
    provider.fileWrite( dstPathTerminal, dstPathTerminal )
    return provider.fileExchange
    ({
      srcPath,
      dstPath : dstPathTerminal,
      sync : 0,
      allowingMissed : 0,
      allowingCycled : 0,
      throwing : 0
    })
    .then( ( got ) =>
    {
      test.identical( got, null );
      test.is( provider.isTerminal( dstPathTerminal ) );
      test.is( provider.isSoftLink( srcPath ) );
      test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );
      test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
      return null;
    })
  })

  return consequence;

}

//

function hardLinkSoftLinkResolving( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  /*
  resolvingSrcSoftLink : [ 0,1 ]
  resolvingDstSoftLink : [ 0,1 ]
  link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]
  */

  function hardLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1
    }
    _.mapSupplement( o, o2 )
    return provider.hardLink( o );
  }

  let routinePath = test.context.pathFor( 'written/fileRenameSoftLinkResolving' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  /**/

  test.open( 'normal' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), dstPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, dstPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'normal' );

  /**/

  test.open( 'double' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isTerminal( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.softLink( srcPath2, srcPathTerminal );
  provider.softLink( srcPath, srcPath2 );
  provider.softLink( dstPath2, dstPathTerminal );
  provider.softLink( dstPath, dstPath2 );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isTerminal( srcPathTerminal ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPathTerminal );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'double' );

  /**/

  test.open( 'broken' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o )
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPathTerminal ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPathTerminal ), srcPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPathTerminal, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPathTerminal, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPathTerminal );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'broken' );

  /**/

  test.open( 'self cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../dst' ) );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'self cycled' );

  /* */

  test.open( 'cycled' );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o )
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : srcPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : srcPath2, srcPath, allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : dstPath2, allowingMissed : 1 });
  provider.softLink({ dstPath : dstPath2, srcPath : dstPath, allowingMissed : 1 });
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( srcPath2 ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isSoftLink( dstPath2 ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPath2 );
  test.identical( provider.pathResolveSoftLink( dstPath ), dstPath2 );
  test.identical( provider.pathResolveSoftLink( srcPath2 ), srcPath );
  test.identical( provider.pathResolveSoftLink( dstPath2 ), dstPath );
  //test.identical( provider.statResolvedRead( srcPath ), null );
  //test.identical( provider.statResolvedRead( dstPath ), null );

  test.close( 'cycled' );

  /**/

  test.open( 'links to same file' );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.identical( o.srcPath, srcPath );
  test.identical( o.dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 0 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 0, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( srcPathTerminal ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.softLink( srcPath, srcPathTerminal );
  provider.softLink( dstPath, srcPathTerminal );
  var o = { resolvingSrcSoftLink : 1, resolvingDstSoftLink : 1 };
  hardLink( o );
  test.identical( o.srcPath, srcPathTerminal );
  test.identical( o.dstPath, srcPathTerminal );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), srcPathTerminal );
  test.identical( provider.pathResolveSoftLink( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );

  test.close( 'links to same file' );
}

//

function hardLinkHardLinkBreaking( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  /*
  resolvingSrcSoftLink : [ 0,1 ]
  resolvingDstSoftLink : [ 0,1 ]
  link : [ normal, double, broken, self cycled, cycled, dst and src resolving to the same file ]
  */

  function hardLink( o )
  {
    let o2 =
    {
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      throwing : 1
    }
    _.mapSupplement( o, o2 )
    return provider.hardLink( o );
  }

  let routinePath = test.context.pathFor( 'written/hardLinkHardLinkBreaking' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let srcPath2 = provider.path.join( routinePath, 'src2' );
  let dstPath = provider.path.join( routinePath, 'dst' );
  let dstPath2 = provider.path.join( routinePath, 'dst2' );
  let srcPathTerminal = provider.path.join( routinePath, 'srcTerminal' );
  let dstPathTerminal = provider.path.join( routinePath, 'dstTerminal' );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  // /*  */

  test.case = 'src - terminal, dst - hardlink';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorSync( () => hardLink( o ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  }
  else
  {
    test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), true );
  }
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.fileRead( srcPath ), srcPath );
  test.identical( provider.fileRead( dstPath ), srcPath );
  test.identical( provider.fileRead( dstPathTerminal ), srcPath );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  }
  else
  {
    test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), true );
  }
  test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  }
  else
  {
    test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), true );
  }
  test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1, rewriting : 0 };
  test.shouldThrowErrorSync( () => hardLink( o ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  }
  else
  {
    test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), true );
  }
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), false );

  test.case = 'src - hardlink, dst - terminal';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  }
  else
  {
    test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), true );
  }
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ dstPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  debugger
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ dstPath, srcPathTerminal ]), false );


  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPath, dstPath );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ dstPath, srcPathTerminal ]), false );

  test.case = 'src - hardlink, dst - missing';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ dstPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ dstPath, srcPathTerminal ]), false );


  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ dstPath, srcPathTerminal ]), false );

  test.case = 'src - hardlink, dst - hardlink';

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 0 };
  test.shouldThrowErrorOfAnyKind( () => hardLink( o ) );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 0 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath, dstPathTerminal ]), hardLinked );
  test.identical( provider.fileRead( srcPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPath ), srcPathTerminal );
  test.identical( provider.fileRead( dstPathTerminal ), srcPathTerminal );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 0, breakingDstHardLink : 1 };
  hardLink( o );
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ srcPathTerminal, dstPath ]), hardLinked );
  test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), false );

  provider.filesDelete( routinePath );
  provider.fileWrite( srcPathTerminal, srcPathTerminal );
  provider.fileWrite( dstPathTerminal, dstPathTerminal );
  provider.hardLink( srcPath, srcPathTerminal );
  provider.hardLink( dstPath, dstPathTerminal );
  var o = { breakingSrcHardLink : 1, breakingDstHardLink : 1 };
  hardLink( o )
  test.identical( provider.filesAreHardLinked([ srcPath, srcPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ dstPath, dstPathTerminal ]), false );
  test.identical( provider.filesAreHardLinked([ srcPath, dstPath ]), hardLinked );

}

//

function hardLinkSoftLinkBasic( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkSoftLinkBasic' );
  let src1Path = test.context.pathFor( 'written/hardLinkSoftLinkBasic/src1' );
  let src2Path = test.context.pathFor( 'written/hardLinkSoftLinkBasic/src2' );
  let src3Path = test.context.pathFor( 'written/hardLinkSoftLinkBasic/src3' );
  let dstPath = test.context.pathFor( 'written/hardLinkSoftLinkBasic/dst' );

  /*
      src1 -> src2 -> src3
      resolvingSrcSoftLink : 0
      hardLink
        - soft link dst -> src1

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 1
      hardLink
        - soft link dst -> src3

      src1 -> src2 -> src3
      resolvingSrcSoftLink : 2
      hardLink
        - hard link dst -> src3
  */

  test.case = 'resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src3Path );

  test.case = 'resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, src3Path );
  provider.softLink( src1Path, src2Path );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ src3Path, dstPath ]) )
}

function hardLinkGlobal( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( provider instanceof _.FileProvider.System )
  {
    test.identical( 1,1 )
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkGlobal' );
  let srcPath = test.context.pathFor( 'written/hardLinkGlobal/src' );
  let dstPath = test.context.pathFor( 'written/hardLinkGlobal/dst' );

  var srcPathDefault = path.globalFromPreferred( srcPath );
  var dstPathDefault = path.globalFromPreferred( dstPath );

  var srcPathSecond = 'second://' + srcPath;
  var dstPathSecond = 'second://' + dstPath;

  var dstPathUnknown = 'unknown://' + dstPath;

  /*  */

  test.open( 'with system' );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ srcPath, dstPath ]) );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ srcPath, dstPath ]) );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.hardLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  test.close( 'with system' );

  /* */

  test.open( 'without system' );

  self.system.providerUnregister( provider );

  test.case = 'default protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathDefault, srcPathDefault );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ srcPath, dstPath ]) );

  test.case = 'other protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPathSecond, srcPathSecond );
  test.is( provider.isTerminal( srcPath ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ srcPath, dstPath ]) );

  test.case = 'src local, dst with unknown protocol';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  test.shouldThrowErrorSync( () => provider.hardLink( dstPathUnknown, srcPath ) );
  test.is( provider.isTerminal( srcPath ) );
  test.is( !provider.fileExists( dstPath ) );

  self.system.providerRegister( provider );

  test.close( 'without system' );

}

//

function hardLinkRelativeLinking( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  if( !_.routineIs( provider.hardLink ) )
  {
    test.identical( 1,1 );
    return;
  }

  let routinePath = test.context.pathFor( 'written/hardLinkRelativeLinking' );
  let src1Path = test.context.pathFor( 'written/hardLinkRelativeLinking/src1' );
  let src2Path = test.context.pathFor( 'written/hardLinkRelativeLinking/src2' );
  let src3Path = test.context.pathFor( 'written/hardLinkRelativeLinking/src3' );
  let dstPath = test.context.pathFor( 'written/hardLinkRelativeLinking/dst' );

  /*
    src1 -> ../src2
    hardLink dst src1
    resolvingSrcSoftLink : 0
    - link dst -> src1

    src1 -> ../src2
    hardLink dst src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 -> ../src2
    hardLink dst ../src1
    resolvingSrcSoftLink : 0
    - link dst -> ../src1

    src1 -> ../src2
    hardLink dst ../src1
    resolvingSrcSoftLink : 1
    - link dst -> ../src2

    src1 as :
    - missing file
    - link

    src2 as :
    - terminal
    - intermediate link
    - missing

  */

  /*  */

  test.case = 'relative link to dir';
  provider.filesDelete( routinePath );
  provider.dirMake( src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isDir( src2Path ) );
  test.is( provider.isDir( dstPath ) );
  test.identical( provider.dirRead( dstPath ), [] );


  /* src1 missing */

  test.case = '../src1 is missing, allowingMissed:0';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = '../src1 is missing, allowingMissed:1';
  provider.filesDelete( routinePath );
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 0,
      resolvingSrcTextLink : 0,
      allowingMissed : 1
    });
  })
  test.is( !provider.fileExists( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /*  */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  debugger
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ dstPath, src2Path ]) );

  /* */

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src2Path, src2Path );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink :2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isTerminal( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.filesAreHardLinked([ dstPath, src2Path ]) );

  /* missing absolute src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : src1Path,
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink
  ({
    srcPath : src1Path,
    dstPath,
    resolvingSrcSoftLink : 2,
    resolvingSrcTextLink : 0,
    allowingMissed : 1
  });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* missing relative src */

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 0, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 1,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( !provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 1, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( dstPath ) );
test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src2' ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  test.shouldThrowErrorSync( () =>
  {
    provider.hardLink
    ({
      srcPath : '../src1',
      dstPath,
      resolvingSrcSoftLink : 2,
      resolvingSrcTextLink : 0,
      allowingMissed : 0
    });
  })
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( src2Path ) );
  test.is( provider.fileExists( dstPath ) );

  test.case = 'src1 -> ../src2, softLink dst src1, resolvingSrcSoftLink : 2, allowingMissed : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath, dstPath );
  provider.softLink({ dstPath : src1Path, srcPath : '../src2', allowingMissed : 1, makingDirectory : 1 });
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0, allowingMissed : 1 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( !provider.fileExists( dstPath ) );

  /* chain */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), src1Path );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : src1Path, dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.filesAreHardLinked([ dstPath,src3Path ]) );

  /*  */

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 0'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 0, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( '../src1' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 1'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 1, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.identical( provider.pathResolveSoftLink( dstPath ),  test.context.globalFromPreferred( '../src3' ) );

  test.case = 'src1 -> ../src2 -> ../src3, softLink dst ../src1, resolvingSrcSoftLink : 2'
  provider.filesDelete( routinePath );
  provider.fileWrite( src3Path, src3Path );
  provider.softLink( src2Path, '../src3' );
  provider.softLink( src1Path, '../src2' );
  provider.hardLink({ srcPath : '../src1', dstPath, resolvingSrcSoftLink : 2, resolvingSrcTextLink : 0 });
  test.is( provider.isSoftLink( src1Path ) );
  test.is( provider.isSoftLink( src2Path ) );
  test.is( provider.isTerminal( dstPath ) );
  test.is( provider.isTerminal( src3Path ) );
  test.is( provider.filesAreHardLinked([ dstPath,src3Path ]) );
}

//

function hardLinkSyncRunner( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var suite = test.suite;
  var tests = suite.tests;

  var runsLimit = 50;

  for( var i = 0; i < runsLimit; i++ )
  {
    tests.hardLinkSync.call( self, test );
    // if( test.report.testCheckFails > 0 )
    // break;
  }
}

//

function hardLinkAsyncRunner( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var suite = test.suite;
  var tests = suite.tests;

  var runsLimit = 50;

  var con = _.Consequence().take( null );

  for( var i = 0; i < runsLimit; i++ )(function()
  {
    con.ifNoErrorThen( ( arg ) =>
    {
      return tests.hardLinkAsync.call( self, test )
      .finally( ( err, got ) =>
      {
        // if( test.report.testCheckFails > 0 )
        // return _.Consequence().error( 'Execution stopped after first failed test run.' );
      })
    })
  })();

  con.ifNoErrorThen( ( err ) => _.errLog( err ) );

  return con;
}

hardLinkAsyncRunner.timeOut = 60000 * 50;

//

function isDir( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isDir' );
  let filePath = test.context.pathFor( 'written/isDir/file' );
  let linkPath = test.context.pathFor( 'written/isDir/link' );
  let linkPath2 = test.context.pathFor( 'written/isDir/link2' );
  let linkPath3 = test.context.pathFor( 'written/isDir/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), false );

  // test.case = 'hardLink -> soft -> text -> dir'
  // provider.filesDelete( dirPath );
  // provider.dirMake( filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isDir( o );
  // test.identical( got, false )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isDirectory(), false );

  test.case = 'hardLink -> text -> soft -> dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isTextLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isDir( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function dirIsEmpty( test )
{
  let self = this;
  let provider = self.provider;

  var filePath = test.context.pathFor( 'written/dirIsEmpty' );
  provider.filesDelete( filePath );

  //

  test.case = 'non existing path'
  test.identical( provider.dirIsEmpty( filePath ), false );

  //

  test.case = 'file'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, '' );
  test.identical( provider.dirIsEmpty( filePath ), false );

  //

  test.case = 'path with dot';
  provider.filesDelete( filePath );
  var path = test.context.pathFor( 'written/.dirIsEmpty' );
  provider.dirMake( path )
  test.identical( provider.dirIsEmpty( path ), true );

  //

  test.case = 'directory with file'
  provider.filesDelete( filePath );
  provider.fileWrite( self.provider.path.join( filePath, 'a' ), '' );
  test.identical( provider.dirIsEmpty( filePath ), false );

  //

  test.case = 'empty directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  test.identical( provider.dirIsEmpty( filePath ), true );

  //

  test.case = 'softLink to file';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.fileWrite( src, '' );
  provider.softLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  //

  test.case = 'textLink to file';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.fileWrite( src, '' );
  provider.textLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  //

  test.case = 'softLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.softLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  //

  test.case = 'textLink to empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.textLink( filePath, src );
  test.identical( provider.dirIsEmpty( filePath ), false );

  test.case = 'softLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.softLink( filePath, src );

  provider.fieldPush( 'resolvingSoftLink', 0 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingSoftLink', 0 );

  provider.fieldPush( 'resolvingSoftLink', 1 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), true );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  //

  test.case = 'textLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.textLink( filePath, src );

  provider.fieldPush( 'usingTextLink', 0 );

  provider.fieldPush( 'resolvingTextLink', 0 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingTextLink', 0 );

  provider.fieldPush( 'resolvingTextLink', 1 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingTextLink', 1 );

  provider.fieldPop( 'usingTextLink', 0 );

  //

  test.case = 'textLink empty dir';
  provider.filesDelete( filePath );
  var src = filePath + '_';
  provider.dirMake( src );
  provider.textLink( filePath, src );

  provider.fieldPush( 'usingTextLink', 1 );

  provider.fieldPush( 'resolvingTextLink', 0 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), false );
  provider.fieldPop( 'resolvingTextLink', 0 );

  provider.fieldPush( 'resolvingTextLink', 1 );
  test.identical( provider.resolvedDirIsEmpty( filePath ), true );
  provider.fieldPop( 'resolvingTextLink', 1 );

  provider.fieldPop( 'usingTextLink', 1 );



};

//

function isTerminal( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isTerminal' );
  let filePath = test.context.pathFor( 'written/isTerminal/file' );
  let linkPath = test.context.pathFor( 'written/isTerminal/link' );
  let linkPath2 = test.context.pathFor( 'written/isTerminal/link2' );
  let linkPath3 = test.context.pathFor( 'written/isTerminal/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isTerminal( o );
  // test.identical( got, true )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isTextLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  provider.fieldPop( 'usingTextLink', 1 );

  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );


  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to terminal';
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  // var got = provider.isTerminal( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  // var got = provider.isTerminal( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  // var got = provider.isTerminal( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isTerminal( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );

};

isTerminal.timeOut = 20000;

//

function isSoftLink( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isSoftLink' );
  let filePath = test.context.pathFor( 'written/isSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/isSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/isSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/isSoftLink/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0 };
  // var got = provider.isSoftLink( o );
  // test.identical( got, false )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  provider.fieldPop( 'usingTextLink', 1 );


  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isSoftLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1 };
  // var got = provider.isSoftLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) )
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1 };
  var got = provider.isSoftLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) )
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

//

function isTextLink( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isTextLink' );
  let filePath = test.context.pathFor( 'written/isTextLink/file' );
  let filePath2 = test.context.pathFor( 'written/isTextLink/file2' );
  let linkPath = test.context.pathFor( 'written/isTextLink/link' );

  /**/

  provider.fieldPush( 'usingTextLink', 0 )

  test.case = 'to missing'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'to directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'to text link'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'self cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  test.mustNotThrowError( () => provider.isTextLink( linkPath ) );

  test.case = 'cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.mustNotThrowError( () => provider.isTextLink( linkPath ) );

  test.case = 'to cycled soft link'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, allowingMissed : 1 });
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fieldPush( 'resolvingSoftLink', 1 )
  test.is( !provider.isTextLink( linkPath ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink to softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink({ dstPath : filePath, srcPath : filePath2 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to dir'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : self.provider.path.dir( filePath ), makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'hardLink'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  provider.fieldPop( 'usingTextLink', 0 )

  /**/

  provider.fieldPush( 'usingTextLink', 1 )
  provider.filesDelete( dirPath );

  test.case = 'to missing'
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to text link'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'self cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink( linkPath ) );

  test.case = 'to cycled soft link'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, allowingMissed : 1 });
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fieldPush( 'resolvingSoftLink', 1 )
  test.is( provider.isTextLink( linkPath ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  test.is( !provider.isTextLink( filePath ) );

  test.case = 'softLink to softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink({ dstPath : filePath, srcPath : filePath2 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'softLink to softLink to dir'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : self.provider.path.dir( filePath ), makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  test.case = 'hardLink'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink( linkPath ) );

  provider.fieldPop( 'usingTextLink', 1 )

  /* resolving soft link */

  provider.fieldPush( 'usingTextLink', 1 )
  provider.filesDelete( dirPath );

  test.case = 'to missing'
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to directory'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to text link'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'self cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'cycled'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'to cycled soft link'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath, srcPath : '../file', allowingMissed : 1 });
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fieldPush( 'resolvingSoftLink', 1 )
  test.is( provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), true );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  test.is( !provider.isTextLink( filePath ) );
  var got = provider.statRead({ filePath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), false );

  test.case = 'softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  test.is( !provider.isTextLink( linkPath ) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got, null );

  test.case = 'softLink to softLink to missing'
  provider.filesDelete( filePath );
  provider.softLink({ dstPath : filePath2, srcPath : filePath, makingDirectory : 1, allowingMissed : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath2, allowingMissed : 1 });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got, null );

  test.case = 'softLink to softLink to terminal'
  provider.filesDelete( provider.path.dir( filePath ) );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink({ dstPath : filePath, srcPath : filePath2 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), false );

  test.case = 'softLink to softLink to dir'
  provider.filesDelete( filePath );
  provider.filesDelete( linkPath );
  provider.softLink({ dstPath : filePath, srcPath : self.provider.path.dir( filePath ), makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( filePath );
  provider.filesDelete( linkPath );
  provider.fileWrite( filePath, filePath );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath, makingDirectory : 1 });
  test.is( !provider.isTextLink({ filePath : linkPath, resolvingSoftLink : 1 }) );
  var got = provider.statRead({ filePath : linkPath, resolvingSoftLink : 1, resolvingTextLink : 0 });
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isLink(), false );

  provider.fieldPop( 'usingTextLink', 1 )
};

//

function isHardLink( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isHardLink' );
  let filePath = test.context.pathFor( 'written/isHardLink/file' );
  let linkPath = test.context.pathFor( 'written/isHardLink/link' );
  let linkPath2 = test.context.pathFor( 'written/isHardLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/isHardLink/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, true )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isHardLink( o );
  // test.identical( got, true )
  // var got = provider.statRead( o );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false );
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  provider.fieldPop( 'usingTextLink', 1 );

  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( o );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );


  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( o );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), true );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isHardLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  // var got = provider.isHardLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  // var got = provider.isHardLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  // var got = provider.isHardLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), true );
  test.identical( got.isTextLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );


  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isTextLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isHardLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  provider.fieldPop( 'usingTextLink', 1 );
}

isHardLink.timeOut = 20000;

//

function isLink( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let dirPath = test.context.pathFor( 'written/isLink' );
  let filePath = test.context.pathFor( 'written/isLink/file' );
  let linkPath = test.context.pathFor( 'written/isLink/link' );
  let linkPath2 = test.context.pathFor( 'written/isLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/isLink/link3' );

  /* resolving off */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );


  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isDirectory(), false );

  // test.case = 'hardLink -> text -> soft -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.softLink( linkPath3, filePath );
  // provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isDirectory(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  provider.fieldPop( 'usingTextLink', 1 );

  /* resolving */

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'missing'
  provider.filesDelete( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'terminal'
  provider.filesDelete( filePath );
  provider.fileWrite( filePath, filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'dir'
  provider.filesDelete( filePath );
  provider.dirMake( filePath );
  var o = { filePath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null);

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to missing'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink :1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );

  test.case = 'soft to text to directory'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

   test.case = 'soft self cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'soft cycled'
  provider.filesDelete( dirPath );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );
  // test.identical( got.isDirectory(), false );
  // test.identical( got.isLink(), false );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, true )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), true );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), true );
  // test.identical( got.isDirectory(), false );
  // test.identical( got.isLink(), true );

  // test.case = 'hardLink -> soft -> text -> terminal'
  // provider.filesDelete( dirPath );
  // provider.fileWrite( filePath,filePath );
  // provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  // provider.softLink( linkPath2, linkPath3 );
  // provider.hardLink( linkPath, linkPath2 );
  // var o = { filePath : linkPath, resolvingTextLink :1, resolvingSoftLink : 1 };
  // var got = provider.isLink( _.mapExtend( null, o ) );
  // test.identical( got, false )
  // var got = provider.statRead( _.mapExtend( null, o ) );
  // test.identical( got.isTerminal(), true );
  // test.identical( got.isHardLink(), false );
  // test.identical( got.isSoftLink(), false );
  // test.identical( got.isTextLink(), false );
  // test.identical( got.isDirectory(), false );
  // test.identical( got.isLink(), false );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'hardLink -> text -> soft -> terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.hardLink( linkPath, linkPath2 );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'soft to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'soft to text to hardLink'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath,filePath);
  provider.hardLink({ dstPath : linkPath3, srcPath : filePath });
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) )
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), true );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to missing'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got, null );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );


  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to terminal'
  provider.filesDelete( dirPath );
  provider.fileWrite( filePath, filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), false );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), true );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text to soft to dir'
  provider.filesDelete( dirPath );
  provider.dirMake( filePath )
  provider.softLink( linkPath2, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), false );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), false );
  test.identical( got.isDirectory(), true );
  test.identical( got.isLink(), false );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got,null );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text self cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath, 'link ../link' );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, false );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got,null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got,null );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 0, resolvingSoftLink : 1 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true )
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got.isTerminal(), true );
  test.identical( got.isHardLink(), false );
  test.identical( got.isSoftLink(), false );
  test.identical( got.isTextLink(), true );
  test.identical( got.isDirectory(), false );
  test.identical( got.isLink(), true );

  test.case = 'text cycled'
  provider.filesDelete( dirPath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = { filePath : linkPath, resolvingTextLink : 1, resolvingSoftLink : 0 };
  var got = provider.isLink( _.mapExtend( null, o ) );
  test.identical( got, true );
  var got = provider.statRead( _.mapExtend( null, o ) );
  test.identical( got,null );

  provider.fieldPop( 'usingTextLink', 1 );
}

isLink.timeOut = 30000;

//

function filesAreHardLinked( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;
  var textData = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';

  if( test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    //!!!Look into cases with soft links, resolvingSoftLink is not implemented in Extract.filesAreHardLinkedAct
    test.identical( 1,1 );
    return;
  }

  if( Config.interpreter === 'browser' || test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  var bufferData = new BufferRaw( 4 );
  else
  var bufferData = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  //

  test.case = 'same text file';
  var filePath = test.context.pathFor( 'written/filesAreHardLinked/file' );
  provider.fileWrite( filePath, textData );
  var got = provider.filesAreHardLinked([ filePath, filePath ]);
  test.identical( got, hardLinked );


  //

  test.case = 'softLink to a file';
  provider.filesDelete( test.context.pathFor( 'written/filesAreHardLinked' ) );
  var filePath = test.context.pathFor( 'written/filesAreHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/filesAreHardLinked/link' );
  provider.fileWrite( filePath, textData );
  provider.softLink( linkPath, filePath );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesAreHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesAreHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  //

  test.case = 'different files with identical binary content';
  var filePath = test.context.pathFor( 'written/filesAreHardLinked/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreHardLinked/file2' );
  provider.filesDelete( test.context.pathFor( 'written/filesAreHardLinked' ) );
  provider.fileWrite( filePath, bufferData );
  provider.fileWrite( filePath2, bufferData );
  var got = provider.filesAreHardLinked([ filePath, filePath2 ]);
  test.identical( got, false );

  //

  test.case = 'symlink to file with  binary content';
  provider.filesDelete( test.context.pathFor( 'written/filesAreHardLinked' ) );
  var filePath = test.context.pathFor( 'written/filesAreHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/filesAreHardLinked/link' );
  provider.fileWrite( filePath, bufferData );
  provider.softLink( linkPath, filePath );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesAreHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesAreHardLinked([ linkPath, filePath ]);
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  //

  test.case = 'hardLink to file with  binary content';
  provider.filesDelete( test.context.pathFor( 'written/filesAreHardLinked' ) );
  var filePath = test.context.pathFor( 'written/filesAreHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/filesAreHardLinked/link' );
  provider.fileWrite( filePath, bufferData );
  provider.hardLink( linkPath, filePath );
  var got = provider.filesAreHardLinked([ linkPath, filePath ]);
  test.identical( got, hardLinked );

  //

  test.case = 'hardLink to file with  text content : file record';
  provider.filesDelete( test.context.pathFor( 'written/filesAreHardLinked' ) );
  var filePath = test.context.pathFor( 'written/filesAreHardLinked/file' );
  var linkPath = test.context.pathFor( 'written/filesAreHardLinked/link' );
  provider.fileWrite( filePath, textData );
  provider.hardLink( linkPath, filePath );
  var fileRecord = provider.recordFactory().record( filePath );
  var linkRecord = provider.recordFactory().record( linkPath );
  var got = provider.filesAreHardLinked([ fileRecord, linkRecord ]);
  test.identical( got, hardLinked );

};

//

function filesAreTextLinked( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = self.pathFor( 'written/filesAreTextLinked' )
  let filePath1 = self.pathFor( 'written/filesAreTextLinked/file1' );
  let filePath2 = self.pathFor( 'written/filesAreTextLinked/file2' );
  let linkPath1 = self.pathFor( 'written/filesAreTextLinked/link1' );
  let linkPath2 = self.pathFor( 'written/filesAreTextLinked/link2' );

  provider.fieldPush( 'usingTextLink', 1 );

  /*
    resolvingTextLink is always on

    options :
    filePath - array with paths
    resolvingSoftLink : 0/1

    kind of file : missing, terminal, dir, link( soft, hard, text ), chain of links
    combine this kinds of file to create test cases
  */

  test.case = 'missing,missing';
  provider.filesDelete( routinePath );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'missing,missing';
  provider.filesDelete( routinePath );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'missing,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'missing,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, filePath2 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, true );

  test.case = 'terminal,text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, true );

  test.case = 'terminal,soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, true );

  test.case = 'terminal,soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 1 });
  test.identical( got, true );

  test.case = 'terminal,soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.filesAreTextLinked({ filePath : [ filePath1, linkPath1 ], resolvingSoftLink : 0 });
  test.identical( got, false );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function filesAreSoftLinked( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = self.pathFor( 'written/filesAreSoftLinked' )
  let filePath1 = self.pathFor( 'written/filesAreSoftLinked/file1' );
  let filePath2 = self.pathFor( 'written/filesAreSoftLinked/file2' );
  let linkPath1 = self.pathFor( 'written/filesAreSoftLinked/link1' );
  let linkPath2 = self.pathFor( 'written/filesAreSoftLinked/link2' );

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'missing,missing';
  provider.filesDelete( routinePath );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'missing,missing';
  provider.filesDelete( routinePath );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'missing,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'missing,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, filePath2 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,text link to other file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.textLink( linkPath1, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,text link to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath1, filePath1 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, true );

  test.case = 'terminal,soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,soft link to other';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.softLink( linkPath1, filePath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, true );

  test.case = 'terminal,soft link to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( linkPath1, filePath1 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, true );

  test.case = 'terminal,hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  test.case = 'terminal,hardlink to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, false );

  test.case = 'terminal,soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 1 });
  test.identical( got, true );

  test.case = 'terminal,soft to text to same';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( linkPath2, filePath1 );
  provider.softLink( linkPath1, linkPath2 );
  var got = provider.filesAreSoftLinked({ filePath : [ filePath1, linkPath1 ], resolvingTextLink : 0 });
  test.identical( got, false );

  provider.fieldPop( 'usingTextLink', 1 );

}

//

function filesAreSame( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
  var textData2 = ' Aenean non feugiat mauris'
  var bufferData1;
  var bufferData2;

  if( Config.interpreter === 'browser' || self.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    bufferData1 = new BufferRaw( 4 );
    bufferData2 = new BufferRaw( 5 );
  }
  else
  {
    bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );
    bufferData2 =  BufferNode.from( [ 0x07, 0x06, 0x05 ] );
  }


  //

  test.case = 'same file with empty content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  provider.fileWrite( filePath, '' );
  var got = provider.filesAreSame( filePath, filePath );
  test.identical( got, true );

  //

  test.case = 'two different files with empty content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, '' );
  provider.fileWrite( filePath2, '' );
  var got = provider.filesAreSame( filePath, filePath2 );
  test.identical( got, true );

  //

  test.case = 'files with identical binary content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, bufferData1 );
  provider.fileWrite( filePath2, bufferData1 );
  var got = provider.filesAreSame( filePath, filePath2 );
  test.identical( got, true );

  //

  test.case = 'files with non identical text content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.fileWrite( filePath2, textData2 );
  var got = provider.filesAreSame( filePath, filePath2 );
  test.identical( got, false );

  //

  test.case = 'files with non identical binart content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, bufferData1 );
  provider.fileWrite( filePath2, bufferData2 );
  var got = provider.filesAreSame( filePath, filePath2 );
  test.identical( got, false );

  //

  test.case = 'file and symlink to file';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.softLink( filePath2, filePath );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesAreSame( filePath, filePath2 );
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesAreSame( filePath, filePath2 );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  //

  test.case = 'not existing path';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, bufferData1 );
  provider.filesDelete( filePath );
  var got = provider.filesAreSame( filePath, filePath2 );
  test.identical( got, false )


  //

  test.case = 'two file records asociated with two regular files';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.fileWrite( filePath, textData1 );
  var got = provider.filesAreSame( provider.recordFactory().record( filePath ), provider.recordFactory().record( filePath2 ) );
  test.identical( got, true );

  //

  test.case = 'two file records asociated with two regular files, same content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.fileWrite( filePath2, textData1 );
  var got = provider.filesAreSame( provider.recordFactory().record( filePath ), provider.recordFactory().record( filePath2 ) );
  test.identical( got, true );

  //

  test.case = 'two file records asociated with two regular files, diff content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.filesDelete( filePath2 );
  provider.fileWrite( filePath2, textData2 );
  var got = provider.filesAreSame( provider.recordFactory().record( filePath ), provider.recordFactory().record( filePath2 ) );
  test.identical( got, false );

  //

  test.case = 'two file records asociated with two symlinks, same content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.filesDelete( filePath2 );
  provider.fileWrite( filePath2, textData1 );
  var linkPath = test.context.pathFor( 'written/filesAreSame/link1' );
  var linkPath2 = test.context.pathFor( 'written/filesAreSame/link2' );
  provider.softLink( linkPath, filePath );
  provider.softLink( linkPath2, filePath2 );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesAreSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesAreSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, true );

  //

  test.case = 'two file records asociated with two symlinks, diff content';
  var filePath = test.context.pathFor( 'written/filesAreSame/file' );
  var filePath2 = test.context.pathFor( 'written/filesAreSame/file2' );
  provider.fileWrite( filePath, textData1 );
  provider.filesDelete( filePath2 );
  provider.fileWrite( filePath2, textData2 );
  var linkPath = test.context.pathFor( 'written/filesAreSame/link1' );
  var linkPath2 = test.context.pathFor( 'written/filesAreSame/link2' );
  provider.softLink( linkPath, filePath );
  provider.softLink( linkPath2, filePath2 );
  /* resolvingSoftLink off */
  provider.fieldPush( 'resolvingSoftLink', 0 );
  var got = provider.filesAreSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 0 );
  test.identical( got, false );
  /* resolvingSoftLink on */
  provider.fieldPush( 'resolvingSoftLink', 1 );
  var got = provider.filesAreSame( provider.recordFactory().record( linkPath ), provider.recordFactory().record( linkPath2 ) );
  provider.fieldPop( 'resolvingSoftLink', 1 );
  test.identical( got, false );

  //

  if( Config.debug )
  {
    test.case = 'missed arguments';
    test.shouldThrowErrorSync( function( )
    {
      self.provider.filesSame( );
    } );
  }

};

//

function statsAreHardLinked( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = self.pathFor( 'written/statsAreHardLinked' )
  let filePath1 = self.pathFor( 'written/statsAreHardLinked/file1' );
  let filePath2 = self.pathFor( 'written/statsAreHardLinked/file2' );
  let linkPath1 = self.pathFor( 'written/statsAreHardLinked/link1' );
  let linkPath2 = self.pathFor( 'written/statsAreHardLinked/link2' );

  if( !_.routineIs( _.statsAreHardLinked ) )
  {
    test.identical( 1,1 )
    return;
  }

  test.case = 'comparing same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  var stat = provider.statRead( filePath1 );
  var got = _.statsAreHardLinked( stat,stat );
  if( provider.UsingBigIntForStat )
  test.identical( got, true );
  else
  test.identical( got, _.maybe );

  test.case = 'comparing with different terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'comparing with terminal of same content';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'imitate problem with same ino, on lower nodejs versions, compare similar files';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, 'diff' );
  provider.fileWrite( filePath2, 'fidd' );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = Number( stat1.ino );
  stat1.mtime = stat2.mtime;
  stat1.birthtime = stat2.birthtime;
  stat1.ctime = stat2.ctime;
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, _.maybe );


  test.case = 'comparing with hardlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  if( provider.UsingBigIntForStat )
  test.identical( got, true );
  else
  test.identical( got, _.maybe );

  test.case = 'comparing with softlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.softLink( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'comparing with textlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.textLink( filePath2, filePath1 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'comparing two diff hardlinks';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  provider.hardLink( linkPath1, filePath1 );
  provider.hardLink( linkPath2, filePath2 );
  var stat1 = provider.statRead( linkPath1 );
  var stat2 = provider.statRead( linkPath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'comparing two hardlinks to same file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.hardLink( linkPath1, filePath1 );
  provider.hardLink( linkPath2, filePath1 );
  var stat1 = provider.statRead( linkPath1 );
  var stat2 = provider.statRead( linkPath2 );
  var got = _.statsAreHardLinked( stat1,stat2 );
  if( provider.UsingBigIntForStat )
  test.identical( got, true );
  else
  test.identical( got, _.maybe );

  test.case = 'same ino different size';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = 1;
  stat1.size = 1;
  stat2.size = 2;
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'same ino different nlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = 1;
  stat1.nlink = 1;
  stat2.nlink = 2;
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

  test.case = 'same ino, size, but different date';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath1, filePath1 );
  provider.fileWrite( filePath2, filePath2 );
  var stat1 = provider.statRead( filePath1 );
  var stat2 = provider.statRead( filePath2 );
  stat1.ino = stat2.ino = 1;
  stat1.size = stat2.size = 1;
  stat1.mtime = new Date();
  var got = _.statsAreHardLinked( stat1,stat2 );
  test.identical( got, false );

}

//

function filesSize( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
  var textData2 = ' Aenean non feugiat mauris'
  var bufferData1;
  var bufferData2;

  if( Config.interpreter === 'browser' || test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    bufferData1 = new BufferRaw( 4 );
    bufferData2 = new BufferRaw( 5 );
  }
  else
  {
    bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );
    bufferData2 =  BufferNode.from( [ 0x07, 0x06, 0x05 ] );
  }

  var  testChecks =
  [
    {
      name : 'empty file',
      path : 'filesSize/filesSize/rtext1.txt',
      expected : 0,
      data : ''
    },
    {
      name : 'text file1',
      data : textData1,
      path : 'filesSize/filesSize/text2.txt',
      expected : textData1.length
    },
    {
      name : 'text file 2',
      data : textData2,
      path : 'filesSize/filesSize/text3.txt',
      expected : textData2.length
    },
    {
      name : 'file binary',
      data : bufferData1,
      path : 'filesSize/filesSize/data1',
      expected : bufferData1.byteLength
    },
    {
      name : 'binary file 2',
      data : bufferData2,
      path : 'filesSize/filesSize/data2',
      expected : bufferData2.byteLength
    },
  ];

  for( var testCheck of testChecks )
  {
    // join several test aspects together

    let path = test.context.pathFor( testCheck.path );
    var got;

    test.case = testCheck.name;

    provider.fileWrite( path, testCheck.data );

    try
    {
      got = provider.filesSize( path );
    }
    catch( err )
    {
      _.errLog( err );
    }

    let expected = testCheck.expected;
    if( _.bigIntIs( got ) )
    expected = BigInt( expected );
    test.identical( got, expected );
  }

  var paths = testChecks.map( c => test.context.pathFor( c.path ) );
  var expected = testChecks.reduce( ( pc, cc ) => { return pc + cc.expected; }, 0 );

  test.case = 'all paths together';
  var got = provider.filesSize( paths );
  if( _.bigIntIs( got ) )
  expected = BigInt( expected );
  test.identical( got, expected );

  test.case = 'single path that exists';
  path = testChecks[ testChecks.length - 1 ].path
  var got = provider.filesSize( test.context.pathFor( path ) );
  var expected = testChecks[ testChecks.length - 1 ].expected;
  if( _.bigIntIs( got ) )
  expected = BigInt( expected );
  test.identical( got,expected )

  if( !Config.debug )
  return;

  test.case = 'single path that not exists';
  path = test.context.pathFor( 'filesSize/filesSize/notExistingPath' );
  test.shouldThrowErrorOfAnyKind( () => provider.filesSize({ filePath : path, throwing : 1 }) );

  test.case = 'single path that not exists';
  path = test.context.pathFor( 'filesSize/filesSize/notExistingPath' );
  var got = provider.filesSize({ filePath : path, throwing : 0 });
  test.identical( got, null );

  test.case = 'not existing path in array';
  path = test.context.pathFor( 'filesSize/filesSize/notExistingPath' );
  var path2 = testChecks[ testChecks.length - 1 ].path;
  var paths = [ path2, path ];
  test.shouldThrowErrorOfAnyKind( () => provider.filesSize( paths ) );

};

//

function fileSize( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  var textData1 = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
  var  textData2 = ' Aenean non feugiat mauris'
  var bufferData1;
  var bufferData2;

  if( Config.interpreter === 'browser' || test.context.providerIsInstanceOf( _.FileProvider.Extract ) )
  {
    bufferData1 = new BufferRaw( 4 );
    bufferData2 = new BufferRaw( 5 );
  }
  else
  {
    bufferData1 = BufferNode.from( [ 0x01, 0x02, 0x03, 0x04 ] );
    bufferData2 =  BufferNode.from( [ 0x07, 0x06, 0x05 ] );
  }
  var  testChecks =
  [
    {
      name : 'empty file',
      path : 'tmp.tmp/fileSize/rtext1.txt',
      expected : 0,
      data : ''
    },
    {
      name : 'text file1',
      data : textData1,
      path : 'tmp.tmp/fileSize/text2.txt',
      expected : textData1.length
    },
    {
      name : 'text file 2',
      data : textData2,
      path : 'tmp.tmp/fileSize/text3.txt',
      expected : textData2.length
    },
    {
      name : 'file binary',
      data : bufferData1,
      path : 'tmp.tmp/fileSize/data1',
      expected : bufferData1.byteLength
    },
    {
      name : 'binary file 2',
      data : bufferData2,
      path : 'tmp.tmp/fileSize/data2',
      expected : bufferData2.byteLength
    },
  ];

  for( var testCheck of testChecks )
  {
    // join several test aspects together

    let path = test.context.pathFor( testCheck.path )
    var got;

    test.case = testCheck.name;

    provider.fileWrite( path, testCheck.data );

    try
    {
      got = provider.fileSize( path );
    }
    catch( err ) {}

    let expected = testCheck.expected;
    if( _.bigIntIs( got ) )
    expected = BigInt( expected );
    test.identical( got, expected );
  }

  //

  if( Config.debug )
  return;

  test.case = 'missed arguments';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( );
  });

  test.case = 'extra arguments';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( test.context.pathFor( 'tmp.tmp/fileSize/data2' ), test.context.pathFor( 'tmp.tmp/fileSize/data3' ) );
  });

  test.case = 'path is not string';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( { filePath : null } );
  });

  test.case = 'passed unexpected property';
  test.shouldThrowErrorSync( function( )
  {
    provider.fileSize( { filePath : test.context.pathFor( 'tmp.tmp/fileSize/data2' ), dir : test.context.pathFor( 'tmp.tmp/fileSize/data3' ) } );
  });

};

//

function fileExists( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let testDirPath = test.context.pathFor( 'written/fileExists' );
  let srcPath = test.context.pathFor( 'written/fileExists/src' );
  let dstPath = test.context.pathFor( 'written/fileExists/dst' );

  let hardLinked = true;
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) && !provider.UsingBigIntForStat )
  hardLinked = _.maybe;

  provider.filesDelete( testDirPath );

  test.case = 'not existing file';
  var got = provider.fileExists( srcPath );
  test.identical( got, false );

  test.case = 'terminal file as directory';
  provider.fileWrite( srcPath, srcPath );
  var filePath = provider.path.join( srcPath, 'notExistingFile' );
  var got = provider.fileExists( filePath );
  test.identical( got, false );

  test.case = 'regular file';
  provider.fileWrite( srcPath, srcPath );
  var got = provider.fileExists( srcPath );
  test.identical( got, true );

  test.case = 'directory';
  provider.dirMakeForFile( srcPath );
  var got = provider.fileExists( testDirPath );
  test.is( provider.isDir( testDirPath ) );
  test.identical( got, true );

  test.case = 'hard link to file';
  provider.fileWrite( srcPath, srcPath );
  provider.hardLink( dstPath, srcPath );
  var got = provider.fileExists( dstPath );
  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  test.identical( provider.filesAreHardLinked([ dstPath, srcPath ]), hardLinked );
  else
  test.identical( provider.filesAreHardLinked([ dstPath, srcPath ]), true );
  test.identical( got, true );

  if( !test.context.softLinkIsSupported() )
  return;

  test.case = 'soft link to file';
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, srcPath );
  var got = provider.fileExists( dstPath );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( got, true );

  test.case = 'soft link to file that not exists';
  provider.filesDelete( srcPath );
  provider.softLink({ dstPath, srcPath, allowingMissed : 1 });
  var got = provider.fileExists( dstPath );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( got, true );
}

//

function fileExistsCompliantBehavior( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileExistsCompliantBehavior' );
  let srcPath = test.context.pathFor( 'written/fileExistsCompliantBehavior/src' );
  let dstPath = test.context.pathFor( 'written/fileExistsCompliantBehavior/dst' );
  let dstPath2 = test.context.pathFor( 'written/fileExistsCompliantBehavior/dst2' );

  /*
    checks that fileExists has same behavior for hd & extract providers:
    resolves intermediate directories, but does not resolve terminal
  */

  test.case = 'soft link to missing, not intermediate links';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath,
    srcPath,
    allowingMissed : 1,
    makingDirectory : 1
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );

  //

  test.case = 'soft link chain to missing, not intermediate links';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath : dstPath2,
    srcPath,
    allowingMissed : 1,
    makingDirectory : 1
  });
  provider.softLink
  ({
    dstPath,
    srcPath : dstPath2,
    allowingMissed : 1,
  });
  test.is( !provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );
  test.is( provider.fileExists( dstPath2 ) );

  //

  test.case = 'path to missing, intermediate link to testDir';
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath,
    srcPath : routinePath,
    allowingMissed : 1,
    makingDirectory : 1
  });
  var pathToCheck = path.join( dstPath, 'src' );
  test.is( !provider.fileExists( pathToCheck ) );
  test.is( provider.fileExists( dstPath ) );

  //

  test.case = 'path to terminal, intermediate link to testDir';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink
  ({
    dstPath,
    srcPath : routinePath,
  });
  var pathToCheck = path.join( dstPath, 'src' );
  test.is( provider.fileExists( pathToCheck ) );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );

  //

  test.case = 'path to terminal, intermediate link to soft link in same directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( dstPath2, dstPath2 );
  provider.softLink
  ({
    dstPath : srcPath,
    srcPath : routinePath,
  });
  provider.softLink
  ({
    dstPath,
    srcPath,
  });
  /* dst -> src -> routinePath */
  var pathToCheck = path.join( routinePath, 'dst/dst2' );
  test.is( provider.fileExists( pathToCheck ) );
  test.is( provider.fileExists( srcPath ) );
  test.is( provider.fileExists( dstPath ) );

}

// --
// record
// --

function record( test )
{
  let self = this;
  let system = self.system || self.provider;
  let providerEffective = self.providerEffective || self.provider;

  test.is( providerEffective.system === system );
  test.is( _.arrayHas( _.mapKeys( system.providersWithProtocolMap ), providerEffective.protocol ) );

  let filePath = test.context.globalFromPreferred( '/record/terminal' );

  var record = self.provider.record( filePath );

  test.identical( record.absolute, filePath );

}

// --
// path
// --

function localsFromGlobals( test )
{
  let self = this;
  let srcProvider = self.providerEffective || self.provider;
  let provider = new srcProvider.constructor({ protocol : 'global' });

  test.open( 'string' );

  test.case = 'local';
  var got = provider.path.localsFromGlobals( '/a' );
  test.identical( got, '/a' );

  test.case = 'relative';
  var got = provider.path.localsFromGlobals( 'a' );
  test.identical( got, 'a' );

  test.case = 'single global string';
  var got = provider.path.localsFromGlobals( 'global:///a' );
  test.identical( got, '/a' )

  test.close( 'string' );

  test.open( 'array' );

  test.case = 'single global in array';
  var got = provider.path.localsFromGlobals( [ 'global:///a' ] );
  test.identical( got, [ '/a' ] )

  test.case = 'globals in array';
  var got = provider.path.localsFromGlobals( [ 'global:///a', 'global:///a/b' ] );
  test.identical( got, [ '/a', '/a/b' ] )

  test.close( 'array' );

  test.open( 'map' );

  var got = provider.path.localsFromGlobals( { 'global:///a' : 'global:///a' } );
  test.identical( got, { '/a' : '/a'} )

  var got = provider.path.localsFromGlobals( { '/a' : 'global:///a' } );
  test.identical( got, { '/a' : '/a'} )

  var got = provider.path.localsFromGlobals( { 'global:///a' : '/a' } );
  test.identical( got, { '/a' : '/a'} )

  var got = provider.path.localsFromGlobals( { 'global:///a' : 1 } );
  test.identical( got, { '/a' : 1 } )

  var got = provider.path.localsFromGlobals( { 1 : 'global:///a' } );
  test.identical( got, { 1 : '/a' } )

  var got = provider.path.localsFromGlobals( { 1 : 1 } );
  test.identical( got, { 1 : 1 } )

  test.close( 'map' );

  if( !Config.debug )
  return;

  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( '/a', '/b' ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( 'b:///a' ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( [ 'b:///a' ] ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { 'b:///a' : '/a' } ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { '/a' : 'b:///a' } ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { '/a' : [] } ) );
  test.shouldThrowErrorSync( () => provider.path.localsFromGlobals( { '/a' : {} } ) );

  provider.finit();

}

//

function globalsFromLocals( test )
{
  let self = this;
  let srcProvider = self.providerEffective || self.provider;
  let provider = new srcProvider.constructor({ protocol : 'global' });

  test.open( 'string' );

  test.case = 'local';
  var got = provider.path.globalsFromLocals( '/a' );
  test.identical( got, 'global:///a' );

  test.case = 'relative';
  var got = provider.path.globalsFromLocals( 'a' );
  test.identical( got, 'global://a' );

  test.case = 'global string';
  var got = provider.path.globalsFromLocals( 'global:///a' );
  test.identical( got, 'global:///a' )

  test.case = 'global string';
  var got = provider.path.globalsFromLocals( 'other:///a' );
  test.identical( got, 'other:///a' )

  test.close( 'string' );

  test.open( 'array' );

  test.case = 'single global in array';
  var got = provider.path.globalsFromLocals( [ 'global:///a' ] );
  test.identical( got, [ 'global:///a' ] )

  test.case = 'single global in array';
  var got = provider.path.globalsFromLocals( [ 'other:///a' ] );
  test.identical( got, [ 'other:///a' ] )

  test.case = 'globals in array';
  var got = provider.path.globalsFromLocals( [ 'global:///a', '/a/b', 'other:///a' ] );
  test.identical( got, [ 'global:///a', 'global:///a/b', 'other:///a' ] )

  test.close( 'array' );

  test.open( 'map' );

  var got = provider.path.globalsFromLocals( { 'global:///a' : 'other:///a' } );
  test.identical( got, { 'global:///a' : 'other:///a' } )

  var got = provider.path.globalsFromLocals( { 'other:///a' : 'global:///a' } );
  test.identical( got, { 'other:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { '/a' : 'global:///a' } );
  test.identical( got, { 'global:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { '/a' : '/a' } );
  test.identical( got, { 'global:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 'global:///a' : '/a' } );
  test.identical( got, { 'global:///a' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 'global:///a' : 1 } );
  test.identical( got, { 'global:///a' : 1 } )

  var got = provider.path.globalsFromLocals( { 1 : '/a' } );
  test.identical( got, { 'global://1' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 1 : 'global:///a' } );
  test.identical( got, { 'global://1' : 'global:///a' } )

  var got = provider.path.globalsFromLocals( { 1 : 1 } );
  test.identical( got, { 'global://1' : 1 } )

  test.close( 'map' );

  if( !Config.debug )
  return;

  test.shouldThrowErrorSync( () => provider.path.globalsFromLocals( '/a', '/b' ) );
  test.shouldThrowErrorSync( () => provider.path.globalsFromLocals( { '/a' : [] } ) );
  test.shouldThrowErrorSync( () => provider.path.globalsFromLocals( { '/a' : {} } ) );

  provider.finit();

}

//

function pathResolve( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;
  let resolve = _.routineJoin( provider.path, provider.path.resolve );
  let join = _.routineJoin( provider.path, provider.path.join );
  let current = _.routineJoin( provider.path, provider.path.current );

  test.case = 'join windows os paths';
  var got = resolve( 'c:\\', 'foo\\', 'bar\\' );
  var expected = '/c/foo/bar/';
  test.identical( got, expected );

  test.case = 'join unix os paths';
  var got = resolve( '/bar/', '/baz', 'foo/', '.' )
  var expected = '/baz/foo';
  test.identical( got, expected );

  test.case = 'here cases'; /* */

  var expected = join( current(), 'aa/cc' );
  var got = resolve( 'aa','.','cc' );
  test.identical( got, expected );

  var expected = join( current(), 'aa/cc' );
  var got = resolve( 'aa','cc','.' )
  test.identical( got, expected );

  var expected = join( current(), 'aa/cc' );
  var got = resolve( '.','aa','cc' );
  test.identical( got, expected );

  test.case = 'down cases'; /* */

  var expected = join( current(), 'aa' );
  var got = resolve( '.','aa','cc','..' );
  test.identical( got, expected );

  var expected = current();
  var got = resolve( '.','aa','cc','..','..' );
  test.identical( got, expected );

  var expected = _.strIsolateRightOrNone( current(),'/' )[ 0 ];
  if( current() === '/' )
  expected = '/..';
  var got = resolve( 'aa','cc','..','..','..' );
  test.identical( got, expected );

  test.case = 'like-down or like-here cases'; /* */

  var expected = join( current(), '.x./aa/bb/.x.' );
  var got = resolve( '.x.','aa','bb','.x.' );
  test.identical( got, expected );

  var expected = join( current(), '..x../aa/bb/..x..' );
  var got = resolve( '..x..','aa','bb','..x..' )
  test.identical( got, expected );

  test.case = 'period and double period combined'; /* */

  var expected = '/a/b';
  var got = resolve( '/abc','./../a/b');
  test.identical( got, expected );

  var expected = '/abc/a/b';
  var got = resolve( '/abc','a/.././a/b');
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( '/abc','.././a/b' );
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( '/abc','./.././a/b'  );
  test.identical( got, expected );

  var expected = '/';
  var got = resolve( '/abc','./../.' );
  test.identical( got, expected );

  var expected = '/..';
  var got = resolve( '/abc','./../../.' );
  test.identical( got, expected );

  var expected = '/';
  var got = resolve( '/abc','./../.' );
  test.identical( got, expected );

  //

  var expected = null;
  var got = resolve( null );
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( null, '/a', 'b' );
  test.identical( got, expected );

  var expected = '/a/b';
  var got = resolve( null, '/a', 'b' );
  test.identical( got, expected );

  var expected = join( current(), 'b' );
  var got = resolve( '/a', null, 'b' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( '/a', 'b', null );
  test.identical( got, expected );

  var expected = '/b';
  var got = resolve( null, 'a', '/b' );
  test.identical( got, expected );

  var expected = '/b';
  var got = resolve( 'a', null, '/b' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( 'a', '/b', null );
  test.identical( got, expected );

  var expected = '/b';
  var got = resolve( null, '/a', '../b' );
  test.identical( got, expected );

  var expected = join( provider.path.dir( current() ), 'b' );
  var got = resolve( '/a', null, '../b' );
  test.identical( got, expected );

  if( !Config.debug ) //
  return;

  test.case = 'nothing passed';
  test.shouldThrowErrorSync( function()
  {
    resolve();
  });

  test.case = 'non string passed';
  test.shouldThrowErrorSync( function()
  {
    resolve( {} );
  });

}

//

function uriResolve( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;
  let resolve = _.routineJoin( provider.path, provider.path.resolve );
  let join = _.routineJoin( provider.path, provider.path.join );
  let current = _.routineJoin( provider.path, provider.path.current );

  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1,1 );
    return;
  }

  test.open( 'with protocol' );

  var got = resolve( 'http://www.site.com:13','a' );
  test.identical( got, join( current(), 'http://www.site.com:13/a' ) );

  var got = resolve( 'http://www.site.com:13/','a' );
  test.identical( got, join( current(), 'http://www.site.com:13/a' ) );

  var got = resolve( 'http://www.site.com:13/','a','b' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13','a', '/b' );
  test.identical( got, join( current(), 'http:///b' ) );

  var got = resolve( 'http://www.site.com:13/','a','b','.' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13','a', '/b', 'c' );
  test.identical( got, join( current(), 'http:///b/c' ) );

  var got = resolve( 'http://www.site.com:13','/a/', '/b/', 'c/', '.' );
  test.identical( got, join( current(), 'http:///b/c' ) );

  var got = resolve( 'http://www.site.com:13','a', '.', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13/','a', '.', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/a/b' ) );

  var got = resolve( 'http://www.site.com:13','a', '..', 'b' );
  test.identical( got, join( current(), 'http://www.site.com:13/b' ) );

  var got = resolve( 'http://www.site.com:13','a', '..', '..', 'b' );
  test.identical( got, join( current(), 'http://b' ) );

  var got = resolve( 'http://www.site.com:13','.a.', 'b', '.c.' );
  test.identical( got, join( current(), 'http://www.site.com:13/.a./b/.c.' ) );

  var got = resolve( 'http://www.site.com:13','a/../' );
  test.identical( got, join( current(), 'http://www.site.com:13/' ) );

  test.close( 'with protocol' );

  /* - */

  test.open( 'with null protocol' );

  var got = resolve( '://www.site.com:13','a' );
  test.identical( got, join( current(), '://www.site.com:13/a' ) );

  var got = resolve( '://www.site.com:13','a', '/b' );
  test.identical( got, join( current(), ':///b' ) );

  var got = resolve( '://www.site.com:13','a', '/b', 'c' );
  test.identical( got, join( current(), ':///b/c' ) );

  var got = resolve( '://www.site.com:13','/a/', '/b/', 'c/', '.' );
  test.identical( got, join( current(), ':///b/c' ) );

  var got = resolve( '://www.site.com:13','a', '.', 'b' );
  test.identical( got, join( current(), '://www.site.com:13/a/b' ) );

  var got = resolve( '://www.site.com:13','a', '..', 'b' );
  test.identical( got, join( current(), '://www.site.com:13/b' ) );

  var got = resolve( '://www.site.com:13','a', '..', '..', 'b' );
  test.identical( got, join( current(), '://b' ) );

  var got = resolve( '://www.site.com:13','.a.', 'b','.c.' );
  test.identical( got, join( current(), '://www.site.com:13/.a./b/.c.' ) );

  var got = resolve( '://www.site.com:13','a/../' );
  test.identical( got, join( current(), '://www.site.com:13/' ) );

  test.close( 'with null protocol' );

  /* */

  var got = resolve( ':///www.site.com:13','a' );
  test.identical( got, ':///www.site.com:13/a' );

  var got = resolve( ':///www.site.com:13/','a' );
  test.identical( got, ':///www.site.com:13/a' );

  var got = resolve( ':///www.site.com:13','a', '/b' );
  test.identical( got, ':///b' );

  var got = resolve( ':///www.site.com:13','a', '/b', 'c' );
  test.identical( got, ':///b/c' );

  var got = resolve( ':///www.site.com:13','/a/', '/b/', 'c/', '.' );
  test.identical( got, ':///b/c' );

  var got = resolve( ':///www.site.com:13','a', '.', 'b' );
  test.identical( got, ':///www.site.com:13/a/b' );

  var got = resolve( ':///www.site.com:13/','a', '.', 'b' );
  test.identical( got, ':///www.site.com:13/a/b' );

  var got = resolve( ':///www.site.com:13','a', '..', 'b' );
  test.identical( got, ':///www.site.com:13/b' );

  var got = resolve( ':///www.site.com:13','a', '..', '..', 'b' );
  test.identical( got, ':///b' );

  var got = resolve( ':///www.site.com:13','.a.', 'b','.c.' );
  test.identical( got, ':///www.site.com:13/.a./b/.c.' );

  var got = resolve( ':///www.site.com:13/','.a.', 'b','.c.' );
  test.identical( got, ':///www.site.com:13/.a./b/.c.' );

  var got = resolve( ':///www.site.com:13','a/../' );
  test.identical( got, ':///www.site.com:13/' );

  var got = resolve( ':///www.site.com:13/','a/../' );
  test.identical( got, ':///www.site.com:13/' );

  /* */

  var got = resolve( '/some/staging/index.html','a' );
  test.identical( got, '/some/staging/index.html/a' );

  var got = resolve( '/some/staging/index.html','.' );
  test.identical( got, '/some/staging/index.html' );

  var got = resolve( '/some/staging/index.html/','a' );
  test.identical( got, '/some/staging/index.html/a' );

  var got = resolve( '/some/staging/index.html','a', '/b' );
  test.identical( got, '/b' );

  var got = resolve( '/some/staging/index.html','a', '/b', 'c' );
  test.identical( got, '/b/c' );

  var got = resolve( '/some/staging/index.html','/a/', '/b/', 'c/', '.' );
  test.identical( got, '/b/c' );

  var got = resolve( '/some/staging/index.html','a', '.', 'b' );
  test.identical( got, '/some/staging/index.html/a/b' );

  var got = resolve( '/some/staging/index.html/','a', '.', 'b' );
  test.identical( got, '/some/staging/index.html/a/b' );

  var got = resolve( '/some/staging/index.html','a', '..', 'b' );
  test.identical( got, '/some/staging/index.html/b' );

  var got = resolve( '/some/staging/index.html','a', '..', '..', 'b' );
  test.identical( got, '/some/staging/b' );

  var got = resolve( '/some/staging/index.html','.a.', 'b','.c.' );
  test.identical( got, '/some/staging/index.html/.a./b/.c.' );

  var got = resolve( '/some/staging/index.html/','.a.', 'b','.c.' );
  test.identical( got, '/some/staging/index.html/.a./b/.c.' );

  var got = resolve( '/some/staging/index.html','a/../' );
  test.identical( got, '/some/staging/index.html/' );

  var got = resolve( '/some/staging/index.html/','a/../' );
  test.identical( got, '/some/staging/index.html/' );

  var got = resolve( '//some/staging/index.html', '.', 'a' );
  test.identical( got, '//some/staging/index.html/a' )

  var got = resolve( '///some/staging/index.html', 'a', '.', 'b', '..' );
  test.identical( got, '///some/staging/index.html/a' )

  var got = resolve( 'file:///some/staging/index.html', '../..' );
  test.identical( got, 'file:///some' )

  var got = resolve( 'svn+https://user@subversion.com/svn/trunk', '../a', 'b', '../c' );
  test.identical( got, join( current(), 'svn+https://user@subversion.com/svn/a/c' ) );

  var got = resolve( 'complex+protocol://www.site.com:13/path/name?query=here&and=here#anchor', '../../path/name' );
  test.identical( got, join( current(), 'complex+protocol://www.site.com:13/path/name?query=here&and=here#anchor' ) );

  var got = resolve( 'https://web.archive.org/web/*\/http://www.heritage.org/index/ranking', '../../../a.com' );
  test.identical( got, join( current(), 'https://web.archive.org/web/*\/http://a.com' ) );

  var got = resolve( '127.0.0.1:61726', '../path'  );
  test.identical( got, join( current(),'path' ) )

  var got = resolve( 'http://127.0.0.1:61726', '../path'  );
  test.identical( got, join( current(), 'http://path' ) );

  //

  var expected = 'file:///staging';
  var got = resolve( null, 'file:///some/index.html', '/staging' );
  test.identical( got, expected );

  var expected = join( current(), 'staging' );
  var got = resolve( 'file:///some/index.html', null, 'staging' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( 'file:///some', 'staging', null );
  test.identical( got, expected );

  var expected = 'file:///some';
  var got = resolve( null, 'a', 'file:///some' );
  test.identical( got, expected );

  var expected = 'file:///some';
  var got = resolve( 'a', null, 'file:///some' );
  test.identical( got, expected );

  var expected = null;
  var got = resolve( 'a', 'file:///some', null );
  test.identical( got, expected );

  var expected = 'file:///b';
  var got = resolve( null, 'file:///some', '../b' );
  test.identical( got, expected );

  var expected = join( provider.path.dir( current() ), 'b' );
  var got = resolve( 'file:///some', null, '../b' );
  test.identical( got, expected );

}

//

function linkingCriticalCases( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  /*
    qqq : cases with preservingRelative : 0 or resolvingHeadDirect : 0 are disabled,
    pathResolveLinkFull does not allow to disable these option for now
    Vova : low priority
  */

  let routinePath = test.context.pathFor( 'written/linkingCriticalCases' );
  let filePath = test.context.pathFor( 'written/linkingCriticalCases/file' );
  let linkPath = test.context.pathFor( 'written/linkingCriticalCases/link' );
  let linkPath2 = test.context.pathFor( 'written/linkingCriticalCases/link2' );

  /* */

  test.case = 'not existing file, allowingMissed : 0';
  provider.filesDelete( self.provider.path.dir( filePath ) );

  // works after change in pathResolveLinkHeadDirect
  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 0,
     resolvingHeadDirect : 1,
     resolvingHeadReverse : 1,
     resolvingSoftLink : 1,
     resolvingTextLink : 1,
     throwing : 0,
  });
  test.identical( got.filePath, null );
  test.identical( got.absolutePath, null );
  test.identical( got.relativePath, null );

  test.case = 'not existing file, allowingMissed : 1';

  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 1,
     resolvingHeadDirect : 1,
     resolvingHeadReverse : 1,
     resolvingSoftLink : 1,
     resolvingTextLink : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  // test.case = 'not existing file, allowingMissed : 0, resolvingHeadDirect : 0, resolvingHeadReverse : 0';

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 0,
  //    resolvingHeadDirect : 0,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, null );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 0,
  //    resolvingHeadDirect : 1,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, null );

  //

  test.case = 'not existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );

  //should return same even if resolvingHead is off
  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 0,
  //    resolvingHeadDirect : 0,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, null );

  /* */

  // works after change in pathResolveLinkHeadDirect
  // test.case = 'two soft links in path';
  // provider.filesDelete( path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o =
  // {
  //   filePath : path.join( routinePath, 'link/link2' ),
  //   preservingRelative : 1,
  //   resolvingHeadDirect : 1,
  //   resolvingHeadReverse : 0,
  //   allowingMissed : 0,
  //   throwing : 1
  // };
  // var got = provider.pathResolveLinkFull( o );
  // var expectedResult = filePath;
  // test.identical( got, expectedResult );

  /* */

  //this case does not work becase of _softLinkSkip
  test.case = 'cycle softLink, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );

  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });

  test.is( provider.isSoftLink( linkPath ) );
  test.is( provider.isSoftLink( linkPath2 ) );

  let files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link2' ] );

  var o =
  {
    filePath : linkPath,
    preservingRelative : 1,
    allowingCycled : 1,
    throwing : 1
  };
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

}

//

function pathResolveLinkTailChain( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  /* - */

  let o1 =
  {
    system : null,
    filePath : null,
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    preservingRelative : 0,
    allowingMissed : 1,
    throwing : 1
  }

  let routinePath = test.context.pathFor( 'written/pathResolveLinkTailChain' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkTailChain/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkTailChain/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkTailChain/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkTailChain/link3' );

  provider.fieldPush( 'usingTextLink', true );

  /* - */

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );

  var o =
  {
    filePath : linkPath,
    resolvingSoftLink : 1,
  }
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] );
  test.identical( o.found, [ linkPath, filePath ] );

  /* trivial */

  // var tree =
  // {
  //   directory :
  //   {
  //     terminal : 'terminal'
  //   },
  //   toDir : [{ softLink : '/directory' }]
  // }

  provider.fileWrite( path.join( routinePath, 'directory/terminal' ), 'terminal' );
  provider.dirMake( path.join( routinePath, 'toDir' ) );
  provider.softLink( path.join( routinePath, 'toDir/softLink' ), path.join( routinePath, 'directory/terminal' ) );

  var o =
  {
    filePath : path.join( routinePath, 'toDir/softLink' ),
    // resolvingHeadDirectories : 1,
    allowingMissed : 1,
    throwing : 1,
  }
  debugger;
  var got = provider.pathResolveLinkTailChain( o );
  debugger;

  test.is( got === o.result );
  test.identical( o.result, [ path.join( routinePath, 'toDir/softLink' ), path.join( routinePath, 'directory/terminal' ) ] );
  test.identical( o.found, [ path.join( routinePath, 'toDir/softLink' ), path.join( routinePath, 'directory/terminal' ) ] );

  // debugger; return; xxx

  /*
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    preservingRelative : [ 0,1 ],
    allowingMissed : [ 0,1 ],
    throwing : 1
  */

  /* basic */

  test.case = 'not existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath, null ] )
  test.identical( o.found, [ filePath, null ] )

  test.case = 'existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath ] )
  test.identical( o.found, [ filePath ] )

  test.case = 'hardLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath ] )
  test.identical( o.found, [ linkPath ] )

  test.case = 'softLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,filePath ] )
  test.identical( o.found, [ linkPath,filePath ] )

  test.case = 'relative softLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath,filePath ] )

  test.case = 'relative softLink, preservingRelative : 1';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  var expectedFound = [ linkPath, filePath ]
  var expectedResult = [ linkPath, test.context.globalFromPreferred( '../file' ) ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  test.case = 'textLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  //

  test.case = 'absolute softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  //

  test.case = 'absolute softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, preservingRelative : 1 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  //

  test.case = 'relative softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath,filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  //

  test.case = 'relative softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath,filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, preservingRelative : 1 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedResult =
  [
    linkPath,
    test.context.globalFromPreferred( '../file' ),
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  //

  test.case = 'absolute softLink to missing, allowingMissed : 0'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  //

  test.case = 'absolute softLink to missing, allowingMissed : 1'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  //

  test.case = 'relative softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath,filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0  } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  //

  test.case = 'relative softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var filePathRelative = provider.path.relative( linkPath,filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1  } );
  var got = provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    filePath,
    null
  ]
  var expectedResult =
  [
    linkPath,
    filePath,
    null
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound );

  /* chain */

  test.case = 'soft-soft-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath2, filePath );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,filePath ] );
  test.identical( o.found, [ linkPath,linkPath2,filePath ] );

  test.case = 'soft-soft-file, preservingRelative';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath2, filePath );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,filePath ] );
  test.identical( o.found, [ linkPath,linkPath2,filePath ] );

  test.case = 'text-text-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, filePath ] );

  test.case = 'text-text-file, preservingRelative';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, filePath ] );

  test.case = 'soft-text-soft-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath3,filePath ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath3,filePath ] );

  test.case = 'soft-text-soft-file, preservingRelative';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath3 ) );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath3,filePath ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath3,filePath ] );

  test.case = 'text-soft-text-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink( linkPath2, linkPath3 );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] );

  test.case = 'text-soft-text-file, preservingRelative';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.softLink( linkPath2, linkPath3 );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] );

  test.case = 'relative soft-relative soft-soft-file, preservingRelative : 1';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath3, filePath );
  provider.softLink( linkPath2, '../link3' );
  provider.softLink( linkPath, '../link2' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  var expectedFound =
  [
    linkPath,
    linkPath2,
    linkPath3,
    filePath
  ]
  var expectedResult =
  [
    linkPath,
    test.context.globalFromPreferred( '../link2' ),
    test.context.globalFromPreferred( '../link3' ),
    filePath
  ]
  test.identical( o.result, expectedResult );
  test.identical( o.found, expectedFound);

  debugger;

  test.case = 'soft-hard-text-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.hardLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] )
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] )

  test.case = 'relative soft-hard-text-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.hardLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, provider.path.relative( linkPath, linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath3, filePath ] )
  test.identical( o.found, [ linkPath, linkPath2, linkPath3, filePath ] )

  test.case = 'relative soft-hard-text-file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath3, 'link ' + provider.path.preferredFromGlobal( filePath ));
  provider.hardLink( linkPath2, linkPath3 );
  provider.softLink( linkPath, provider.path.relative( linkPath, linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.found, [ linkPath, linkPath2, linkPath3,filePath ] )
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../link2' ), linkPath3,filePath ]  )

  // /* chain, resolvingHeadDirectories : [ 0, 1 ] */

  // test.case = 'two soft links in path';
  // provider.filesDelete( self.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ) , preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // var expectedFound =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   '../file',
  //   path.join( routinePath, 'link/file' ),
  // ]
  // var expectedResult =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   path.join( routinePath, 'link/file' ),
  // ]
  // test.identical( o.result, expectedResult );
  // test.identical( o.found, expectedFound );

  // //

  // test.case = 'two soft links in path';
  // provider.filesDelete( self.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ) , preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // var expectedFound =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   path.join( routinePath, 'link' ),
  //   '..',
  //   routinePath,
  //   linkPath2,
  //   '../file',
  //   filePath,
  // ]
  // var expectedResult =
  // [
  //   path.join( routinePath, 'link/link2' ),
  //   path.join( routinePath, 'link' ),
  //   routinePath,
  //   linkPath2,
  //   filePath
  // ]
  // test.identical( o.result, expectedResult );
  // test.identical( o.found, expectedFound );

  // //

  // test.case = 'several absolute soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, pathToFile ] )
  // test.identical( o.found, [ routinePath, pathToFile ] )

  // //

  // test.case = 'several absolute soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )
  // test.identical( o.found, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )

  // //

  // test.case = 'several relative soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.found, [ routinePath, '../../file', path.join( dirPath, 'linkToDir1/file'), null ] )
  // test.identical( o.result, [ routinePath, path.join( dirPath, 'linkToDir1/file'), null ] )

  // //

  // test.case = 'several relative soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.found, [ routinePath, linkToDir1Path, '../dir1', dir1Path, linkToTerminalPath, '../../dir2', dirPath2, linkInDir2, '../../file', pathToFile ] )
  // test.identical( o.result, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )

  // //

  // test.case = 'several absolute text links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirectories : 1 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )
  // test.identical( o.found, [ routinePath, linkToDir1Path, dir1Path, linkToTerminalPath, dirPath2, linkInDir2, pathToFile ] )

  // //

  // test.case = 'several absolute text links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirectories : 0 } );
  // var got = provider.pathResolveLinkTailChain( o );
  // test.identical( o.result, [ routinePath, null ] )
  // test.identical( o.found, [ routinePath, null ] )

  /* cycle, throwing : [ 0,1 ], allowingMissed : [ 0,1 ] */

  test.case = 'self cycle softLink, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath, null ] );

  test.case = 'self cycle softLink, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'self cycle softLink, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath, null ] );

  test.case = 'self cycle softLink, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath, null ] );

  test.case = 'self cycle text, throwing on '
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath, null ] );

  test.case = 'self cycle text, throwing on '
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'self cycle text, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath, null ] );

  test.case = 'self cycle text, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath, 'link ' + '../link' );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath, null ] );

  test.case = 'cycle softLink, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle softLink, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'cycle softLink, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle softLink, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle text link, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle text link, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'cycle text link, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle text link, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( linkPath2 ) );
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle soft text, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle soft text, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 1, allowingMissed : 0, allowingCycled : 0 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );

  test.case = 'cycle soft text, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 1 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );

  test.case = 'cycle soft text, throwing off'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( linkPath2, 'link ' + provider.path.preferredFromGlobal( linkPath ) );
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, throwing : 0, allowingMissed : 0 } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,linkPath2,linkPath, null ] );
  test.identical( o.found, [ linkPath,linkPath2,linkPath, null ] );


  /* allowingMissed : 0 throwing : 1, preservingRelative : [ 0, 1 ] */

  o1.allowingMissed = 0;
  o1.throwing = 1;

  //

  test.case = 'not existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var o = _.mapExtend( null, o1, { filePath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ filePath, null ] )
  test.identical( o.found, [ filePath, null ] )

  test.case = 'existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath ] )
  test.identical( o.found, [ filePath ] )

  test.case = 'hardLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath ] )
  test.identical( o.found, [ linkPath ] )

  test.case = 'softLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,filePath ] )
  test.identical( o.found, [ linkPath,filePath ] )

  test.case = 'relative softLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath,filePath ] )

  test.case = 'textLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,filePath, null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,filePath, null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,filePath, null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'double textLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  test.case = 'double softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  test.case = 'soft to text to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  test.case = 'text to soft to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  /* allowingMissed : 0 throwing : 0, preservingRelative : [ 0, 1 ] */

  o1.allowingMissed = 0;
  o1.throwing = 0;

  //

  test.case = 'not existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath, null ] )
  test.identical( o.found, [ filePath, null ] )

  test.case = 'existing file';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  var o = _.mapExtend( null, o1, { filePath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ filePath ] )
  test.identical( o.found, [ filePath ] )

  test.case = 'hardLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath ] )
  test.identical( o.found, [ linkPath ] )

  test.case = 'softLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath,filePath ] )
  test.identical( o.found, [ linkPath,filePath ] )

  test.case = 'relative softLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath,filePath ] )

  test.case = 'textLink';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] )
  test.identical( o.found, [ linkPath, filePath ] )

  test.case = 'softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,filePath, null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,filePath, null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'relative softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,filePath, null ] )
  test.identical( o.found, [ linkPath,filePath, null ] )

  test.case = 'textLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath, preservingRelative : 1 } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath, test.context.globalFromPreferred( '../file' ), null ] )
  test.identical( o.found, [ linkPath, filePath, null ] )

  test.case = 'double textLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  test.case = 'double softLink to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  test.case = 'soft to text to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  test.case = 'text to soft to missing';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  test.mustNotThrowError( () => provider.pathResolveLinkTailChain( o ) );
  test.identical( o.result, [ linkPath,linkPath2, filePath, null ] )
  test.identical( o.found, [ linkPath,linkPath2, filePath, null ] )

  provider.fieldPop( 'usingTextLink', true );
}

pathResolveLinkTailChain.timeOut = 30000;

//

function pathResolveLinkFull( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  /*
    qqq : cases with preservingRelative : 0 or resolvingHeadDirect : 0 are disabled,
    pathResolveLinkFull does not allow to disable these option for now
    Vova : low priority
  */

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFull' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkFull/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkFull/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkFull/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkFull/link3' );
  let terminalInDirPath = provider.path.join( routinePath, 'terminal' );
  let toDirPath = path.join( routinePath, 'toDir' );

  provider.fieldPush( 'usingTextLink', true );

  /* - */

  test.open( 'critical' );

  var tree =
  {
    directory :
    {
      terminal : 'terminal',
    },
    toDir : [{ softLink : '/directory' }],
  }

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( toDirPath, routinePath );

  var o2 =
  {
     filePath : path.join( toDirPath, 'terminal' ),
     allowingMissed : 0,
     throwing : 0,
  }
  var got = provider.pathResolveLinkFull( o2 );
  test.identical( got.absolutePath, terminalInDirPath );

  test.close( 'critical' );

  /* - */

  test.case = 'not existing file';
  provider.filesDelete( path.dir( filePath ) );

  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 0,
     throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
       filePath,
       allowingMissed : 0,
       throwing : 1,
    });
  })

  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 1,
     throwing : 1,
  });
  test.identical( got.absolutePath, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 0,
  //    resolvingHeadDirect : 0,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, null );

  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 0,
     resolvingHeadDirect : 1,
     resolvingHeadReverse : 1,
     resolvingSoftLink : 1,
     resolvingTextLink : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 0,
  //    resolvingHeadDirect : 1,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, null );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 0,
  //    resolvingHeadDirect : 0,
  //    resolvingHeadReverse : 1,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, null );

  var got = provider.pathResolveLinkFull
  ({
     filePath,
     allowingMissed : 1,
     resolvingHeadDirect : 1,
     resolvingHeadReverse : 1,
     resolvingSoftLink : 1,
     resolvingTextLink : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 1,
  //    resolvingHeadDirect : 0,
  //    resolvingHeadReverse : 1,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 1,
  //    resolvingHeadDirect : 1,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, filePath );

  // var got = provider.pathResolveLinkFull
  // ({
  //    filePath,
  //    allowingMissed : 1,
  //    resolvingHeadDirect : 0,
  //    resolvingHeadReverse : 0,
  //    resolvingSoftLink : 1,
  //    resolvingTextLink : 1,
  //    throwing : 0,
  // });
  // test.identical( got, filePath );

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //      filePath,
  //      allowingMissed : 0,
  //      resolvingHeadDirect : 0,
  //      resolvingHeadReverse : 0,
  //      resolvingSoftLink : 1,
  //      resolvingTextLink : 1,
  //      throwing : 1,
  //   });
  // })

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //      filePath,
  //      allowingMissed : 0,
  //      resolvingHeadDirect : 1,
  //      resolvingHeadReverse : 0,
  //      resolvingSoftLink : 1,
  //      resolvingTextLink : 1,
  //      throwing : 1,
  //   });
  // })

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //      filePath,
  //      allowingMissed : 0,
  //      resolvingHeadDirect : 0,
  //      resolvingHeadReverse : 1,
  //      resolvingSoftLink : 1,
  //      resolvingTextLink : 1,
  //      throwing : 1,
  //   });
  // })

  // test.shouldThrowErrorOfAnyKind( () =>
  // {
  //   provider.pathResolveLinkFull
  //   ({
  //      filePath,
  //      allowingMissed : 0,
  //      resolvingHeadDirect : 0,
  //      resolvingHeadReverse : 0,
  //      resolvingSoftLink : 0,
  //      resolvingTextLink : 0,
  //      throwing : 1,
  //   });

  // })

  // var got = provider.pathResolveLinkFull
  // ({
  //     filePath,
  //     allowingMissed : 1,
  //     resolvingHeadDirect : 0,
  //     resolvingHeadReverse : 0,
  //     resolvingSoftLink : 0,
  //     resolvingTextLink : 0,
  //     throwing : 1,
  // });
  // test.identical( got, filePath )

  // var got = provider.pathResolveLinkFull
  // ({
  //     filePath,
  //     allowingMissed : 0,
  //     resolvingHeadDirect : 0,
  //     resolvingHeadReverse : 0,
  //     resolvingSoftLink : 0,
  //     resolvingTextLink : 0,
  //     throwing : 0,
  // });
  // test.identical( got, null );

  //

  test.case = 'absolute softLink to missing'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingMissed : 0,
     throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingMissed : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, filePath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : linkPath,
      allowingMissed : 0,
      throwing : 1,
    });
  })

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingMissed : 1,
     throwing : 1,
  });
  test.identical( got.absolutePath, filePath );

  //

  test.case = 'self cycle softLink'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath, srcPath : '../link', allowingMissed : 1, makingDirectory : 1 });

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingCycled : 0,
     throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.filePath, null );
  test.identical( got.relativePath, null );

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingCycled : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, linkPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : linkPath,
      allowingCycled : 0,
      throwing : 1,
    });
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingCycled : 1,
     throwing : 1,
  });
  test.identical( got.absolutePath, linkPath );

  //

  test.case = 'cycle softLink'
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingCycled : 0,
     throwing : 0,
  });
  test.identical( got.absolutePath, null );
  test.identical( got.relativePath, null );
  test.identical( got.filePath, null );

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingCycled : 1,
     throwing : 0,
  });
  test.identical( got.absolutePath, linkPath );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    provider.pathResolveLinkFull
    ({
      filePath : linkPath,
      allowingCycled : 0,
      throwing : 1,
    });
  })
  test.identical( got.absolutePath, linkPath );

  var got = provider.pathResolveLinkFull
  ({
     filePath : linkPath,
     allowingCycled : 1,
     throwing : 1,
  });
  test.identical( got.absolutePath, linkPath );

  provider.fieldPop( 'usingTextLink', true );

  /* chain, resolvingHeadDirect : [ 0, 1 ], resolvingHeadReverse : 0 */

  var o1 =
  {
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    allowingMissed : 1,
    resolvingHeadDirect : 0,
    resolvingHeadReverse : 0,
    throwing : 1
  }

  // test.case = 'two soft links in path';
  // provider.filesDelete( self.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ) , preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // var expected = path.join( routinePath, 'link/file' );
  // test.identical( got,expected )

  //

  // test.case = 'two soft links in path';
  // provider.filesDelete( self.provider.path.dir( filePath ) );
  // provider.fileWrite( filePath, filePath );
  // provider.softLink( linkPath, '..' );
  // provider.softLink( linkPath2, '../file' );
  // var o = _.mapExtend( null, o1, { filePath : path.join( routinePath, 'link/link2' ) , preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 1 } );
  // var got = provider.pathResolveLinkFull( o );
  // var expected = filePath;
  // test.identical( got,expected );

  //

  // test.case = 'several absolute soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got,path.join( dirPath, pathToFile ) );

  //

  // test.case = 'several absolute soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, dir1Path );
  // provider.softLink( linkToTerminalPath, dirPath2 );
  // provider.softLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 1 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got,pathToFile );

  //

  // test.case = 'several relative soft links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // var expected = path.join( dirPath, 'linkToDir1/file' );
  // test.identical( got,expected );


  //

  test.case = 'several relative soft links in path';
  var dirPath = self.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile,pathToFile );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file

    path : 'dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 0, resolvingHeadDirect : 1, resolvingHeadReverse : 1 } );
  var got = provider.pathResolveLinkFull( o );
  test.identical( got.absolutePath,pathToFile );

  //

  test.case = 'several relative soft links in path';
  var dirPath = self.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile,pathToFile );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file

    path : 'dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 1 } );
  var got = provider.pathResolveLinkFull( o );
  var expected = provider.path.relative( linkInDir2, pathToFile );
  test.identical( got.filePath,expected );

  //

  // test.case = 'several absolute text links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 0 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got,routinePath );

  //

  // test.case = 'several absolute text links in path';
  // var dirPath = self.provider.path.dir( filePath );
  // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.textLink( linkToDir1Path, dir1Path );
  // provider.textLink( linkToTerminalPath, dirPath2 );
  // provider.textLink( linkInDir2, pathToFile );

  // /*
  //   dir :
  //     dir1 :
  //       linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir1
  //     file

  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */

  // var routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath , preservingRelative : 1, resolvingHeadDirect : 0, resolvingHeadReverse : 1 } );
  // var got = provider.pathResolveLinkFull( o );
  // test.identical( got,pathToFile );

}

pathResolveLinkFull.timeOut = 30000;

//

function pathResolveSoftLink( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveSoftLink' );
  let filePath = test.context.pathFor( 'written/pathResolveSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveSoftLink/link3' );
  let dirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir/terminal' );
  let testData = 'pathResolveSoftLink';

  var o1 =
  {
  };

  test.case = 'not existing file';
  provider.filesDelete( routinePath );
  var o = _.mapExtend( null, o1, { filePath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'existing regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var o = _.mapExtend( null, o1, { filePath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'hardlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.hardLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  // textLinks

  test.case = 'textlink';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.fileWrite( linkPath, 'link ' + provider.path.preferredFromGlobal( filePath ));
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  test.case = 'textlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textlink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  test.case = 'relative textlink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, linkPath );

  // softLinks

  test.case = 'absolute softlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'relative softlink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath, '../file' );
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, test.context.globalFromPreferred( '../file' ) );

  test.case = 'absolute softlink to missing'
  provider.filesDelete( routinePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePath,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'relative softlink to missing'
  provider.filesDelete( routinePath );
  var filePathRelative = provider.path.relative( linkPath,filePath );
  provider.softLink
  ({
    dstPath : linkPath,
    srcPath : filePathRelative,
    makingDirectory : 1,
    allowingMissed : 1
  });
  var o = _.mapExtend( null, o1, { filePath : linkPath } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePathRelative );

  // Chains of links

  test.case = 'Chain with two absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveSoftLink( { filePath : got } );
  test.identical( got1, filePath );
  var got2 = provider.pathResolveSoftLink( { filePath : got1 } );
  test.identical( got2, filePath );

  test.case = 'Chain with relative and absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveSoftLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath );

  test.case = 'Chain with absolute and relative soft link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveSoftLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file0' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath + '0' );

  test.case = 'Chain with two absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative text link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveSoftLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  /* resolvingMultiple */

  test.case = 'single soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath, filePath );
  var o = _.mapExtend( null, o1, { filePath : linkPath, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'double soft link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink( linkPath2, filePath );
  provider.softLink( linkPath, linkPath2 );
  var o = _.mapExtend( null, o1, { filePath : linkPath, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'Chain with two softlink and text link to missing file';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.softLink({ dstPath : linkPath3, srcPath : linkPath2 });
  var got = provider.pathResolveSoftLink( { filePath : linkPath3, resolvingMultiple : 1 } );
  test.identical( got, linkPath );

  test.case = 'Chain with two softlink, last link is broken';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2, resolvingMultiple : 1 } );
  test.identical( got, filePath );

  test.case = 'Chain with two textlinks';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2, resolvingMultiple : 1 } );
  test.identical( got, linkPath2 );

  test.case = 'Chain with two relative softLinks';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : '../link' });
  var got = provider.pathResolveSoftLink( { filePath : linkPath2, resolvingMultiple : 1 } );
  test.identical( got, filePath );

  test.case = 'Chain with relative and absolute softLinks';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.softLink({ dstPath : linkPath3, srcPath : '../link2' });
  var got = provider.pathResolveSoftLink( { filePath : linkPath3, resolvingMultiple : 1 } );
  test.identical( got, filePath );

  /* resolvingIntermediateDirectories */

  test.case = 'two soft links in path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '..' );
  provider.softLink( linkPath2, test.context.globalFromPreferred( '../file' ) );
  var pathToResolve = provider.path.join( routinePath, 'link/link2' )
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, filePath );

  test.case = 'intermediate absolute soft link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate absolute soft link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate chain of soft links to other directory, resolvingMultiple off';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveSoftLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of soft links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, dirPath );
  provider.softLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate chain of relative soft links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, '../dir' );
  provider.softLink( linkPath, '../link2' );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveSoftLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of relative soft links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath2, '../dir' );
  provider.softLink( linkPath, '../link2' );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, o1, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveSoftLink( o );
  test.identical( got, terminalInDirPath );

  /* */

  if( !Config.debug )
  return;

  test.case = 'No object input';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath } );
  test.mustNotThrowError( () => provider.pathResolveSoftLink( linkPath ) );

  test.case = 'No arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( ) );

  test.case = 'Too many arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : linkPath }, { filePath : linkPath } ) );

  test.case = 'No filePath option';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { otherPath : linkPath } ) );

  test.case = 'Redundant option';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : linkPath, allowingMissed : 1 } ) );

  test.case = 'Wrong filePath options - undefined';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : undefined } ) );

  test.case = 'Wrong filePath options - number';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : 3.14159 } ) );

  test.case = 'Wrong filePath options - array';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : [ 0, 'a' ] } ) );

  test.case = 'Wrong filePath options - null';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : null } ) );

  test.case = 'Wrong filePath options - NaN';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveSoftLink( { filePath : NaN } ) );

}

//

function pathResolveTextLink( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveSoftLink' );
  let filePath = test.context.pathFor( 'written/pathResolveSoftLink/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveSoftLink/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveSoftLink/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveSoftLink/link3' );
  let dirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir' );
  let terminalInDirPath = test.context.pathFor( 'written/pathResolveSoftLink/dir/terminal' );
  let testData = 'pathResolveTextLink';

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var o = { filePath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'hardLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  /*

    Add test cases :

    absolute textLink to file that does not exist
    relative textLink to file that does not exist
    relative textLink to regular file

    use allowingMissed : 1 option to create link for missing file
  */

  test.case = 'absolute textLink to file that does not exist';
  provider.filesDelete( routinePath );  // remove temp files created by previous test case
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1  });
  var o = { filePath : linkPath }; // create options map for current test case
  var got = provider.pathResolveTextLink( o ); // call routine and save result
  test.identical( got, filePath ); // check result

  test.case = 'relative textLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, test.context.globalFromPreferred( '../file2' ) );

  test.case = 'relative textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, test.context.globalFromPreferred( '../file' ) );

  test.case = 'absolute softLink to file that does not exist';
  provider.filesDelete( routinePath );  // remove temp files created by previous test case
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 }); // prepare link for test case
  var o = { filePath : linkPath }; // create options map for current test case
  var got = provider.pathResolveTextLink( o ); // call routine and save result
  test.identical( got, linkPath ); // check result

  test.case = 'relative softLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'Chain with two absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveTextLink( { filePath : got } );
  test.identical( got1, filePath );
  var got2 = provider.pathResolveTextLink( { filePath : got1 } );
  test.identical( got2, filePath );

  test.case = 'Chain with relative and absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveTextLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath );

  test.case = 'Chain with absolute and relative text link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath2 );
  var got1 = provider.pathResolveTextLink( { filePath : got } );
  test.identical( got1, test.context.globalFromPreferred( '../file0' ) );
  var got2 = provider.path.resolve( linkPath2, got1 );
  test.identical( got2, filePath + '0' );

  test.case = 'Chain with two absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative soft link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath );

  provider.fieldPop( 'usingTextLink', 1 );

  /**/

  provider.fieldPush( 'usingTextLink', 0 );

  test.case = 'regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  var o = { filePath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'hardLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.hardLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute textLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1  });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative textLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative textLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'absolute softLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 }); // prepare link for test case
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative softLink to file that does not exist';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : '../file2', allowingMissed : 1, makingDirectory : 1 });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'relative softLink to regular file';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file' });
  var o = { filePath : linkPath };
  var got = provider.pathResolveTextLink( o );
  test.identical( got, linkPath );

  test.case = 'Chain with two absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : filePath });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative text link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.textLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with two absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : filePath });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with relative and absolute soft links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file' });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute and relative soft link that doesnt exist';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath2, srcPath : '../file0', allowingMissed : 1, makingDirectory : 1  });
  provider.softLink({ dstPath : linkPath, srcPath : linkPath2  });
  var got = provider.pathResolveTextLink( { filePath : linkPath } );
  test.identical( got, linkPath );

  test.case = 'Chain with absolute soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : filePath });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath2 );

  test.case = 'Chain with relative soft and text links';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.softLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2 } );
  test.identical( got, linkPath2 );

  provider.fieldPop( 'usingTextLink', 0 );


  provider.fieldPush( 'usingTextLink', 1 );

  /* resolvingMultiple */

  test.case = 'single text link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink( linkPath, filePath );
  var got = provider.pathResolveTextLink({ filePath : linkPath, resolvingMultiple : 1 });
  test.identical( got, filePath );

  test.case = 'double text link';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink( linkPath2, filePath );
  provider.textLink( linkPath, linkPath2 );
  var got = provider.pathResolveTextLink({ filePath : linkPath, resolvingMultiple : 1 });
  test.identical( got, filePath );

  test.case = 'Chain with two textlinks and soft link to missing file';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.textLink({ dstPath : linkPath3, srcPath : linkPath2 });
  var got = provider.pathResolveTextLink( { filePath : linkPath3, resolvingMultiple : 1 } );
  test.identical( got, linkPath );

  test.case = 'Chain with two textlinks, last link is broken';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2, resolvingMultiple : 1 } );
  test.identical( got, filePath );

  test.case = 'Chain with two softlinks';
  provider.filesDelete( routinePath );
  provider.softLink({ dstPath : linkPath, srcPath : filePath, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath });
  var got = provider.pathResolveTextLink( { filePath : linkPath2, resolvingMultiple : 1 } );
  test.identical( got, linkPath2 );

  test.case = 'Chain with two relative textlinks';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : '../link' });
  var got = provider.pathResolveTextLink( { filePath : linkPath2, resolvingMultiple : 1 } );
  test.identical( got, filePath );

  test.case = 'Chain with relative and absolute textlinks';
  provider.filesDelete( routinePath );
  provider.textLink({ dstPath : linkPath, srcPath : '../file', allowingMissed : 1, makingDirectory : 1 });
  provider.textLink({ dstPath : linkPath2, srcPath : linkPath });
  provider.textLink({ dstPath : linkPath3, srcPath : '../link2' });
  var got = provider.pathResolveTextLink( { filePath : linkPath3, resolvingMultiple : 1 } );
  test.identical( got, filePath );

  /* resolvingIntermediateDirectories */

  test.case = 'two text links in path';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.textLink( linkPath, test.context.globalFromPreferred( '..' ) );
  provider.textLink( linkPath2, '../file' );
  var pathToResolve = provider.path.join( routinePath, 'link/link2' )
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  debugger
  var got = provider.pathResolveTextLink( o );
  test.identical( got, filePath );

  test.case = 'intermediate absolute text link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate absolute soft link to other directory';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.softLink( linkPath, dirPath );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, pathToResolve );

  test.case = 'intermediate chain of text links to other directory, resolvingMultiple off';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, dirPath );
  provider.textLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveTextLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of text links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, dirPath );
  provider.textLink( linkPath, linkPath2 );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, terminalInDirPath );

  test.case = 'intermediate chain of relative text links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, '../dir' );
  provider.textLink( linkPath, '../link2' );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 0 } );
  var got = provider.pathResolveTextLink( o );
  var expected = provider.path.join( linkPath2, 'terminal' );
  test.identical( got, expected );

  test.case = 'intermediate chain of relative text links to other directory, resolvingMultiple on';
  provider.filesDelete( routinePath );
  provider.fileWrite( terminalInDirPath, terminalInDirPath );
  provider.textLink( linkPath2, '../dir' );
  provider.textLink( linkPath, '../link2' );
  var pathToResolve = provider.path.join( linkPath, 'terminal' );
  var o = _.mapExtend( null, { filePath : pathToResolve, resolvingIntermediateDirectories : 1, resolvingMultiple : 1 } );
  var got = provider.pathResolveTextLink( o );
  test.identical( got, terminalInDirPath );

  provider.fieldPop( 'usingTextLink', 1 );

  /* */

  if( !Config.debug )
  return;

  test.case = 'Expects object input';
  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, testData );
  provider.textLink({ dstPath : linkPath, srcPath : filePath });
  test.mustNotThrowError( () => provider.pathResolveTextLink( linkPath ) );

  test.case = 'No arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( ) );

  test.case = 'Too many arguments';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : linkPath },  { filePath : linkPath } ) );

  test.case = 'No filePath option';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { otherPath : linkPath } ) );

  test.case = 'Only one allowingMissed option';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : linkPath, allowingMissed : 1 } ) );

  test.case = 'Wrong filePath options - undefined';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : undefined } ) );

  test.case = 'Wrong filePath options - number';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : 3.14159 } ) );

  test.case = 'Wrong filePath options - array';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : [ 0, 'a' ] } ) );

  test.case = 'Wrong filePath options - null';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : null } ) );

  test.case = 'Wrong filePath options - NaN';
  test.shouldThrowErrorOfAnyKind( () => provider.pathResolveTextLink( { filePath : NaN } ) );

}

//

function pathResolveLinkFullSpecial( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFull' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkFull/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkFull/link' );
  let linkPath2 = test.context.pathFor( 'written/pathResolveLinkFull/link2' );
  let linkPath3 = test.context.pathFor( 'written/pathResolveLinkFull/link3' );
  let terminalInDirPath = provider.path.join( routinePath, 'terminal' );
  let toDirPath = path.join( routinePath, 'toDir' );

  provider.fieldPush( 'usingTextLink', 1 );

  var o1 =
  {
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    allowingMissed : 1,
    resolvingHeadDirect : 0,
    resolvingHeadReverse : 0,
    throwing : 1
  }

  /* - */

  test.case = 'two soft links in path';
  provider.filesDelete( self.provider.path.dir( filePath ) );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, '..' );
  provider.softLink( linkPath2, '../file' );
  var o2 =
  {
    filePath : path.join( routinePath, 'link/link2' ),
    preservingRelative : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
  }
  var o = _.mapExtend( null, o1, o2 );
  var got = provider.pathResolveLinkFull( o ).relativePath;
  var expected = test.context.globalFromPreferred( '../file' );
  test.identical( got, expected );

  //

  test.case = 'cycled softLink, throwing on'
  provider.filesDelete( self.provider.path.dir( filePath ) );

  provider.softLink({ dstPath : linkPath, srcPath : linkPath2, allowingMissed : 1, makingDirectory : 1 });
  provider.softLink({ dstPath : linkPath2, srcPath : linkPath, allowingMissed : 1, makingDirectory : 1 });

  test.is( provider.isSoftLink( linkPath ) );
  test.is( provider.isSoftLink( linkPath2 ) );

  let files = provider.dirRead( routinePath );
  test.identical( files, [ 'link', 'link2' ] );

  var o =
  {
    filePath : linkPath,
    preservingRelative : 1,
    allowingCycled : 1,
    throwing : 1
  };
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, linkPath2, linkPath, null ] );
  test.identical( o.found, [ linkPath, linkPath2, linkPath, null ] );

  /* - */

  test.case = 'several absolute soft links in path';
  var dirPath = self.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile,pathToFile );
  provider.softLink( linkToDir1Path, dir1Path );
  provider.softLink( linkToTerminalPath, dirPath2 );
  provider.softLink( linkInDir2, pathToFile );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file
    path : 'dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o2 =
  {
    filePath : routinePath,
    preservingRelative : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
  }
  var o = _.mapExtend( null, o1, o2 );
  debugger;
  var got = provider.pathResolveLinkFull( o );
  debugger;
  test.identical( got.absolutePath, pathToFile );

  /* - */

  test.case = 'several absolute text links in path';
  var dirPath = self.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile,pathToFile );
  provider.textLink( linkToDir1Path, dir1Path );
  provider.textLink( linkToTerminalPath, dirPath2 );
  provider.textLink( linkInDir2, pathToFile );

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file
    path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o2 =
  {
    filePath : routinePath,
    preservingRelative : 1,
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
  }
  var o = _.mapExtend( null, o1, o2 );
  var got = provider.pathResolveLinkFull( o );
  test.is( !!provider.usingTextLink );
  test.identical( got.absolutePath, pathToFile );

  provider.fieldPop( 'usingTextLink', 1 );
}

//

function pathResolveLinkFullResult( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/pathResolveLinkFullResult' );
  let srcPath = test.context.pathFor( 'written/pathResolveLinkFullResult/file' );
  let src2Path = test.context.pathFor( 'written/pathResolveLinkFullResult/file2' );
  let dstPath = test.context.pathFor( 'written/pathResolveLinkFullResult/link' );

  var o =
  {
    resolvingHeadDirect : 1,
    resolvingHeadReverse : 1,
    preservingRelative : 0,
    relativeOriginalFile : 1,
    resolvingSoftLink : null,
    resolvingTextLink : null,
    throwing : 1,
    allowingMissed : 1,
    allowingCycled : 1
  }

  test.case = 'missing path';
  provider.filesDelete( routinePath );
  var o2 = { filePath : srcPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  var o2 = { filePath : srcPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  /* */

  test.open( 'soft links' );

  test.case = 'absolute soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, srcPath )
  var o2 = { filePath : dstPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, '../file' )
  var o2 = { filePath : dstPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, '../file' )
  var o2 = { filePath : dstPath, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( dstPath, '../file' )
  var o2 = { filePath : dstPath, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( src2Path,  srcPath )
  provider.softLink( dstPath,  src2Path )
  var o2 = { filePath : dstPath };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links, preservingRelative:1'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( src2Path,  '../file' )
  provider.softLink( dstPath,  '../file2' )
  var o2 = { filePath : dstPath, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of relative soft links, preservingRelative:0'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.softLink( src2Path,  '../file' )
  provider.softLink( dstPath,  '../file2' )
  var o2 = { filePath : dstPath, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.close( 'soft links' );

  /* */

  test.open( 'text links' );

  provider.fieldPush( 'usingTextLink', 1 );

  test.case = 'absolute text link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath, srcPath )
  var o2 = { filePath : dstPath, resolvingTextLink : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:1';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'relative soft link to terminal, preservingRelative:0';
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( src2Path,  srcPath )
  provider.textLink( dstPath,  src2Path )
  var o2 = { filePath : dstPath, resolvingTextLink : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, srcPath );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of absolute soft links, preservingRelative:1'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( src2Path,  test.context.globalFromPreferred( '../file' ) );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file2' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 1 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  test.case = 'chain of relative soft links, preservingRelative:0'
  provider.filesDelete( routinePath );
  provider.fileWrite( srcPath, srcPath );
  provider.textLink( src2Path,  test.context.globalFromPreferred( '../file' ) );
  provider.textLink( dstPath,  test.context.globalFromPreferred( '../file2' ) );
  var o2 = { filePath : dstPath, resolvingTextLink : 1, preservingRelative : 0 };
  var got = provider.pathResolveLinkFull( _.mapExtend( null, o, o2 ));
  test.identical( got.filePath, srcPath );
  test.identical( got.relativePath, test.context.globalFromPreferred( '../file' ) );
  test.identical( got.absolutePath, srcPath );

  provider.fieldPop( 'usingTextLink', 1 );

  test.close( 'text links' );
}

//

function pathNativize( t )
{
  let self = this;
  let provider = self.provider;

  if( !_.routineIs( provider.path.nativize ) )
  return;

  if( !( provider instanceof _.FileProvider.HardDrive ) )
  {
    t.description = 'nativize returns src'
    t.identical( 1, 1 )
    return;
  }

  if( Config.interpreter === 'njs' && process.platform === 'win32' )
  {
    t.description = 'path in win32 style ';

    /**/

    debugger
    var path = '/A/abc/';
    var got = provider.path.nativize( path );
    var expected = 'A:\\abc\\';
    t.identical( got, expected );

    /**/

    var path = '/A/';
    var got = provider.path.nativize( path );
    var expected = 'A:\\';
    t.identical( got, expected );

    /**/

    var path = '/A';
    var got = provider.path.nativize( path );
    // var expected = 'A:\\';
    var expected = 'A:';
    t.identical( got, expected );

    /**/

    var path = '/A/a';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a';
    t.identical( got, expected );

    /**/

    var path = 'A:/a';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a';
    t.identical( got, expected );

    /**/

    var path = '\\A\\a';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a';
    t.identical( got, expected );

    /**/

    var path = 'A';
    var got = provider.path.nativize( path );
    var expected = 'A';
    t.identical( got, expected );

    /**/

    var path = '/c/a';
    var got = provider.path.nativize( path );
    var expected = 'c:\\a';
    t.identical( got, expected );

    /**/

    var path = '/A/1.txt';
    var got = provider.path.nativize( path );
    var expected = 'A:\\1.txt';
    t.identical( got, expected );

    /**/

    var path = 'A:/a\\b/c\\d';
    var got = provider.path.nativize( path );
    var expected = 'A:\\a\\b\\c\\d';
    t.identical( got, expected );
  }

  //

  if( Config.debug )
  {
    t.description = 'path is not a string ';
    t.shouldThrowErrorSync( function()
    {
      provider.path.nativize( 1 );
    })
  }
}

// --
// experiment
// --

function fileCopyExperiment( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/fileCopyExperiment' );
  let srcPath = provider.path.join( routinePath, 'src' );
  let dstPath = provider.path.join( routinePath, 'dst' );

  /*

    src, dst - both are self soft links

    1. dstPath fails to resolve, dstStat is null, dstPath is not changed because allowingMissed is 1 by default
    2. verifyDst is called because fileExists check gives true
       verifyDst throws an error because does not expect to see dstStat as null in this case


    Expected behaviour :

    dstStat is created in verifyDst, stat from pathResolveLinkFull is not be used
    dstPath is be rewritten by soft link from srcPath

  */

  provider.filesDelete( routinePath );
  provider.dirMake( routinePath );
  provider.softLink({ dstPath : srcPath, srcPath : test.context.globalFromPreferred( '../src' ), allowingMissed : 1 });
  provider.softLink({ dstPath, srcPath : test.context.globalFromPreferred( '../dst' ), allowingMissed : 1 });
  var got = provider.fileCopy
  ({
      srcPath,
      dstPath,
      sync : 1,
      rewriting : 1,
      resolvingSrcSoftLink : 0,
      resolvingDstSoftLink : 1,
      allowingMissed : 0,
      throwing : 0
  });

  test.identical( got, true );
  test.identical( srcPath, srcPath );
  test.identical( dstPath, dstPath );
  test.is( provider.isSoftLink( srcPath ) );
  test.is( provider.isSoftLink( dstPath ) );
  test.identical( provider.pathResolveSoftLink( srcPath ), test.context.globalFromPreferred( '../src' ) );
  test.identical( provider.pathResolveSoftLink( dstPath ), test.context.globalFromPreferred( srcPath ) );

}

//

function statReadExperiment( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'written/statReadExperiment' );
  let srcPath = provider.path.join( routinePath, 'src' );

  test.shouldThrowErrorOfAnyKind( () =>
  {
    debugger
    provider.statRead({ filePath : srcPath, throwing : 1 });
    debugger;
  })

  //

  var got = provider.statRead({ filePath : srcPath, throwing : 0 });
  test.identical( got, null );

}

//

function experiment( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;

  let routinePath = test.context.pathFor( 'experiment' );
  let filePath = test.context.pathFor( 'experiment/file' );
  let linkPath = test.context.pathFor( 'experiment/link' );
  let linkPath2 = test.context.pathFor( 'experiment/link2' );
  let linkPath3 = test.context.pathFor( 'experiment/link3' );

  var o1 =
  {
    resolvingSoftLink : 1,
    resolvingTextLink : 1,
    allowingMissed : 1,
    resolvingHeadDirect : 0,
    resolvingHeadReverse : 0,
    throwing : 1
  }

  /* - */

  // test.case = 'several relative soft links in path, simpliefied';
  // var dirPath = self.provider.path.dir( filePath );
  // // var dir1Path = path.join( dirPath, 'dir1' );
  // var dirPath2 = path.join( dirPath, 'dir2' );
  // var pathToFile = path.join( dirPath, 'file' );
  // var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  // // var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  // var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  // provider.filesDelete( dirPath );
  // provider.dirMake( dirPath );
  // // provider.dirMake( dir1Path );
  // provider.dirMake( dirPath2 );
  // provider.fileWrite( pathToFile,pathToFile );
  // provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dirPath2 ) );
  // // provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  // provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );
  //
  // /*
  //   dir :
  //     // dir1 :
  //     //   linkToDir2
  //     dir2 :
  //       linkToTerminal
  //     linkToDir2
  //     file
  //
  //   path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  // */
  //
  // var routinePath = path.join( dirPath, 'linkToDir1/linkToTerminal' )
  // var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 1 } );
  // debugger;
  // var got = provider.pathResolveLinkFull( o );
  // debugger;
  // test.identical( got.absolutePath, pathToFile );

  // debugger; return; xxx

  /* - */

  test.case = 'several relative soft links in path, complicated';
  var dirPath = self.provider.path.dir( filePath );
  var dir1Path = path.join( dirPath, 'dir1' );
  var dirPath2 = path.join( dirPath, 'dir2' );
  var pathToFile = path.join( dirPath, 'file' );
  var linkToDir1Path = path.join( dirPath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToDir2' );
  var linkInDir2 = path.join( dirPath2, 'linkToTerminal' );
  provider.filesDelete( dirPath );
  provider.dirMake( dirPath );
  provider.dirMake( dir1Path );
  provider.dirMake( dirPath2 );
  provider.fileWrite( pathToFile, pathToFile );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, dirPath2 ) );
  provider.softLink( linkInDir2, provider.path.relative( linkInDir2, pathToFile ) );

  routinePath = path.join( dirPath, 'linkToDir1/linkToDir2/linkToTerminal' )
  var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 1 } );
  var got = provider.pathResolveLinkFull( o ).relativePath;
  var expected = provider.path.relative( linkInDir2, pathToFile );
  test.identical( got, expected );

  debugger; return; xxx

  /*
    dir :
      dir1 :
        linkToDir2
      dir2 :
        linkToTerminal
      linkToDir1
      file

    path : '/dir/linkToDir1/linkToDir2/linkToTerminal' -> 'dir/file'
  */

/*

/experiment/linkToDir1/linkToDir2/linkToTerminal
lrwxrwxrwx 1 kos 197121 9 Dec 11 16:22 /experiment/linkToDir1/linkToDir2/linkToTerminal -> ./../file

/experiment/linkToDir1/linkToDir2
lrwxrwxrwx 1 kos 197121 9 Dec 11 16:22 /experiment/linkToDir1/linkToDir2 -> ./../dir2

/experiment/linkToDir1
lrwxrwxrwx 1 kos 197121 6 Dec 11 16:22 /experiment/linkToDir1 -> ./dir1

/experiment
total 1
drwxr-xr-x 1 kos 197121   0 Dec 11 16:22 .
drwxr-xr-x 1 kos 197121   0 Dec 11 16:22 ..
drwxr-xr-x 1 kos 197121   0 Dec 11 16:22 dir1
drwxr-xr-x 1 kos 197121   0 Dec 11 16:22 dir2
-rw-r--r-- 1 kos 197121 129 Dec 11 16:22 file
lrwxrwxrwx 1 kos 197121   6 Dec 11 16:22 linkToDir1 -> ./dir1

/experiment/dir1
total 0
drwxr-xr-x 1 kos 197121 0 Dec 11 16:22 .
drwxr-xr-x 1 kos 197121 0 Dec 11 16:22 ..
lrwxrwxrwx 1 kos 197121 9 Dec 11 16:22 linkToDir2 -> ./../dir2

/experiment/dir2
total 0
drwxr-xr-x 1 kos 197121 0 Dec 11 16:22 .
drwxr-xr-x 1 kos 197121 0 Dec 11 16:22 ..
lrwxrwxrwx 1 kos 197121 9 Dec 11 16:22 linkToTerminal -> ./../file

/experiment/linkToDir1/file
No such file or directory

/experiment/linkToDir1
experiment/linkToDir1 -> ./dir1

/experiment/linkToDir1
experiment/linkToDir2

*/

  /* - */

  test.case = 'works only for extract';
  var basePath = self.provider.path.dir( filePath );
  var dir1Path = path.join( basePath, 'dir1a/dir1b' );
  var terminalPath = path.join( basePath, 'terminal' );
  var linkToDir1Path = path.join( basePath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToTerminal' );

  console.log( 'basePath', basePath );

  provider.filesDelete( basePath );
  provider.dirMake( basePath );
  provider.dirMake( dir1Path );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink( linkToTerminalPath, provider.path.relative( linkToTerminalPath, terminalPath ) );

  routinePath = path.join( basePath, 'linkToDir1/linkToTerminal' )
  var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 1 } );
  var got = provider.pathResolveLinkFull( o );
  test.identical( got, terminalPath );

  /* - */

  // test.case = 'works only for hd, but not';
  test.case = 'works only for both';
  var basePath = self.provider.path.dir( filePath );
  var dir1Path = path.join( basePath, 'dir1a/dir1b' );
  var terminalPath = path.join( basePath, 'terminal' );
  var linkToDir1Path = path.join( basePath, 'linkToDir1' );
  var linkToTerminalPath = path.join( dir1Path, 'linkToTerminal' );

  console.log( 'basePath', basePath );

  provider.filesDelete( basePath );
  provider.dirMake( basePath );
  provider.dirMake( dir1Path );
  provider.fileWrite( terminalPath, terminalPath );
  provider.softLink( linkToDir1Path, provider.path.relative( linkToDir1Path, dir1Path ) );
  provider.softLink({ dstPath : linkToTerminalPath, srcPath : provider.path.relative( /* basePath */linkToTerminalPath, terminalPath ), allowingMissed : 1 });

  routinePath = path.join( basePath, 'linkToDir1/linkToTerminal' )
  var o = _.mapExtend( null, o1, { filePath : routinePath, preservingRelative : 1, resolvingHeadDirect : 1, resolvingHeadReverse : 1 } );
  var got = provider.pathResolveLinkFull( o );
  test.identical( got, terminalPath );

}

//

function experiment2( test )
{
  let self = this;
  let provider = self.provider;
  let path = provider.path;
  let routinePath = test.context.pathFor( 'written/pathResolveLinkTailChain' );
  let filePath = test.context.pathFor( 'written/pathResolveLinkTailChain/file' );
  let linkPath = test.context.pathFor( 'written/pathResolveLinkTailChain/link' );

  provider.filesDelete( routinePath );
  provider.fileWrite( filePath, filePath );
  provider.softLink( linkPath, filePath );

  var o =
  {
    filePath : linkPath,
    resolvingSoftLink : 1,
  }
  provider.pathResolveLinkTailChain( o );
  test.identical( o.result, [ linkPath, filePath ] );
  test.identical( o.found, [ linkPath, filePath ] );
}

//

function hardLinkExperiment( test )
{
  let self = this;
  let provider = self.provider;
  let routinePath = test.context.pathFor( 'hardLinkExperiment' );
  let terminalPath = test.context.pathFor( 'hardLinkExperiment/terminal' );
  let linkPath = test.context.pathFor( 'hardLinkExperiment/hardLink' );

  if( self.providerIsInstanceOf( _.FileProvider.HardDrive ) )
  {
    test.identical( 1, 1 );
    return;
  }

  provider.filesDelete( routinePath );
  provider.fileWrite( terminalPath, terminalPath );
  provider.hardLink( linkPath, terminalPath );
  debugger;
  var statTerminal = provider.statRead( terminalPath );
  var statLink = provider.statRead( linkPath );
  debugger;
  test.identical( statTerminal.ino, statLink.ino );
  debugger;
  var got = _.statsAreHardLinked( statTerminal, statLink );
  test.identical( got, _.maybe );
  var got = provider.filesAreHardLinked([ linkPath, terminalPath ]);
  test.identical( got, true );

}

//

function EncodersGenerate( test )
{
  let self = this;
  let provider = self.provider;
  let writeConverters = _.Gdf.InMap[ 'structure' ];
  let readConverters = _.Gdf.OutMap[ 'structure' ];

  //

  test.case = 'check if all write encoders are generated';
  _checkEncoders( _.FileWriteEncoders, writeConverters );

  //

  test.case = 'check if all read encoders are generated';
  _checkEncoders( _.FileReadEncoders, readConverters );

  //

  test.case = 'add and remove write converter';

  test.will = 'encoder and converter should not exist';
  test.is( !_.FileWriteEncoders[ 'testEncoder' ] );
  test.is( !_.Gdf.ExtMap[ 'testEncoder' ] || !_.Gdf.ExtMap[ 'testEncoder' ].length );
  var testConverter =
  {
    ext : [ 'testEncoder' ],
    in : [ 'structure' ],
    out : [ 'string' ],

    onEncode : function( op )
    {
      op.out.data = _.toStr( op.out.data, { levels : 99 } );
      op.out.format = 'string';
    }
  }
  var converter = _.Gdf([ testConverter ])[ 0 ];

  test.will = 'encoder should not exist';
  test.is( !_.FileWriteEncoders[ 'testEncoder' ] );

  test.will = 'update encoders, encoder should exist';
  provider.EncodersGenerate();
  var encoder = _.FileWriteEncoders[ 'testEncoder' ];
  test.is( _.mapIs( encoder ) );
  test.identical( encoder.exts, converter.ext );
  test.identical( encoder.converter, converter );

  test.will = 'finit converter, encoder should exist';
  converter.finit();
  test.is( _.mapIs( _.FileWriteEncoders[ 'testEncoder' ] ) );
  provider.EncodersGenerate();
  test.will = 'update encoders, encoder should not exist';
  test.is( !_.FileWriteEncoders[ 'testEncoder' ] );

  //

  test.case = 'adjust converter exts'
  var testConverter =
  {
    ext : [ 'testEncoder' ],
    in : [ 'structure' ],
    out : [ 'string' ],

    onEncode : function( op )
    {
      op.out.data = _.toStr( op.out.data, { levels : 99 } );
      op.out.format = 'string';
    }
  }
  var converter = _.Gdf([ testConverter ])[ 0 ];
  var ext = 'testExt';
  let originalExt = converter.ext.slice();
  converter.ext = [ ext ];
  test.is( !_.mapIs( _.FileWriteEncoders[ ext ] ) );
  provider.EncodersGenerate();
  var encoder = _.FileWriteEncoders[ ext ];
  test.is( _.mapIs( encoder ) );
  test.identical( encoder.exts, converter.ext );
  test.identical( encoder.converter, converter );
  converter.ext = originalExt.slice();
  converter.finit();
  provider.EncodersGenerate();
  test.is( !_.mapIs( _.FileWriteEncoders[ ext ] ) );

  /* - */

  function _checkEncoders( encoders, converters )
  {
    _.each( converters, ( converter ) =>
    {
      _.each( converter.ext, ( ext ) =>
      {
        if( encoders[ ext ].converter.default )
        {
          test.will = 'Expects only one default converter for encoder: ' + ext;
          let defaultConverter = _.Gdf.ExtMap[ ext ].filter( ( c ) => !!c.default )
          test.identical( defaultConverter.length, 1 );

          test.will = ext + ' encoder should exist';
          test.is( _.mapIs( encoders[ ext ] ) );
          test.will = ext + ' encoder should use default converter: ' + defaultConverter[ 0 ].name;
          test.is( encoders[ ext ].converter === defaultConverter[ 0 ] );
        }
        else
        {
          test.will = ext + ' encoder should exist';
          test.is( _.mapIs( encoders[ ext ] ) );
          test.will = ext + ' encoder should exist and use converter: ' + converter.name;
          test.is( encoders[ ext ].converter === converter );
        }

        test.will = ext + ' encoder should have onBegin/onEnd or both';

        if( _.FileWriteEncoders[ ext ] )
        {
          test.is( _.routineIs( encoders[ ext ].onBegin ) );
        }
        else
        {
          test.is( _.routineIs( encoders[ ext ].onBegin ) );
          test.is( _.routineIs( encoders[ ext ].onEnd ) );
        }

        test.will = ext + ' encoder should have exts arrays';
        test.is( _.arrayIs( encoders[ ext ].exts ) )
      })
    })
  }
}

// --
// declare
// --

var Self =
{

  name : 'Tools.mid.files.fileProvider.Abstract',
  abstract : 1,
  silencing : 1,
  // verbosity : 7,

  onSuiteBegin,
  onSuiteEnd,
  onRoutineEnd,

  context :
  {
    pathFor,
    providerIsInstanceOf,
    softLinkIsSupported,
    suitePath : null,
    system : null,
    // shouldWriteOnlyOnce
  },

  tests :
  {

    //testDelaySample,
    mustNotThrowError,

    readWriteSync,
    readWriteAsync,

    fileReadJson,
    fileWriteJson,

    fileReadWithEncoding,
    fileWriteWithEncoding,

    fileTouch,
    fileTimeSet,

    writeAsyncThrowingError,

    //qqq: extend linking routines with cases using resolvingSrcSoftLink:2 and resolvingSrcTextLink:0-2

    fileCopyActSync,
    fileCopySync,
    fileCopyRelativePath,
    fileCopyLinksSync,
    fileCopyAsync,
    fileCopyLinksAsync,
    fileCopySoftLinkResolving,
    fileCopyAsyncThrowingError,
    fileCopyLinks,
    fileCopyError,
    fileCopySoftLinkExtended,
    fileCopySoftLinkBasic, //qqq: extend test routine for resolvingSrcTextLink:0-2
    fileCopyGlobal,
    fileCopyRelativeLinking,//qqq: extend test routine for resolvingSrcTextLink:0-2

    fileRenameSync,
    fileRenameRelativePath,
    fileRenameAsync,
    fileRenameActSync,
    fileRenameSync2,
    fileRenameSoftLinkResolving,
    fileRenameSoftLinkBasic, //qqq: extend test routine for resolvingSrcTextLink:0-2
    fileRenameGlobal,
    fileRenameRelativeLinking,//qqq: extend test routine for resolvingSrcTextLink:0-2

    fileDeleteSync,
    fileDeleteActSync,
    fileDeleteAsync,
    fileDeleteLocked,
    fileDeletePerfomance,

    statResolvedReadSync,
    statReadActSync,
    statResolvedReadAsync,
    statReadActLinkedHead,

    dirMakeSync,
    dirMakeLinksSync,
    dirMakeAsync,

    hashReadSync,
    hashReadAsync,

    dirReadSync,
    dirReadSyncOutputFormats,
    dirReadAsync,

    fileWriteSync,
    fileWriteLinksSync,
    fileWriteAsync,
    fileWriteLinksAsync,

    fileReadAsync,

    softLinkSync,
    softLinkAsync,
    softLinkRelativePath,
    softLinkChain,
    softLinkActSync,
    softLinkSoftLinkResolving,
    softLinkRelativeLinkResolving,
    softLinkMakeAndResolve,
    softLinkSoftLinkBasic,//qqq: extend test routine for resolvingSrcTextLink:0-2
    softLinkGlobal,
    softLinkRelativeLinking,//qqq: extend test routine for resolvingSrcTextLink:0-2

    textLinkSync,
    textLinkSoftLinkBasic,//qqq: extend test routine for resolvingSrcTextLink:0-2
    textLinkGlobal,
    textLinkRelativeLinking,//qqq: extend test routine for resolvingSrcTextLink:0-2

    hardLinkSync,
    hardLinkMultipleSync,
    hardLinkRelativePath,
    // hardLinkExperiment,
    hardLinkSoftlinked,
    hardLinkActSync,
    hardLinkAsync,
    hardLinkActAsync,
    hardLinkSoftLinkResolving,
    hardLinkHardLinkBreaking,
    hardLinkSoftLinkBasic,//qqq: extend test routine for resolvingSrcTextLink:0-2
    hardLinkGlobal,
    hardLinkRelativeLinking,//qqq: extend test routine for resolvingSrcTextLink:0-2

    fileExchangeSync,
    fileExchangeAsync,

    //etc

    // hardLinkSyncRunner,
    // hardLinkAsyncRunner,

    isDir,
    dirIsEmpty,

    isTerminal,
    isSoftLink,
    isTextLink,
    isHardLink,
    isLink,

    filesAreHardLinked,
    filesAreTextLinked,
    filesAreSoftLinked,
    filesAreSame,

    statsAreHardLinked,

    filesSize,
    fileSize,

    fileExists,
    fileExistsCompliantBehavior,

    // record

    record,

    // path

    localsFromGlobals,
    globalsFromLocals,

    pathResolve,
    uriResolve,

    linkingCriticalCases,
    pathResolveLinkTailChain,
    pathResolveLinkFull,
    pathResolveSoftLink,
    pathResolveTextLink,
    pathResolveLinkFullSpecial,
    pathResolveLinkFullResult,

    pathNativize,

    // experiment

    fileCopyExperiment,
    statReadExperiment,
    experiment,
    experiment2,
    hardLinkExperiment,

    //static

    EncodersGenerate,

  },

};

wTestSuite( Self );

})();
