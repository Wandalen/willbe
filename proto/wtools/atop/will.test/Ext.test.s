( function _WillExternals_test_s_()
{

'use strict';


if( typeof module !== 'undefined' )
{
  const _ = require( '../../../node_modules/Tools' );

  _.include( 'wTesting' );;
  _.include( 'wProcess' );
  _.include( 'wFiles' );

  require( '../will/include/Top.s' );
}

/* Desirable :

- Test check line is short. Use variables to reach that.

    var outfile = _.fileProvider.fileReadUnknown( a.abs( 'out/exportRewritesOutFile.out.will.yml' ) );
    var exp = [ 'disabled.out', '../', '../.module/Tools/', '../.module/Tools/out/wTools.out', '../.module/PathBasic/', '../.module/PathBasic/out/wPathBasic.out' ];
    var got = _.props.keys( outfile.module );
    test.identical( got, exp );

- Name return of _.process.start "op".

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    return op;
  })

- Use routine assetFor to setup environment for a test routine.

function exportCourruptedSubmodulesDisabled( test )
{
  let context = this;
  let a = context.assetFor( test, 'corruptedSubmodulesDisabled' );
  let outPath = a.abs( 'super.out' );
  ...

*/

/*
qqq : fix npm submodules tests
*/

const _global = _global_;
const _ = _global_.wTools;

// --
// context
// --

function onSuiteBegin()
{
  let context = this;
  context.suiteTempPath = _.path.tempOpen( _.path.join( __dirname, '../..' ), 'willbe' );
  context.assetsOriginalPath = _.path.join( __dirname, '_asset' );
  context.repoDirPath = _.path.join( context.assetsOriginalPath, '-repo' );
  context.appJsPath = _.path.nativize( _.Will.WillPathGet() );
  let reposDownload = require( './ReposDownload.s' );
  return reposDownload().then( () =>
  {
    _.assert( _.fileProvider.isDir( _.path.join( context.repoDirPath, 'ModuleForTesting1' ) ) );
    return null;
  })
}

//

function onSuiteEnd()
{
  let context = this;
  _.assert( _.strHas( context.suiteTempPath, '/willbe-' ) )
  _.path.tempClose( context.suiteTempPath );
}

//

function onRoutineEnd( test )
{
  const context = this;
  const routineTempPath = _.fileProvider.path.join( context.suiteTempPath, test.routine.name );
  _.fileProvider.filesDelete( routineTempPath );
  _.assert( !_.fileProvider.fileExists( routineTempPath ) );
}

//

function assetFor( test, name )
{
  let context = this;

  if( !name )
  name = test.name;

  let a = test.assetFor( name );

  a.will = new _.Will;

  a.find = a.fileProvider.filesFinder
  ({
    withTerminals : 1,
    withDirs : 1,
    withStem : 1,
    allowingMissed : 1,
    maskPreset : 0,
    outputFormat : 'relative',
    filter :
    {
      recursive : 2,
      maskAll :
      {
        excludeAny : [ /(^|\/)\.git($|\/)/, /(^|\/)\+/ ],
      },
      maskTransientAll :
      {
        excludeAny : [ /(^|\/)\.git($|\/)/, /(^|\/)\+/ ],
      },
    },
  });

  a.findNoModules = a.fileProvider.filesFinder
  ({
    withTerminals : 1,
    withDirs : 1,
    withStem : 1,
    allowingMissed : 1,
    maskPreset : 0,
    outputFormat : 'relative',
    filter :
    {
      recursive : 2,
      maskAll :
      {
        excludeAny : [ /(^|\/)\.git($|\/)/, /(^|\/)\+/, /(^|\/)\.module\/.*/ ],
      },
      maskTransientAll :
      {
        excludeAny : [ /(^|\/)\.git($|\/)/, /(^|\/)\+/, /(^|\/)\.module\/.*/ ],
      },
    },
  });

  a.reflect = function reflect()
  {
    a.fileProvider.filesDelete( a.routinePath );
    a.fileProvider.filesReflect({ reflectMap : { [ a.originalAssetPath ] : a.routinePath } });
    try
    {
      a.fileProvider.filesReflect({ reflectMap : { [ context.repoDirPath ] : a.abs( context.suiteTempPath, '-repo' ) } });
    }
    catch( err )
    {
      _.errAttend( err );
      /* Dmytro : temporary, clean -repo directory before copying files, prevents fails in *nix systems */
      _.take( null )
      .delay( 3000 )
      .deasync();
      a.fileProvider.filesDelete( a.abs( context.suiteTempPath, '-repo' ) );
      a.fileProvider.filesReflect({ reflectMap : { [ context.repoDirPath ] : a.abs( context.suiteTempPath, '-repo' ) } });
    }
    return null
  }

  /* aaa : for Dmytro : ? */ /* Dmytro : this method reduces running time of single test routine that needs no local testing submodules in 3-4 times */
  a.reflectMinimal = function reflectMinimal()
  {
    a.fileProvider.filesDelete( a.routinePath );
    a.fileProvider.filesReflect({ reflectMap : { [ a.originalAssetPath ] : a.routinePath } });
    return null;
  }

  _.assert( a.fileProvider.isDir( a.originalAssetPath ) );

  return a;
}

// --
// tests
// --

function etcPreCloneRepos( test )
{
  let context = this;
  let a = context.assetFor( test, '-repo' );

  a.ready.then( () =>
  {
    test.true( a.fileProvider.isDir( a.abs( context.repoDirPath, 'ModuleForTesting1' ) ) );
    return null;
  })

  return a.ready;
}

//

function etcSingleModuleWithSpaceTrivial( test )
{
  let context = this;
  let a = context.assetFor( test, 'single with space' );
  a.fileProvider.filesReflect({ reflectMap : { [ a.originalAssetPath ] : a.abs( 'single with space' ) } });

  a.appStart({ execPath : '.with "single with space/" .resources.list' })

  .then( ( op ) =>
  {
    test.case = '.with "single with space/" .resources.list';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `name : 'single with space'` ) );
    test.true( _.strHas( op.output, `description : 'Module for testing'` ) );
    test.true( _.strHas( op.output, `version : '0.0.1'` ) );
    return null;
  })

  return a.ready;
}

//

function etcWillFilterFieldsOverwrite( test )
{
  let context = this;
  let a = context.assetFor( test, 'willFilterFieldsOverwrite' );
  a.reflect();

  /* - */

  a.appStart( '.clean.submodules ; .submodules.update recursive:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated / ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( modules, [ 'ModuleForTesting3' ] );
    return null;
  });

  /* - */

  return a.ready;
}

etcWillFilterFieldsOverwrite.rapidity = 1;
etcWillFilterFieldsOverwrite.description =

`
Filter fields overwrite problem:
Command can modify filter fields of main( will ). It can break behavior of other commands that may be executed in the sequence.
This test runs two commands with different filtering options in the sequence to check if problem is fixed.
`

//

function etcOldImportFileAdapt( test )
{
  let context = this;
  let a = context.assetFor( test, 'oldImportFileAdapt' );
  a.reflectMinimal();

  /* - */

  a.appStartNonThrowing( '.imply willFileAdapting:0 .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Failed to download submodules' ) );
    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( modules, null );
    return null;
  });

  /* */

  a.appStart( '.imply willFileAdapting:1 .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /\+ 4\/4 submodule\(s\) of module::.* were downloaded in/ ), 1 );

    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    let expectedModules =
    [
      'ModuleForTesting1',
      'ModuleForTesting1a',
      'ModuleForTesting1b',
      'ModuleForTesting2'
    ];
    test.identical( modules, expectedModules );

    _.each( expectedModules, ( moduleName ) =>
    {
      test.true( _.git.isRepository({ localPath : a.abs( `.module/${moduleName}` ) }) );
    });

    return null;
  });

  /* - */

  return a.ready;
}

etcOldImportFileAdapt.rapidity = 1;
etcOldImportFileAdapt.description =
`
  Checks if old format of import file is converted to new format if feature is enabled via option.
`;

//

/*
  etcRunWillbe checks if willbe can be terminated on early start from terminal when executed as child process using ExecUnrestricted script
*/

function etcRunWillbe( test )
{

  let context = this;
  let a = context.assetFor( test, 'runWillbe' );

  a.fork = _.process.starter
  ({
    // execPath : 'node',
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    ready : a.ready,
    mode : 'fork',
  });
  a.appStart = _.process.starter
  ({
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    ready : a.ready,
    mode : 'shell',
  });

  /* - */

  a.ready
  .then( () =>
  {
    a.reflect();
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'execUnrestricted: terminate utility during heavy load of will files, should be terminated';
    let o = { args : [ a.path.nativize( a.abs( __dirname, '../will/ExecUnrestricted' ) ), '.submodules.list' ], ready : null };

    let con = a.fork( o );

    o.pnd.stdout.on( 'data', ( data ) =>
    {
      if( _.bufferAnyIs( data ) )
      data = _.bufferToStr( data );
      if( _.strHas( data, 'wTools.out.will.yml' ) )
      {
        console.log( 'Terminating willbe...' );
        o.pnd.kill( 'SIGINT' )
        // o.pnd.stdin.write( '\x03\n' ); /* CTRL+C */
        // o.pnd.stdin.write( '~^C\n' ); /* CTRL+C */
      }
    });

    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      if( process.platform === 'win32' )
      test.identical( o.exitCode, null );
      else
      test.identical( o.exitCode, 255 );
      test.identical( o.exitSignal, 'SIGINT' );
      test.true( _.strHas( o.output, 'wTools.out.will.yml' ) );
      test.true( !_.strHas( o.output, 'wLogger.out.will.yml' ) );
      test.true( !_.strHas( o.output, 'wLoggerToJs.out.will.yml' ) );
      test.true( !_.strHas( o.output, 'wConsequence.out.will.yml' ) );
      test.true( !_.strHas( o.output, 'wInstancing.out.will.yml' ) );

      return null;
    })
  })

  /* */

  .then( () =>
  {
    test.case = 'Exec: terminate utility during heavy load of will files, should fail'
    let o = { execPath : 'node', args : [ execPath, '.submodules.list' ], ready : null };
    let con = a.appStart( o );

    o.pnd.stdout.on( 'data', ( data ) =>
    {
      if( _.bufferAnyIs( data ) )
      data = _.bufferToStr( data );
      if( _.strHas( data, 'wTools.out.will.yml' ) )
      {
        console.log( 'Terminating willbe...' );
        // o.pnd.kill( 'SIGTERM' );
        // o.pnd.kill( 'SIGINT' );
        o.pnd.kill( 'SIGINT' );
        // o.pnd.kill( 'SIGKILL' );
      }
    });

    return test.shouldThrowErrorAsync( con )
    .then( () =>
    {
      if( process.platform === 'win32' )
      test.identical( o.exitCode, null );
      else
      test.identical( o.exitCode, 255 );
      test.identical( o.exitSignal, 'SIGINT' );
      test.true( _.strHas( o.output, 'module::runWillbe / submodule::Tools' ) );
      test.true( _.strHas( o.output, 'module::runWillbe / submodule::Logger' ) );
      test.true( _.strHas( o.output, 'module::runWillbe / submodule::LoggerToJs' ) );
      return null;
    });

  });

  /* - */

  return a.ready;
}

//

function etcKillWillbe( test )
{
  const context = this;
  const a = context.assetFor( test, 'eachList' );
  a.reflectMinimal();
  const con = _.take( null );
  const delay = 2100;

  /* */

  con.then( () =>
  {
    test.case = 'kill willbe without signal';
    var o =
    {
      execPath : _.Will.WillPathGet() + ' .with ./* .paths.list',
      currentPath : a.routinePath,
      outputCollecting : 1,
      throwingExitCode : 0,
      outputGraying : 1,
      ready : a.ready,
      mode : 'fork',
    };
    var result = _.process.start( o );
    o.pnd.stdout.on( 'data', ( data ) =>
    {
      console.log( 'Terminating willbe... SIGTERM' );
      _.time.out( delay, () => o.pnd.kill() );
    });

    return a.ready.then( ( op ) =>
    {
      test.notIdentical( op.exitCode, 0 );
      test.identical( op.exitReason, 'signal' );
      test.identical( op.exitSignal, 'SIGTERM' );

      test.identical( _.strCount( op.output, 'Command ".with ./* .paths.list"' ), 1 );
      test.ge( _.strCount( op.output, '. Opened .' ), 1 );
      test.le( _.strCount( op.output, '. Opened .' ), 7 );
      test.ge( _.strCount( op.output, '. Read 6 willfile(s)' ), 0 );
      if( !process.platform === 'win32' )
      test.ge( _.strCount( op.output, 'SIGTERM' ), 1 );

      return null;
    });
  });

  /* */

  con.then( () =>
  {
    test.case = 'kill willbe with signal SIGTERM';
    var o =
    {
      execPath : _.Will.WillPathGet() + ' .with ./* .paths.list',
      currentPath : a.routinePath,
      outputCollecting : 1,
      throwingExitCode : 0,
      outputGraying : 1,
      ready : a.ready,
      mode : 'fork',
    };
    var result = _.process.start( o );
    o.pnd.stdout.on( 'data', ( data ) =>
    {
      console.log( 'Terminating willbe... SIGTERM' );
      _.time.out( delay, () => o.pnd.kill( 'SIGTERM') );
    });

    return a.ready.then( ( op ) =>
    {
      test.notIdentical( op.exitCode, 0 );
      test.identical( op.exitReason, 'signal' );
      test.identical( op.exitSignal, 'SIGTERM' );

      test.identical( _.strCount( op.output, 'Command ".with ./* .paths.list"' ), 1 );
      test.ge( _.strCount( op.output, '. Opened .' ), 2 );
      test.ge( _.strCount( op.output, '. Read 6 willfile(s)' ), 0 );
      if( !process.platform === 'win32' )
      test.ge( _.strCount( op.output, 'SIGTERM' ), 1 );

      return null;
    });
  });

  /* */

  con.then( () =>
  {
    test.case = 'kill willbe with signal SIGKILL';
    var o =
    {
      execPath : _.Will.WillPathGet() + ' .with ./* .paths.list',
      currentPath : a.routinePath,
      outputCollecting : 1,
      throwingExitCode : 0,
      outputGraying : 1,
      ready : a.ready,
      mode : 'fork',
    };
    var result = _.process.start( o );
    o.pnd.stdout.on( 'data', ( data ) =>
    {
      console.log( 'Terminating willbe... SIGKILL' );
      o.pnd.kill( 'SIGKILL' );
    });

    return a.ready.then( ( op ) =>
    {
      test.notIdentical( op.exitCode, 0 );
      test.identical( op.exitReason, 'signal' );
      test.identical( op.exitSignal, 'SIGKILL' );

      test.identical( _.strCount( op.output, 'Command ".with ./* .paths.list"' ), 1 );
      test.identical( _.strCount( op.output, '. Opened .' ), 0 );
      test.identical( _.strCount( op.output, '. Read 6 willfile(s)' ), 0 );
      if( !process.platform === 'win32' )
      test.ge( _.strCount( op.output, 'SIGKILL' ), 1 );

      return null;
    });
  });

  /* */

  con.then( () =>
  {
    test.case = 'kill willbe with signal SIGINT';
    var o =
    {
      execPath : _.Will.WillPathGet() + ' .with ./* .paths.list',
      currentPath : a.routinePath,
      outputCollecting : 1,
      throwingExitCode : 0,
      outputGraying : 1,
      ready : a.ready,
      mode : 'fork',
    };
    var result = _.process.start( o );
    o.pnd.stdout.on( 'data', ( data ) =>
    {
      console.log( 'Terminating willbe... SIGINT' );
      _.time.out( delay, () => o.pnd.kill( 'SIGINT' ) );
    });

    return a.ready.then( ( op ) =>
    {
      test.notIdentical( op.exitCode, 0 );
      test.identical( op.exitReason, 'signal' );
      test.identical( op.exitSignal, 'SIGINT' );

      test.identical( _.strCount( op.output, 'Command ".with ./* .paths.list"' ), 1 );
      test.ge( _.strCount( op.output, '. Opened .' ), 2 );
      test.ge( _.strCount( op.output, '. Read 6 willfile(s)' ), 0 );
      if( !process.platform === 'win32' )
      test.ge( _.strCount( op.output, 'SIGINT' ), 1 );

      return null;
    });
  });

  /* - */

  return con;
}

//

function etcRunDebugWill( test )
{
  let context = this;
  let a = context.assetFor( test, 'simple' );
  let con = _.take( null );
  a.reflect();

  /* */

  con.then( () =>
  {
    test.case = 'debug-will .help';

    var debugWillPath = a.abs( a.path.dir( _.Will.WillPathGet() ), 'ExecDebug' );
    var o =
    {
      execPath : debugWillPath + ' .help',
      currentPath : a.routinePath,
      outputCollecting : 1,
      throwingExitCode : 0,
      outputGraying : 1,
      ready : a.ready,
      mode : 'fork',
    };
    _.process.start( o );

    return a.ready.then( ( op ) =>
    {
      if( op.exitCode === 0 )
      {
        test.description = 'utility debugnode exists';
        // test.identical( _.strCount( op.output, 'debugnode/node_modules/electron/dist/electron --no-sandbox' ), 1 );
        // test.identical( _.strCount( op.output, 'debugnode/proto/wtools/atop/nodeWithDebug/browser/electron/ElectronProcess.ss' ), 1 );
        test.identical( _.strCount( op.output, 'Command ".help"' ), 1 );
        test.identical( _.strCount( op.output, '.help - Get help.' ), 1 );
        test.identical( _.strCount( op.output, '.imply - Change state or imply value of a variable.' ), 1 );
      }
      else
      {
        test.description = 'utility debugnode not exists';
        test.identical( _.strCount( op.output, 'spawn debugnode ENOENT' ), 1 );
        test.identical( _.strCount( op.output, 'code : \'ENOENT\'' ), 1 );
        test.identical( _.strCount( op.output, 'syscall : \'spawn debugnode\'' ), 1 );
        test.identical( _.strCount( op.output, 'path : \'debugnode\'' ), 1 );
        test.identical( _.strCount( op.output, 'spawnargs' ), 1 );
        test.identical( _.strCount( op.output, 'Error starting the process' ), 1 );
      }
      return null;
    });
  });

  return con;
}

etcRunDebugWill.experimental = 1;

//

/*

Performance issue. Related with
- path map handling
- file filter forming
Disappeared as mystically as appeared.

*/

function etcResourcesFormReflectorsExperiment( test )
{
  let context = this;
  let a = context.assetFor( test, 'performance' );
  a.reflect()

  /* */

  a.ready.then( () =>
  {
    /* This case uses out file of Starter that cause slow forming of reflector reflect.submodules from supermode */

    test.case = 'old version of out file from Starter module, works really slow';
    let o2 =
    {
      execPath,
      currentPath : a.abs( './old-out-file/' ),
      args : [ '.submodules.list' ],
      mode : 'fork',
      outputCollecting : 1
    };

    let con = _.process.start( o2 );
    let t = _.time.out( 10000, () =>
    {
      o2.pnd.kill( 'SIGKILL' );
      throw _.err( 'TimeOut:10000, resources forming takes too long' );
    });

    return _.Consequence.Or( con, t );
    // return con.orKeepingSplit( t );
  })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'module::old-out-file / submodule::Starter' ) );
    test.true( _.strHas( op.output, 'path : git+https:///github.com/Wandalen/wStarter.git/out/wStarter!master' ) );
    test.true( _.strHas( op.output, 'autoExporting : 0' ) );
    test.true( _.strHas( op.output, 'enabled : 1' ) );
    test.true( _.strHas( op.output, 'Exported builds : [ \'proto.export\' ]' ) );
    test.true( _.strHas( op.output, 'isDownloaded : false' ) );
    test.true( _.strHas( op.output, 'isAvailable : false' ) );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    /* This case uses new out file of Starter forming of reflector reflect.submodules from supermode is fast */

    test.case = 'new version of out file from Starter module, works fast';

    let o2 =
    {
      execPath,
      currentPath : a.abs( './new-out-file/' ),
      args : [ '.submodules.list' ],
      mode : 'fork',
      outputCollecting : 1
    };

    let con = _.process.start( o2 );
    let t = _.time.out( 10000, () =>
    {
      o2.pnd.kill( 'SIGKILL' );
      throw _.err( 'TimeOut : 10000, resources forming takes too long' );
    });

    return _.Consequence.Or( con, t );
    // return con.orKeepingSplit( t );
  })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'module::new-out-file / submodule::Starter' ) );
    test.true( _.strHas( op.output, 'path : git+https:///github.com/Wandalen/wStarter.git/out/wStarter!master' ) );
    test.true( _.strHas( op.output, 'autoExporting : 0' ) );
    test.true( _.strHas( op.output, 'enabled : 1' ) );
    test.true( _.strHas( op.output, 'Exported builds : [ \'proto.export\' ]' ) );
    test.true( _.strHas( op.output, 'isDownloaded : false' ) );
    test.true( _.strHas( op.output, 'isAvailable : false' ) );

    return null;
  })

  /* */

  return a.ready;
}

//

function etcCommandsSeveral( test )
{
  let context = this;
  let a = context.assetFor( test, 'open' );
  a.reflect();
  a.fileProvider.filesDelete({ filePath : a.abs( 'out' ) });

  /* - */

  a.appStart( '".with . .export ; .clean"' )
  .then( ( op ) =>
  {
    test.case = '.with . .export ; .clean';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Command .*\.with \. \.export ; \.clean.*/ ), 1 );
    test.identical( _.strCount( op.output, /Exported .*module::submodule \/ build::export.*/ ), 1 );
    test.identical( _.strCount( op.output, 'Clean deleted 5 file' ), 1 );

    var exp =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './doc.ex.will.yml',
      './doc.im.will.yml',
      './doc',
      './doc/.ex.will.yml',
      './doc/.im.will.yml',
      './doc/doc.ex.will.yml',
      './doc/doc.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js'
    ];
    var got = a.find( a.routinePath );
    test.identical( got, exp );

    return null;
  });

  /* - */

  return a.ready;
}

etcCommandsSeveral.description =
`
- check internal stat of will
- several commands separated with ";"" should works
`;

//

function etcRunCommandsOnDisabledModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'openWithDisabled' );
  a.reflectMinimal();
  a.fileProvider.filesDelete({ filePath : a.abs( 'out' ) });

  /* - */

  a.appStart( '.shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from unnamed disabled module, no selector';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStart( '.with ./ .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from unnamed disabled module, selector - current directory';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStart( '.with ./will .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from unnamed disabled module, selector - directory with name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStart( '.with ./will.yml .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from unnamed disabled module, selector - directory with full name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStartNonThrowing( '.with ./will* .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should not echo, selector - directory with name and glob';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 0 );
    return null;
  });

  /* */

  a.appStart( '.with ./Disabled .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from named disabled module, selector - directory with name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStart( '.with ./Disabled.will .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from named disabled module, selector - directory with name and extension';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStart( '.with ./Disabled.will.yml .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from named disabled module, selector - directory with full name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  a.appStartNonThrowing( '.with ./Disabled* .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should not echo, selector - directory with name and glob';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 0 );
    return null;
  });

  /* */

  a.appStart( '.with ./* .shell echo str' )
  .then( ( op ) =>
  {
    test.case = 'should echo once from named enabled module, selector - willfiles in directory';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  /* */

  a.appStart({ currentPath : a.abs( '..' ), execPath : '.with */* .shell echo str' })
  .then( ( op ) =>
  {
    test.case = 'should echo once from enabled module, run from external directory with all willfiles';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

etcRunCommandsOnDisabledModule.description =
`
- check internal stat of will
- several commands separated with ";"" should works
`;

//

function etcResolveDefaultBuilds( test )
{
  let context = this;
  let a = context.assetFor( test, 'buildsResolve' );
  a.reflectMinimal();

  /* - */

  a.appStart( '.build' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".build"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::build' ), 1 );
    test.identical( _.strCount( op.output, 'Exporting module::implicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, '> echo implicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::implicit / build::build in' ), 1 );
    return null;
  });

  a.appStart( '.export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".export"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::build' ), 0 );
    test.identical( _.strCount( op.output, 'Exporting module::implicit / build::export' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, '> echo implicit' ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::implicit / build::export in' ), 1 );
    return null;
  });

  a.appStart( '.publish' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".publish"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::build' ), 0 );
    test.identical( _.strCount( op.output, 'Exporting module::implicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::publish' ), 1 );
    test.identical( _.strCount( op.output, '> echo implicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::implicit / build::publish in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with SeveralCriterions .build' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".with SeveralCriterions .build"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::explicit / build::build' ), 1 );
    test.identical( _.strCount( op.output, 'Exporting module::explicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::explicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, '> echo explicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::explicit / build::build in' ), 1 );
    return null;
  });

  a.appStart( '.with SeveralCriterions .export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".with SeveralCriterions .export"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::explicit / build::build' ), 0 );
    test.identical( _.strCount( op.output, 'Exporting module::explicit / build::export' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::explicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, '> echo explicit' ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::explicit / build::export in' ), 1 );
    return null;
  });

  a.appStart( '.with SeveralCriterions .publish' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".with SeveralCriterions .publish"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::explicit / build::build' ), 0 );
    test.identical( _.strCount( op.output, 'Exporting module::explicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::explicit / build::publish' ), 1 );
    test.identical( _.strCount( op.output, '> echo explicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::explicit / build::publish in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.build build.no.default.criterion' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".build build.no.default.criterion"' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::build.no.default.criterion' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, '> echo implicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::implicit / build::build.no.default.criterion in' ), 1 );
    return null;
  });

  a.appStartNonThrowing( '.export build.no.default.criterion' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".export build.no.default.criterion"' ), 1 );
    test.identical( _.strCount( op.output, /Building module::implicit \/ build::build\s/ ), 0 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::build.no.default.criterion' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, '> echo implicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::implicit / build::build.no.default.criterion in' ), 1 );
    return null;
  });

  a.appStartNonThrowing( '.publish build.no.default.criterion' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".publish build.no.default.criterion"' ), 1 );
    test.identical( _.strCount( op.output, /Building module::implicit \/ build::build\s/ ), 0 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::implicit / build::build.no.default.criterion' ), 1 );
    test.identical( _.strCount( op.output, '> echo implicit' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::implicit / build::build.no.default.criterion in' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

etcResolveDefaultBuilds.description =
`
check that utility resolves next builds with criterion default:
  - trivial;
  - export;
  - publish;
`;

//

function etcResolveBuildsLists( test )
{
  let context = this;
  let a = context.assetFor( test, 'buildsResolve' );
  a.reflectMinimal();

  /* - */

  a.appStart( '.builds.list' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".builds.list"' ), 1 );
    test.identical( _.strCount( op.output, /module::implicit \/ build::build\s/ ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::build.no.default.criterion' ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::export.no.default.criterion' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::publish.no.default.criterion' ), 0 );
    return null;
  });

  a.appStart( '.exports.list' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".exports.list"' ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::build' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::build.no.default.criterion' ), 0 );
    test.identical( _.strCount( op.output, /module::implicit \/ build::export\s/ ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::export.no.default.criterion' ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::publish' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::publish.no.default.criterion' ), 0 );
    return null;
  });

  a.appStart( '.publishes.list' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".publishes.list"' ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::build' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::build.no.default.criterion' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::export' ), 0 );
    test.identical( _.strCount( op.output, 'module::implicit / build::export.no.default.criterion' ), 0 );
    test.identical( _.strCount( op.output, /module::implicit \/ build::publish\s/ ), 1 );
    test.identical( _.strCount( op.output, 'module::implicit / build::publish.no.default.criterion' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

etcResolveBuildsLists.description =
`
check that utility resolves valid names for build types:
  - trivial;
  - export;
  - publish;
`;

//

function etcRunWithSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'runWithSubmodules' );
  a.reflectMinimal();

  /* - */

  a.appStart( '.shell echo {about::name}' );
  a.ready.then( ( op ) =>
  {
    test.case = 'default behavior, should run only supermodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo super' ), 1 );
    test.identical( _.strCount( op.output, '> echo submodule' ), 0 );
    test.identical( _.strCount( op.output, '> echo submodule2' ), 0 );
    return null;
  });

  /* */

  a.appStart( '.imply withSubmodules:0 .shell echo {about::name}' );
  a.ready.then( ( op ) =>
  {
    test.case = 'withSubmodules:0, should run only supermodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo super' ), 1 );
    test.identical( _.strCount( op.output, '> echo submodule' ), 0 );
    test.identical( _.strCount( op.output, '> echo submodule2' ), 0 );
    return null;
  });

  /* */

  a.appStart( '.imply withSubmodules:1 .shell echo {about::name}' );
  a.ready.then( ( op ) =>
  {
    test.case = 'withSubmodules:1, should run supermodule and submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo super' ), 1 );
    test.identical( _.strCount( op.output, '> echo submodule' ), 1 );
    test.identical( _.strCount( op.output, '> echo submodule2' ), 0 );
    return null;
  });

  /* */

  a.appStart( '.imply withSubmodules:2 .shell echo {about::name}' );
  a.ready.then( ( op ) =>
  {
    test.case = 'withSubmodules:2, should run supermodule and submodules recursive';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo super' ), 1 );
    test.identical( _.strCount( op.output, /> echo submodule\s/ ), 1 );
    test.identical( _.strCount( op.output, '> echo submodule2' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

// --
// build
// --

function build( test )
{
  let context = this;
  let a = context.assetFor( test, 'make' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with v1 .build'
    a.fileProvider.filesDelete( a.abs( 'out/Produced.js2' ) );
    a.fileProvider.filesDelete( a.abs( 'out/Produced.txt2' ) );
    return null;
  })

  a.appStart({ execPath : '.with v1 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .+ \/ build::shell1/ ) );
    test.true( _.strHas( op.output, `node ${ a.path.normalize( 'file/Produce.js' )}` ) );
    if( process.platform === 'win32' )
    {
      test.identical( _.strCount( op.output, 'out\\Produced.txt2' ), 1 );
      test.identical( _.strCount( op.output, 'out\\Produced.js2' ), 1 );
    }
    else
    {
      test.identical( _.strCount( op.output, 'out/Produced.txt2' ), 1 );
      test.identical( _.strCount( op.output, 'out/Produced.js2' ), 1 );
    }
    test.true( _.strHas( op.output, /Built .+ \/ build::shell1/ ) );

    var files = a.find( a.routinePath );
    var exp =
    [
      '.',
      './v1.will.yml',
      './v2.will.yml',
      './file',
      './file/File.js',
      './file/File.test.js',
      './file/Produce.js',
      './file/Src1.txt',
      './file/Src2.txt',
      './out',
      './out/Produced.js2',
      './out/Produced.txt2',
      './out/shouldbe.txt'
    ];
    test.identical( files, exp );
    return null;
  })

  a.appStart({ execPath : '.with v1 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .+ \/ build::shell1/ ) );
    test.true( !_.strHas( op.output, 'node file/Produce.js' ) );
    if( process.platform === 'win32' )
    {
      test.identical( _.strCount( op.output, 'out\\Produced.txt2' ), 0 );
      test.identical( _.strCount( op.output, 'out\\Produced.js2' ), 0 );
    }
    else
    {
      test.identical( _.strCount( op.output, 'out/Produced.txt2' ), 0 );
      test.identical( _.strCount( op.output, 'out/Produced.js2' ), 0 );
    }
    test.true( _.strHas( op.output, /Built .+ \/ build::shell1/ ) );

    var files = a.find( a.routinePath );
    var exp =
    [
      '.',
      './v1.will.yml',
      './v2.will.yml',
      './file',
      './file/File.js',
      './file/File.test.js',
      './file/Produce.js',
      './file/Src1.txt',
      './file/Src2.txt',
      './out',
      './out/Produced.js2',
      './out/Produced.txt2',
      './out/shouldbe.txt'
    ];
    test.identical( files, exp );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with v2 .build'
    a.fileProvider.filesDelete( a.abs( 'out/Produced.js2' ) );
    a.fileProvider.filesDelete( a.abs( 'out/Produced.txt2' ) );
    return null;
  })

  a.appStart({ execPath : '.with v2 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .+ \/ build::shell1/ ) );
    test.true( _.strHas( op.output, `node ${ a.path.normalize( 'file/Produce.js' )}` ) );
    if( process.platform === 'win32' )
    {
      test.identical( _.strCount( op.output, 'out\\Produced.txt2' ), 1 );
      test.identical( _.strCount( op.output, 'out\\Produced.js2' ), 1 );
    }
    else
    {
      test.identical( _.strCount( op.output, 'out/Produced.txt2' ), 1 );
      test.identical( _.strCount( op.output, 'out/Produced.js2' ), 1 );
    }
    test.true( _.strHas( op.output, /Built .+ \/ build::shell1/ ) );

    var files = a.find( a.routinePath );
    var exp =
    [
      '.',
      './v1.will.yml',
      './v2.will.yml',
      './file',
      './file/File.js',
      './file/File.test.js',
      './file/Produce.js',
      './file/Src1.txt',
      './file/Src2.txt',
      './out',
      './out/Produced.js2',
      './out/Produced.txt2',
      './out/shouldbe.txt'
    ];
    test.identical( files, exp );
    return null;
  })

  a.appStart({ execPath : '.with v2 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .+ \/ build::shell1/ ) );
    test.true( !_.strHas( op.output, 'node file/Produce.js' ) );
    if( process.platform === 'win32' )
    {
      test.identical( _.strCount( op.output, 'out\\Produced.txt2' ), 0 );
      test.identical( _.strCount( op.output, 'out\\Produced.js2' ), 0 );
    }
    else
    {
      test.identical( _.strCount( op.output, 'out/Produced.txt2' ), 0 );
      test.identical( _.strCount( op.output, 'out/Produced.js2' ), 0 );
    }
    test.true( _.strHas( op.output, /Built .+ \/ build::shell1/ ) );

    var files = a.find( a.routinePath );
    var exp =
    [
      '.',
      './v1.will.yml',
      './v2.will.yml',
      './file',
      './file/File.js',
      './file/File.test.js',
      './file/Produce.js',
      './file/Src1.txt',
      './file/Src2.txt',
      './out',
      './out/Produced.js2',
      './out/Produced.txt2',
      './out/shouldbe.txt'
    ];
    test.identical( files, exp );
    return null;
  })

  /* - */

  return a.ready;
}

build.rapidity = -1;

//

function buildStepShellAndViewWithoutAbout( test )
{
  let context = this;
  let a = context.assetFor( test, 'buildStepShellAndView' );

  if( !_.process.insideTestContainer() )
  return test.true( true );

  a.reflect();

  /* - */

  a.appStart({ execPath : '.build run' })
  .then( ( op ) =>
  {
    test.case = 'module is not a git repository';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::buildStepShellAndViewWithoutAbout / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> node Sample.s' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::buildStepShellAndViewWithoutAbout / build::run' ), 1 );
    test.identical( _.strCount( op.output, 'View http:///www.google.com' ), 1 );
    return null;
  });

  /* - */

  a.shell( 'git init' );
  a.shell( 'git remote add origin https://github.com/Wandalen/wModuleForTesting2.git' );
  a.appStart({ execPath : '.build run' })
  .then( ( op ) =>
  {
    test.case = 'module is a git repository';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::buildStepShellAndViewWithoutAbout / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> node Sample.s' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::buildStepShellAndViewWithoutAbout / build::run' ), 1 );
    test.identical( _.strCount( op.output, 'View http:///www.google.com' ), 1 );
    return null;
  });

  /* - */

  return a.ready.delay( 5000 );
}

//

/*
Test transpilation of JS files.
*/

function buildTranspile( test )
{
  let context = this;
  let a = context.assetFor( test, 'transpile' );

  /* - */

  begin();

  /* */

  a.ready.then( () =>
  {
    test.case = '.build debug'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build debug' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './debug',
      './debug/dir1',
      './debug/dir1/Text.txt',
      './debug/dir2',
      './debug/dir2/File.js',
      './debug/dir2/File.test.js',
      './debug/dir2/File1.debug.js',
      './debug/dir2/File2.debug.js',
      './debug/dir3.test',
      './debug/dir3.test/File.js',
      './debug/dir3.test/File.test.js'
    ];
    test.identical( files, exp );
    a.fileProvider.isTerminal( a.abs( 'out/debug/dir3.test/File.js' ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build compiled.debug'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build compiled.debug' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './compiled.debug',
      './compiled.debug/Main.s',
      './tests.compiled.debug',
      './tests.compiled.debug/Tests.s'
    ];
    test.identical( files, exp );
    a.fileProvider.isTerminal( a.abs( 'out/compiled.debug/Main.s' ) );
    a.fileProvider.isTerminal( a.abs( 'out/tests.compiled.debug/Tests.s' ) );

    var read = a.fileProvider.fileRead( a.abs( 'out/compiled.debug/Main.s' ) );
    test.true( !_.strHas( read, 'dir2/-Ecluded.js' ) );
    test.true( _.strHas( read, 'dir2/File.js' ) );
    test.true( !_.strHas( read, 'dir2/File.test.js' ) );
    test.true( _.strHas( read, 'dir2/File1.debug.js' ) );
    test.true( !_.strHas( read, 'dir2/File1.release.js' ) );
    test.true( _.strHas( read, 'dir2/File2.debug.js' ) );
    test.true( !_.strHas( read, 'dir2/File2.release.js' ) );

    var read = a.fileProvider.fileRead( a.abs( 'out/tests.compiled.debug/Tests.s' ) );
    test.true( !_.strHas( read, 'dir2/-Ecluded.js' ) );
    test.true( !_.strHas( read, 'dir2/File.js' ) );
    test.true( _.strHas( read, 'dir2/File.test.js' ) );
    test.true( !_.strHas( read, 'dir2/File1.debug.js' ) );
    test.true( !_.strHas( read, 'dir2/File1.release.js' ) );
    test.true( !_.strHas( read, 'dir2/File2.debug.js' ) );
    test.true( !_.strHas( read, 'dir2/File2.release.js' ) );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build raw.release'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build raw.release' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './raw.release',
      './raw.release/dir1',
      './raw.release/dir1/Text.txt',
      './raw.release/dir2',
      './raw.release/dir2/File.js',
      './raw.release/dir2/File.test.js',
      './raw.release/dir2/File1.release.js',
      './raw.release/dir2/File2.release.js',
      './raw.release/dir3.test',
      './raw.release/dir3.test/File.js',
      './raw.release/dir3.test/File.test.js'
    ];
    test.identical( files, exp );
    a.fileProvider.isTerminal( a.abs( 'out/raw.release/dir3.test/File.test.js' ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build release';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build release' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './release',
      './release/Main.s',
      './tests.compiled.release',
      './tests.compiled.release/Tests.s'
    ];
    test.identical( files, exp );
    a.fileProvider.isTerminal( a.abs( 'out/release/Main.s' ) );
    a.fileProvider.isTerminal( a.abs( 'out/tests.compiled.release/Tests.s' ) );

    var read = a.fileProvider.fileRead( a.abs( 'out/release/Main.s' ) );
    test.true( _.strHas( read, 'dir2/File.js' ) );
    test.true( !_.strHas( read, 'dir2/File1.debug.js' ) );
    test.true( _.strHas( read, 'dir2/File1.release.js' ) );
    test.true( !_.strHas( read, 'dir2/File2.debug.js' ) );
    test.true( _.strHas( read, 'dir2/File2.release.js' ) );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build all'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build all' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './compiled.debug',
      './compiled.debug/Main.s',
      './debug',
      './debug/dir1',
      './debug/dir1/Text.txt',
      './debug/dir2',
      './debug/dir2/File.js',
      './debug/dir2/File.test.js',
      './debug/dir2/File1.debug.js',
      './debug/dir2/File2.debug.js',
      './debug/dir3.test',
      './debug/dir3.test/File.js',
      './debug/dir3.test/File.test.js',
      './raw.release',
      './raw.release/dir1',
      './raw.release/dir1/Text.txt',
      './raw.release/dir2',
      './raw.release/dir2/File.js',
      './raw.release/dir2/File.test.js',
      './raw.release/dir2/File1.release.js',
      './raw.release/dir2/File2.release.js',
      './raw.release/dir3.test',
      './raw.release/dir3.test/File.js',
      './raw.release/dir3.test/File.test.js',
      './release',
      './release/Main.s',
      './tests.compiled.debug',
      './tests.compiled.debug/Tests.s',
      './tests.compiled.release',
      './tests.compiled.release/Tests.s'
    ];
    test.identical( files, exp );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.fileWrite( a.abs( 'proto/dir2/-Excluded.js' ), 'console.log( \'dir2/-Ecluded.js\' );' )
      return null;
    });
  }
}

//

function buildTranspileWithOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'transpileOptions' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'minify, raw mode, max compression'
    test.description =
    `Options:\
     \n transpilingStrategy : [ 'Uglify' ]\
     \n optimization : 9\
     \n minification : 9\
     \n diagnosing : 0\
     \n beautifing : 0
    `
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })
  a.appStart({ execPath : '.build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './File.min.js' ] );
    let file = a.fileProvider.fileRead( a.abs( 'out/File.min.js') );
    let lines = _.strLinesCount( file );
    test.identical( lines, 1 );
    return null;
  })

  /* - */

  return a.ready;
}

//

function buildTranspileExperiment( test )
{
  let context = this;
  let a = context.assetFor( test, 'transpile' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build debug'
    return null;
  })
  a.appStart({ execPath : '.build compiled.debug' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    console.log( op.output );
    return null;
  })

  return a.ready;
}

buildTranspileExperiment.experimental = 1;

//

function buildSingleModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'single' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.build'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    return null;
  })

  a.appStart({ execPath : '.build' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .*module::single \/ build::debug\.raw.*/ ) );
    test.true( _.strHas( op.output, 'reflected 2 file(s)' ) );
    test.true( _.strHas( op.output, /Built .*module::single \/ build::debug\.raw.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './Single.s' ] );

    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = '.build debug.raw'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    return null;
  })

  a.appStart({ execPath : '.build debug.raw' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .*module::single \/ build::debug\.raw.*/ ) );
    test.true( _.strHas( op.output, 'reflected 2 file(s)' ) );
    test.true( _.strHas( op.output, /Built .*module::single \/ build::debug\.raw.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './Single.s' ] );

    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = '.build release.raw'
    a.fileProvider.filesDelete( a.abs( 'out/release' ) );
    return null;
  })

  a.appStart({ execPath : '.build release.raw' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Building .*module::single \/ build::release\.raw.*/ ) );
    test.true( _.strHas( op.output, 'reflected 2 file(s)' ) );
    test.true( _.strHas( op.output, /Built .*module::single \/ build::release\.raw.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './Single.s' ] );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build wrong'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    a.fileProvider.filesDelete( a.abs( 'out/release' ) );
    var o =
    {
      args : [ '.build wrong' ],
      ready : null,
    }
    return test.shouldThrowErrorOfAnyKind( () => a.appStart( o ) )
    .then( ( op ) =>
    {
      test.true( o.exitCode !== 0 );
      test.true( o.output.length >= 1 );
      test.true( !a.fileProvider.fileExists( a.abs( 'out/debug' ) ) )
      test.true( !a.fileProvider.fileExists( a.abs( 'out/release' ) ) )

      return null;
    })
  })

  /* - */

  return a.ready;
}

//

function buildSingleStep( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepShell' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.build debug1'
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.build debug1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build debug2'
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.build debug2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function buildSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'build withoud submodules';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build' })
  .then( (op ) =>
  {
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    var files = a.find( a.abs( 'out' ) );
    test.gt( files.length, 10 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.submodules.update' })
  .then( () =>
  {
    test.case = '.build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, /Building .*module::submodules \/ build::debug\.raw.*/ ) );
    test.true( _.strHas( op.output, /Built .*module::submodules \/ build::debug\.raw.*/ ) );

    var files = a.find( a.abs( 'out' ) );
    test.gt( files.length, 10 );
    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.build wrong';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.ready.then( () =>
  {
    var o =
    {
      execPath : 'node ' + context.appJsPath,
      currentPath : a.routinePath,
      outputCollecting : 1,
      outputGraying : 1,
      args : [ '.build wrong' ]
    };

    return test.shouldThrowErrorOfAnyKind( _.process.start( o ) )
    .then( ( op ) =>
    {
      test.true( o.exitCode !== 0 );
      test.true( o.output.length >= 1 );
      test.true( !a.fileProvider.fileExists( a.abs( 'out' ) ) );
      test.true( !a.fileProvider.fileExists( a.abs( 'out/debug' ) ) );
      test.true( !a.fileProvider.fileExists( a.abs( 'out/release' ) ) );
      return null;
    });
  });

  /* - */

  return a.ready;
}

buildSubmodules.timeOut = 300000;

//

function buildOptionWithSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'buildOptionWithSubmodules' );
  a.reflect();

  /* */

  a.ready.then( () =>
  {
    test.case = '.with withSubmodulesDef .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with withSubmodulesDef .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '/withSubmodulesDef.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with withSubmodules2 .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with withSubmodules2 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '/withSubmodules2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with withSubmodules1 .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with withSubmodules1 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '/withSubmodules1.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with withSubmodules0 .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with withSubmodules0 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '/withSubmodules0.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  });

  /* - */

  return a.ready;
}

buildOptionWithSubmodules.timeOut = 300000;
buildOptionWithSubmodules.experimental = 1;

//

function buildOptionWithSubmodulesExplicitRunOption( test )
{
  let context = this;
  let a = context.assetFor( test, 'buildOptionWithSubmodules' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:0 ; .with withSubmodulesDef .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:0 ; .with withSubmodulesDef .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '/withSubmodulesDef.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:0 ; .with withSubmodules2 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:0 ; .with withSubmodules2 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '/withSubmodules2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:0 ; .with withSubmodules1 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:0 ; .with withSubmodules1 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '/withSubmodules1.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:0 ; .with withSubmodules0 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:0 ; .with withSubmodules0 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '/withSubmodules0.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:1 ; .with withSubmodulesDef .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:1 ; .with withSubmodulesDef .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '/withSubmodulesDef.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:1 ; .with withSubmodules2 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:1 ; .with withSubmodules2 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '/withSubmodules2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:1 ; .with withSubmodules1 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:1 ; .with withSubmodules1 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '/withSubmodules1.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:1 ; .with withSubmodules0 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:1 ; .with withSubmodules0 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '/withSubmodules0.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 0 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:2 ; .with withSubmodulesDef .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:2 ; .with withSubmodulesDef .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '/withSubmodulesDef.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 1 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:2 ; .with withSubmodules2 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:2 ; .with withSubmodules2 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '/withSubmodules2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 1 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:2 ; .with withSubmodules1 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:2 ; .with withSubmodules1 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '/withSubmodules1.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 1 );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.imply withSubmodules:2 ; .with withSubmodules0 .build'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.imply withSubmodules:2 ; .with withSubmodules0 .build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo1' ), 1 );

    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '/withSubmodules0.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l3.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '/l1.will.yml' ), 1 );

    return null;
  })

  /* - */

  return a.ready;
}

buildOptionWithSubmodulesExplicitRunOption.rapidity = -1;
buildOptionWithSubmodulesExplicitRunOption.timeOut = 300000;

//

function buildDetached( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetached' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.build';
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, /\+ .*module::wModuleForTesting1.* was downloaded version .*master.* in/ ) );
    test.true( _.strHas( op.output, /\+ .*module::wPathBasic.* was downloaded version .*622fb3c259013f3f6e2aeec73642645b3ce81dbc.* in/ ) );
    test.true( _.strHas( op.output, /\.module\/ModuleForTesting2a\.informal <- npm:\/\/wprocedure/ ) );
    test.true( _.strHas( op.output, /\.module\/ModuleForTesting12\.informal <- git\+https:\/\/github\.com\/Wandalen\/wModuleForTesting12\.git#fb7c095a0fdbd6766b0d840ad914b5887c1500e7/ ) );
    test.true( _.strHas( op.output, /\.module\/ModuleForTesting12ab\.informal <- git\+https:\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git/ ) );

    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting12.informal', 'ModuleForTesting12ab.informal', 'ModuleForTesting2a.informal', 'ModuleForTesting2b' ] );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, [ 'debug', 'ModuleForTesting12.informal.out.will.yml', 'ModuleForTesting12ab.informal.out.will.yml', 'ModuleForTesting2a.informal.out.will.yml' ] );

    return null;
  })

  /* - */

  return a.ready;
}

buildDetached.timeOut = 300000;

//

function openModuleWithLostSubmodule( test )
{
  let context = this;
  let a = context.assetFor( test, 'openWithLostSubmodule' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export using no command with'
    return null;
  });

  a.appStartNonThrowing({ execPath : '.export' });
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".export"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '! Failed to open module::super' ), 1 );
    test.identical( _.strCount( op.output, 'Exporting module::super / build::export' ), 1 );
    test.identical( _.strCount( op.output, '+ reflector::reflect.proto reflected 2 file' ), 1 );
    test.identical( _.strCount( op.output, 'Found no out-willfile for relation::Submodule' ), 1 );
    test.identical( _.strCount( op.output, 'Error looking for willfiles for module at' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open module::super / module::super / relation::Submodule' ), 1 );
    var exp =
    'Exporting is impossible because module::super / module::super / relation::Submodule is not downloaded or not valid!';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Failed to export module::super / module::super / exported::export' ), 1 );
    test.identical( _.strCount( op.output, 'Failed module::super / step::export' ), 1 );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/super.out.will.yml' ) ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.export using command with'
    return null;
  });

  a.appStartNonThrowing({ execPath : '.with "**" .export' });
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".with ** .export"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 5 );
    test.identical( _.strCount( op.output, '! Failed to open module::super' ), 1 );
    test.identical( _.strCount( op.output, 'Exporting module::super / build::export' ), 1 );
    test.identical( _.strCount( op.output, '+ reflector::reflect.proto reflected 2 file' ), 1 );
    test.identical( _.strCount( op.output, 'Found no out-willfile for relation::Submodule' ), 1 );
    test.identical( _.strCount( op.output, 'Error looking for willfiles for module at' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open module::super / module::super / relation::Submodule' ), 1 );
    var exp =
    'Exporting is impossible because module::super / module::super / relation::Submodule is not downloaded or not valid!';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Failed to export module::super / module::super / exported::export' ), 1 );
    test.identical( _.strCount( op.output, 'Failed module::super / step::export' ), 1 );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/super.out.will.yml' ) ) );
    return null;
  });

  /* - */

  return a.ready;
}

openModuleWithLostSubmodule.rapidity = -1;
openModuleWithLostSubmodule.description =
`
Routine is intended to verify that utility throws error when local submodule is lost.
Utility should throw error even if submodule exists in another directory of module and
utility command has part '.with' :
will .with ** .export

The regular commands do not depend of submodules presence, the export commands depend.
Maybe, some scenarios exist where utility does not throw error.
`;

//

function openWith( test )
{
  let context = this;
  let a = context.assetFor( test, 'open' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './submodule.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with . .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with . .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './submodule.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with doc .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc .export -- deleted doc.will.yml';
    a.reflectMinimal();
    a.fileProvider.fileDelete( a.abs( 'doc.ex.will.yml' ) );
    a.fileProvider.fileDelete( a.abs( 'doc.im.will.yml' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.with doc .export' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc. .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with doc. .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc/. .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with doc/. .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with do .export'
    a.reflectMinimal();
    return null;
  });

  a.appStartNonThrowing({ execPath : '.with do .export' })
  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'uncaught error' ), 0 );
    test.identical( _.strCount( op.output, '====' ), 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with docx .export';
    a.reflectMinimal();
    return null;
  });

  a.appStartNonThrowing({ execPath : '.with docx .export' })
  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'uncaught error' ), 0 );
    test.identical( _.strCount( op.output, '====' ), 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc/ .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with doc/ .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [ '.', './submodule.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc/.will.yml .export -- deleted doc/.will.yml';

    a.reflectMinimal();
    a.fileProvider.fileDelete( a.abs( 'doc/.ex.will.yml' ) );
    a.fileProvider.fileDelete( a.abs( 'doc/.im.will.yml' ) );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with doc/.will.yml .export' })
  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'uncaught error' ), 0 );
    test.identical( _.strCount( op.output, '====' ), 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    a.reflect();

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with doc/doc .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with doc/doc .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with doc/doc. .export';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.with doc/doc. .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );

    return null;
  });

  /* - */

  return a.ready;
}

openWith.rapidity = -1;

//

function openInDirWithUnderscore( test )
{
  let context = this;
  let a = context.assetFor( test, '_openInDirWithUnderscore' );
  a.reflectMinimal();

  /* - */

  a.appStart({ execPath : '.build' })
  .then( ( op ) =>
  {
    test.case = '.build - only root module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.with . .build' })
  .then( ( op ) =>
  {
    test.case = '.with . .build - only root module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.with * .build' })
  .then( ( op ) =>
  {
    test.case = '.with * .build - root module and root named module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo named-root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::named-root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.with ** .build' })
  .then( ( op ) =>
  {
    test.case = '.with * .build - root module, root named module, runned module, runned named module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo named-root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::named-root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 0 );

    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo runned' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::runned / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo named-runned' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::named-runned / build::run in' ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.with */* .build' })
  .then( ( op ) =>
  {
    test.case = '.with */* .build - root module, root named module, runned module, runned named module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo named-root' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::named-root / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 0 );

    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo runned' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::runned / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo named-runned' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::named-runned / build::run in' ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.with _skipped/ .build' })
  .then( ( op ) =>
  {
    test.case = '.with _skipped/ .build - skipped module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 0 );

    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo skipped' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::skipped / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.with _skipped/* .build' })
  .then( ( op ) =>
  {
    test.case = '.with _skipped/* .build - skipped module and skipped named module';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::root / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-root / build::run' ), 0 );

    test.identical( _.strCount( op.output, 'Building module::skipped / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo skipped' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::skipped / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::named-skipped / build::run' ), 1 );
    test.identical( _.strCount( op.output, '> echo named-skipped' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::named-skipped / build::run in' ), 1 );

    test.identical( _.strCount( op.output, 'Building module::runned / build::run' ), 0 );
    test.identical( _.strCount( op.output, 'Building module::named-runned / build::run' ), 0 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function openEach( test )
{
  let context = this;
  let a = context.assetFor( test, 'open' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.each . .export'
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.each . .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './submodule.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [] );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.each doc/ .export'
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.each doc/. .export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [] );
    var files = a.find( a.abs( 'doc/out' ) );
    test.identical( files, [ '.', './submodule.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );
    var files = a.find( a.abs( 'doc/doc.out' ) );
    test.identical( files, [ '.', './super.out.will.yml', './debug', './debug/File.debug.js', './debug/File.release.js' ] );

    return null;
  })

  /* - */

  return a.ready;
}

openEach.timeOut = 300000;

// --
// reflect
// --

function reflectorOptionsCheck( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorOptionsCheck' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, /Exported module::reflectorOptionsCheck \/ build::export with 3 file\(s\) in/ ) );

    var files = a.find( a.abs( 'out/' ) );
    test.identical( files, [ '.', './reflectorOptionsCheck.out.will.yml' ] );
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/reflectorOptionsCheck.out.will.yml' ) );

    outfile = outfile.module[ 'reflectorOptionsCheck.out' ]

    test.case = 'reflector without options';
    var reflector = outfile.reflector[ 'reflect.withoutOptions' ];
    test.identical( reflector.mandatory, undefined );
    test.identical( reflector.dstRewritingOnlyPreserving, undefined );
    test.identical( reflector.linkingAction, undefined );

    test.case = 'reflector with default options';
    var reflector = outfile.reflector[ 'reflect.defaultOptions' ];
    test.identical( reflector.mandatory, 1 );
    test.identical( reflector.dstRewritingOnlyPreserving, 1 );
    test.identical( reflector.linkingAction, 'hardLinkMaybe' );

    test.case = 'reflector with not default options';
    var reflector = outfile.reflector[ 'reflect.notDefaultOptions' ];
    test.identical( reflector.mandatory, 0 );
    test.identical( reflector.dstRewritingOnlyPreserving, 0 );
    test.identical( reflector.linkingAction, 'fileCopy' );

    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectorOptionsCheckDefaultOptionsAndWithoutOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorOptionsCheck' );
  a.reflectMinimal();

  /* - */

  a.appStart({ execPath : '.export' })
  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.abs( './.will.yml' ) );
    return null;
  });

  /* */

  a.appStart({ args : '.with import .build defaultOptions' });
  a.ready.then( ( op ) =>
  {
    test.case = '".with import .build defaultOptions", first reflection';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );
    return null;
  });

  /* */

  a.appStart({ args : '.with import .build defaultOptions' });
  a.ready.then( ( op ) =>
  {
    test.case = '".with import .build defaultOptions", second reflection';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );
    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.with import .build withoutOptions' });
  a.ready.then( ( op ) =>
  {
    test.case = '".with import .build withoutOptions", throw error - different files';
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Can\'t rewrite terminal file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectorOptionsCheckWithoutOptionsAndDefaultOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorOptionsCheck' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.export' })

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.abs( './.will.yml' ) );
    return null;
  })

  /* */

  a.appStart({ args : '.with import .build withoutOptions' })
  .then( ( op ) =>
  {
    test.case = '".with import .build withoutOptions", first reflection';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );

    return null;
  });

  /* */

  a.appStart({ args : '.with import .build withoutOptions' })
  .then( ( op ) =>
  {
    test.case = '".with import .build withoutOptions", second reflection';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );

    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.with import .build defaultOptions' })
  .then( ( op ) =>
  {
    test.case = '".with import .build defaultOptions", throw error - different files';
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Can\'t rewrite terminal file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );

    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectorOptionsCheckWithoutOptionsAndNotDefaultOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorOptionsCheck' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.export' })

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.abs( './.will.yml' ) );
    return null;
  })

  /* */

  a.appStart({ args : '.with import .build withoutOptions' })
  .then( ( op ) =>
  {
    test.case = '".with import .build withoutOptions", first reflection';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );

    return null;
  });

  /* */

  a.appStart({ args : '.with import .build withoutOptions' })
  .then( ( op ) =>
  {
    test.case = '".with import .build withoutOptions", second reflection';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );
    return null;
  });

  /* */

  a.appStart({ args : '.with import .build notDefaultOptions' }) /* aaa : ? */ /* Dmytro : routine is splitted */
  .then( ( op ) =>
  {
    test.case = '".with import .build notDefaultOptions", rewrite file because options disabled';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 1 file' ) );
    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './File.js' ] );

    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectNothingFromSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectNothingFromSubmodules' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( 'out/debug' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  /*
    Module has unused reflector and step : "reflect.submodules"
    Throws error if none submodule is defined
  */

  a.appStart({ execPath : '.export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 2 file(s)' ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, /Exported module::reflectNothingFromSubmodules \/ build::proto.export with 2 file\(s\) in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './Single.s' ] );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './reflectNothingFromSubmodules.out.will.yml', './debug', './debug/Single.s' ] );

    test.true( a.fileProvider.fileExists( a.abs( 'out/reflectNothingFromSubmodules.out.will.yml' ) ) )
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/reflectNothingFromSubmodules.out.will.yml' ) );

    outfile = outfile.module[ 'reflectNothingFromSubmodules.out' ]

    var reflector = outfile.reflector[ 'exported.files.proto.export' ];
    var expectedFilePath =
    {
      '.' : '',
      'Single.s' : ''
    }
    test.identical( reflector.src.basePath, '.' );
    test.identical( reflector.src.prefixPath, 'path::exported.dir.proto.export' );
    test.identical( reflector.src.filePath, { 'path::exported.files.proto.export' : '' } );

    var expectedReflector =
    {
      'reflect.proto' :
      {
        'src' :
        {
          'filePath' : { 'path::proto' : 'path::out.*=1' }
        },
        'criterion' : { 'debug' : 1 },
        'inherit' : [ 'predefined.*' ],
      },
      'reflect.submodules1' :
      {
        'dst' : { 'basePath' : '.', 'prefixPath' : 'path::out.debug' },
        'criterion' : { 'debug' : 1 },
        'inherit' : [ 'submodule::*/exported::*=1/reflector::exported.files*=1' ],
      },
      'reflect.submodules2' :
      {
        'src' :
        {
          'filePath' : { 'submodule::*/exported::*=1/path::exported.dir*=1' : 'path::out.*=1' },
          'prefixPath' : ''
        },
        'dst' : { 'prefixPath' : '' },
        'criterion' : { 'debug' : 1 },
        'inherit' : [ 'predefined.*' ],
      },
      'exported.proto.export' :
      {
        'src' :
        {
          'filePath' : { '**' : '' },
          'prefixPath' : '../proto'
        },
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'mandatory' : 1,
        'dstRewritingOnlyPreserving' : 1,
        'linkingAction' : 'hardLinkMaybe',
      },
      'exported.files.proto.export' :
      {
        'src' : { 'filePath' : { 'path::exported.files.proto.export' : '' }, 'basePath' : '.', 'prefixPath' : 'path::exported.dir.proto.export', 'recursive' : 0 },
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'recursive' : 0,
      }
    }
    test.identical( outfile.reflector, expectedReflector );
    // logger.log( _.entity.exportJson( outfile.reflector ) );

    return null;
  })

  return a.ready;
}

//

function reflectGetPath( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectGetPath' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:1 .build debug1';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .build debug1' });
  a.ready.then( ( arg ) => validate( arg ) );

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:1 .build debug2';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .build debug2' });
  a.ready.then( ( arg ) => validate( arg ) );

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:1 .build debug3';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .build debug3' });
  a.ready.then( ( arg ) => validate( arg ) );

  /* - */

  return a.ready;

  /* */

  function validate( arg )
  {
    test.identical( arg.exitCode, 0 );

    var expected =
    [
      '.',
      './debug',
      './debug/wtools',
      './debug/wtools/testing',
      './debug/wtools/testing/Common.s',
      './debug/wtools/testing/l3',
      './debug/wtools/testing/l3/testing12',
      './debug/wtools/testing/l3/testing12/ModuleForTesting12.s',
    ];
    var files = a.find( a.abs( 'out' ) );
    test.gt( files.length, 4 );
    test.identical( files, expected );
    return null;
  }
}

//

function reflectSubdir( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectSubdir' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.each module .export' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.isTerminal( a.abs( 'submodule.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out' ) ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build variant:1';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });
  a.appStart({ execPath : '.imply withSubmodules:1 .build variant:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.isTerminal( a.abs( './module/proto/File1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( './out/debug/proto/File1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'submodule.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out' ) ) );

    var expected =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './submodule.out.will.yml',
      './module',
      './module/submodule.will.yml',
      './module/proto',
      './module/proto/File1.s',
      './module/proto/File2.s',
      './out',
      './out/debug',
      './out/debug/proto',
      './out/debug/proto/File1.s',
      './out/debug/proto/File2.s',
    ];
    var got = a.find( a.routinePath );
    test.identical( got, expected );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build variant:2';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });
  a.appStart({ execPath : '.imply withSubmodules:1 .build variant:2' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.isTerminal( a.abs( './module/proto/File1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( './out/debug/proto/File1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'submodule.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out' ) ) );

    var expected =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './submodule.out.will.yml',
      './module',
      './module/submodule.will.yml',
      './module/proto',
      './module/proto/File1.s',
      './module/proto/File2.s',
      './out',
      './out/debug',
      './out/debug/proto',
      './out/debug/proto/File1.s',
      './out/debug/proto/File2.s',
    ];
    var got = a.find( a.routinePath );
    test.identical( got, expected );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build variant:3';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });
  a.appStart({ execPath : '.imply withSubmodules:1 .build variant:3' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.isTerminal( a.abs( './module/proto/File1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( './out/debug/proto/File1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'submodule.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out' ) ) );

    var expected =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './submodule.out.will.yml',
      './module',
      './module/submodule.will.yml',
      './module/proto',
      './module/proto/File1.s',
      './module/proto/File2.s',
      './out',
      './out/debug',
      './out/debug/proto',
      './out/debug/proto/File1.s',
      './out/debug/proto/File2.s',
    ];
    var got = a.find( a.routinePath );
    test.identical( got, expected );
    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectSubmodulesWithBase( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectSubmodulesWithBase' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.each module .export' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.isTerminal( a.abs( 'submodule1.out.will.yml' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'submodule2.out.will.yml' ) ) );
    return op;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'variant 0, src basePath : ../..';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .build variant:0' })
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var expected =
    [
      '.',
      './debug',
      './debug/reflectSubmodulesWithBase',
      './debug/reflectSubmodulesWithBase/module',
      './debug/reflectSubmodulesWithBase/module/proto',
      './debug/reflectSubmodulesWithBase/module/proto/File1.s',
      './debug/reflectSubmodulesWithBase/module/proto/File2.s'
    ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, expected );
    return op;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'variant 1, src basePath : "{submodule::*/exported::*=1/path::exported.dir*=1}/../.."';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .build variant:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var expected =
    [
      '.',
      './debug',
      './debug/module',
      './debug/module/proto',
      './debug/module/proto/File1.s',
      './debug/module/proto/File2.s'
    ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, expected );
    return op;
  });

  /* - */

  return a.ready;
}

reflectSubmodulesWithBase.timeOut = 150000;

//

function reflectComposite( test )
{
  let context = this;
  let a = context.assetFor( test, 'compositeReflector' );

  /* - */

  begin();

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:0'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:0' })
  .then( ( arg ) =>
  {
    var expected =
    [
      '.',
      './debug',
      './debug/dir1',
      './debug/dir1/for-git.txt',
      './debug/dir2',
      './debug/dir2/File.js',
      './debug/dir2/File.test.js',
      './debug/dir2/File1.debug.js',
      './debug/dir2/File2.debug.js'
    ];
    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 5 );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:1'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:1' })
  .then( ( arg ) =>
  {
    var expected =
    [
      '.',
      './debug',
      './debug/dir1',
      './debug/dir1/for-git.txt',
      './debug/dir2',
      './debug/dir2/File.js',
      './debug/dir2/File.test.js',
      './debug/dir2/File1.debug.js',
      './debug/dir2/File2.debug.js'
    ];
    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 5 );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:2'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:2' })
  .then( ( arg ) =>
  {
    var expected =
    [
      '.',
      './debug',
      './debug/dir1',
      './debug/dir1/for-git.txt',
      './debug/dir2',
      './debug/dir2/File.js',
      './debug/dir2/File.test.js',
      './debug/dir2/File1.debug.js',
      './debug/dir2/File2.debug.js'
    ];
    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 5 );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:3'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:3' })
  .then( ( arg ) =>
  {
    var expected =
    [
      '.',
      './debug',
      './debug/dir1',
      './debug/dir1/for-git.txt',
      './debug/dir2',
      './debug/dir2/File.js',
      './debug/dir2/File.test.js',
      './debug/dir2/File1.debug.js',
      './debug/dir2/File2.debug.js'
    ];
    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 5 );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:4'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:4' })
  .then( ( arg ) =>
  {
    var expected =
    [ '.', './debug', './debug/dir1', './debug/dir1/File.js', './debug/dir1/File.test.js', './debug/dir1/File1.debug.js', './debug/dir1/File2.debug.js' ]
    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 5 );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:5'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:5' })
  .then( ( arg ) =>
  {
    var expected = [ '.', './debug', './debug/dir1', './debug/dir1/File.js', './debug/dir1/File.test.js', './debug/dir1/File1.debug.js', './debug/dir1/File2.debug.js' ];
    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 5 );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:6'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:6' })
  .then( ( arg ) =>
  {
    var expected = [ '.', './debug', './debug/dir1', './debug/dir1/File.test.js' ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.build out* variant:7'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build out* variant:7' })
  .then( ( arg ) =>
  {
    var expected = [ '.', './debug', './debug/dir1', './debug/dir1/File.test.js' ]
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, expected );
    test.identical( arg.exitCode, 0 );
    return null;
  });

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.fileWrite( a.abs( 'proto/dir2/-Excluded.js' ), 'console.log( \'dir2/-Ecluded.js\' );' );
      return null;
    });
  }
}

reflectComposite.rapidity = -1;

//

function reflectRemoteGit( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectRemoteGit' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.build download.* variant:1'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:1' })
  .then( ( arg ) => validate1( arg ) )

  /* */

  .then( () =>
  {
    test.case = '.build download.* variant:2'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:2' })
  .then( ( arg ) => validate1( arg ) )

  /* */

  .then( () =>
  {
    test.case = '.build download.* variant:3'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:3' })
  .then( ( arg ) => validate1( arg ) )

  /* */

  .then( () =>
  {
    test.case = '.build download.* variant:4'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:4' })
  .then( ( arg ) => validate1( arg ) )

  /* */

  .then( () =>
  {
    test.case = '.build download.* variant:5'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:5' })
  .then( ( arg ) => validate1( arg ) )

  /* */

  .then( () =>
  {
    test.case = '.build download.* variant:6'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:6' })
  .then( ( arg ) => validate1( arg ) )

  /* */

  .then( () =>
  {
    test.case = '.build download.* variant:7'
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    return null;
  })

  a.appStart({ execPath : '.build download.* variant:7' })
  .then( ( arg ) => validate2( arg ) )

  /* */

  .then( () =>
  {
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting2a' ) );
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting1b' ) );
    a.fileProvider.filesDelete( a.abs( 'ModuleForTesting12' ) );
    return null;
  })

  /* */

  return a.ready;

  /* */

  function validate1( arg )
  {
    test.identical( arg.exitCode, 0 );
    var files = a.find( a.abs( 'ModuleForTesting2a' ) );
    test.ge( files.length, 10 );
    return null;
  }

  /* */

  function validate2( arg )
  {
    test.identical( arg.exitCode, 0 );

    var files = a.find( a.abs( 'ModuleForTesting2a' ) );
    test.ge( files.length, 10 );
    var files = a.find( a.abs( 'ModuleForTesting1b' ) );
    test.ge( files.length, 10 );
    var files = a.find( a.abs( 'ModuleForTesting12' ) );
    test.ge( files.length, 10 );

    return null;
  }

}

//

function reflectRemoteHttp( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectRemoteHttp' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.build download'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build download' })
  .then( ( arg ) =>
  {
    test.true( a.fileProvider.isTerminal( a.abs( 'out/ModuleForTesting1.s' ) ) );
    test.gt( a.fileProvider.fileSize( a.abs( 'out/ModuleForTesting1.s' ) ), 200 );
    return null;
  })

  return a.ready;
}

//

function reflectWithOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectWithOptions' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with mandatory .build variant1';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.with mandatory .clean' })
  a.appStartNonThrowing({ execPath : '.with mandatory .build variant1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, / \+ reflector::reflect.proto1 reflected 3 file\(s\) .+\/reflectWithOptions\/.* : .*out\/debug.* <- .*proto.* in/ ) );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js', './debug/File.test.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with mandatory .build variant2';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.with mandatory .clean' })
  a.appStartNonThrowing({ execPath : '.with mandatory .build variant2' })
  .finally( ( err, op ) =>
  {
    test.true( !err );
    test.true( !!op.exitCode );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, '====' ), 0 );
    test.true( _.strHas( op.output, /Failed .*module::.+ \/ step::reflect\.proto2/ ) );
    test.true( _.strHas( op.output, /No file found at .+/ ) );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with mandatory .build variant3';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.with mandatory .clean' })
  a.appStartNonThrowing({ execPath : '.with mandatory .build variant3' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, / \+ reflector::reflect.proto3 reflected 0 file\(s\) .+\/reflectWithOptions\/.* : .*out\/debug.* <- .*proto.* in/ ) );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );
    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectWithOptionDstRewriting( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectWithOptionsDstRewriting' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'reflect file, break hardlink and try to reflect again';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.clean' })
  a.appStartNonThrowing({ execPath : '.build variant1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js' ] );

    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, true );
    a.fileProvider.fileDelete( a.abs( 'proto/File.js' ) )
    a.fileProvider.fileWrite( a.abs( 'proto/File.js' ), 'console.log( "File2.js" )' )
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );

    a.fileProvider.fileWrite( a.abs( 'proto/File.js' ), `console.log( '123' );` );

    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant1' })
  .finally( ( err, op ) =>
  {
    test.true( !err );
    test.true( !!op.exitCode );
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );
    return null;
  })

  /* - */

  a.ready.then( () =>
  {
    test.case = 'reflect file with dstRewritingOnlyPreserving : 0, hard link should be restored';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    var read = a.fileProvider.fileRead( a.abs( 'proto/File.js') );
    test.identical( read, `console.log( '123' );` )
    var read = a.fileProvider.fileRead( a.abs( 'out/debug/File.js' ) );
    test.identical( read, `console.log( '123' );` )
    test.identical( linked, true );

    return null;
  })

  .then( () =>
  {
    test.case = 'unlink out file and try to restore';
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, true );
    a.fileProvider.fileDelete( a.abs( 'out/debug/File.js' ) )
    a.fileProvider.fileWrite( a.abs( 'out/debug/File.js' ), 'console.log( "Unlinked.js" )' )
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js'), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant1' })
  .finally( ( err, op ) =>
  {
    test.true( !err );
    test.true( !!op.exitCode );
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js' ), a.abs( 'out/debug/File.js' ) ])
    var read = a.fileProvider.fileRead( a.abs( 'proto/File.js' ) );
    test.identical( read, `console.log( '123' );` )
    var read = a.fileProvider.fileRead( a.abs( 'out/debug/File.js' ) );
    test.identical( read, `console.log( '123' );` )
    test.identical( linked, true );

    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectWithOptionLinking( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectWithOptionsLinking' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'reflect file using hardlinking';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js' ] );
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js'), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, true );

    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = 'linkingAction : fileCopy, other options default, should not throw error';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js' ] );
    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js'), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, true );

    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = 'linkingAction : fileCopy, dstRewritingOnlyPreserving : 0, breakingDstHardLink : 1';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant3' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js' ] );

    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js'), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );

    let write = 'console.log( "File2.js" )';
    a.fileProvider.fileWrite( a.abs( 'proto/File.js'), write );
    let read = a.fileProvider.fileRead( a.abs( 'out/debug/File.js') );
    test.notIdentical( write, read );

    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectorFromPredefinedWithOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorWithOptionsFromPredefined' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'reflector without explicit inherit property';
    return null;
  })

  a.appStartNonThrowing({ execPath : '.build variant1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js' ] );

    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js'), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );

    var read1 = a.fileProvider.fileRead( a.abs( 'proto/File.js' ) );
    var read2 = a.fileProvider.fileRead( a.abs( 'out/debug/File.js' ) );

    test.notIdentical( read1, read2 )

    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = 'same reflector but has explicit inherit from predefined reflector';
    return null;
  })
  a.appStartNonThrowing({ execPath : '.build variant2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File.js' ] );

    var linked = a.fileProvider.areHardLinked([ a.abs( 'proto/File.js'), a.abs( 'out/debug/File.js' ) ])
    test.identical( linked, false );

    var read1 = a.fileProvider.fileRead( a.abs( 'proto/File.js' ) );
    var read2 = a.fileProvider.fileRead( a.abs( 'out/debug/File.js' ) );

    test.notIdentical( read1, read2 )

    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectWithSelectorInDstFilter( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectSelectingDst' );
  a.reflect();

  /*
    reflect.proto:
      filePath :
        path::proto : .
      dst :
        basePath : .
        prefixPath : path::out.*=1 #<-- doesn't work
        # prefixPath : "{path::out.*=1}" #<-- this works
      criterion :
        debug : [ 0, 1 ]
  */

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build debug';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build debug' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/Single.s' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build release';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build release' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './release', './release/Single.s' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectSubmodulesWithCriterion( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesWithCriterion' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    return null;
  });

  a.appStart({ execPath : '.with module/A .export' });
  a.appStart({ execPath : '.with module/B .export' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.routinePath );
    var expected =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './module',
      './module/A.out.will.yml',
      './module/A.will.yml',
      './module/B.out.will.yml',
      './module/B.will.yml',
      './module/A',
      './module/A/A.js',
      './module/B',
      './module/B/B.js'
    ];
    test.identical( files, expected );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'reflect only A';
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .build A' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out/debug' ) );
    var expected = [ '.', './A.js' ];
    test.identical( files, expected );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'reflect only B';
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    return null;
  });

  a.appStart( '.imply withSubmodules:1 .build B' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out/debug' ) );
    var expected = [ '.', './B.js' ];
    test.identical( files, expected );
    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectSubmodulesWithPluralCriterionManualExport( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectSubmodulesWithPluralCriterion' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'reflect informal submodule, manual export';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.each module .export' });
  a.appStart({ execPath : '.imply withSubmodules:1 .build variant1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var expected = [ '.', './debug', './debug/File.s' ];
    test.identical( files, expected );
    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectSubmodulesWithPluralCriterionEmbeddedExport( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectSubmodulesWithPluralCriterion' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'reflect informal submodule exported using steps, two builds in a row'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  // first run works

  a.appStart({ execPath : '.build variant2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var expected = [ '.', './debug', './debug/File.s' ];
    test.identical( files, expected );
    return null;
  })

  // second run fails

  a.appStart({ execPath : '.build variant2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    var expected = [ '.', './debug', './debug/File.s' ];
    test.identical( files, expected );
    return null;
  })

  return a.ready;
}

reflectSubmodulesWithPluralCriterionEmbeddedExport.timeOut = 300000;

//

function reflectNpmModules( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectNpmModules' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    a.reflect();
    return null;
  });

  /* */

  a.appStart( '.build' )
  .then( ( op ) =>
  {
    test.case = 'reflect exported npm modules';

    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './out',
      './out/wModuleForTesting12ab.out.will.yml',
      './out/wModuleForTesting2a.out.will.yml',
      './proto',
      './proto/node_modules',
      './proto/node_modules/wmodulefortesting2a',
      './proto/wtools',
      './proto/wtools/testing',
      './proto/wtools/testing/Basic.s',
      './proto/wtools/testing/Common.s',
      './proto/wtools/testing/l3',
      './proto/wtools/testing/l3/testing2a',
      './proto/wtools/testing/l3/testing2a/ModuleForTesting2a.s',
      './proto/wtools/testing/l4',
      './proto/wtools/testing/l4/testing12ab',
      './proto/wtools/testing/l4/testing12ab/Include.s',
      './proto/wtools/testing/l4/testing12ab/ModuleForTesting12ab.s',
    ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

reflectNpmModules.timeOut = 600000;

//

/*
  moduleA exports:
  proto
    amid
      Tools.s

  moduleB exports:
    proto
      amid

  proto/amid of moduleB doesn't exist on hard drive, but its listed in out file

  main module reflects files of these modules, when assert fails
*/

function relfectSubmodulesWithNotExistingFile( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesReflectWithNotExisting' );
  a.reflect();
  _.assert( a.fileProvider.fileExists( a.abs( 'module/moduleB/proto/amid/File.txt' ) ) );
  a.fileProvider.fileDelete( a.abs( 'module/moduleB/proto/amid/File.txt' ) );

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'setup';
    return null;
  })

  a.appStart({ execPath : '.clean recursive:2' })
  a.appStart({ execPath : '.with module/moduleA/ .export' })
  a.appStart({ execPath : '.with module/moduleB/ .export' })

  /* - */

  a.ready
  // .finally( ( err, arg ) => / Dmytro : op is not defined, so `arg` replaced to `op` */
  .finally( ( err, op ) =>
  {
    test.true( err === undefined );
    if( err )
    logger.log( err );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    return op || null;
  })

  .then( () =>
  {
    test.case = 'reflect submodules'

    let exp =
    [
      '.',
      './.will.yml',
      './module',
      './module/moduleA.out.will.yml',
      './module/moduleB.out.will.yml',
      './module/moduleA',
      './module/moduleA/.will.yml',
      './module/moduleA/out',
      './module/moduleA/out/debug',
      './module/moduleA/out/debug/amid',
      './module/moduleA/out/debug/amid/Tools.s',
      './module/moduleA/proto',
      './module/moduleA/proto/amid',
      './module/moduleA/proto/amid/Tools.s',
      './module/moduleB',
      './module/moduleB/.will.yml',
      './module/moduleB/out',
      './module/moduleB/out/debug',
      './module/moduleB/out/debug/amid',
      './module/moduleB/proto',
      './module/moduleB/proto/amid'
    ]
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    return null;
  })

  a.appStart({ execPath : '.build' })

  a.ready
  .finally( ( err, op ) =>
  {
    test.true( _.errIs( err ) );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    logger.log( err );
    if( err )
    throw err;
    return op;
  })

  return test.shouldThrowErrorAsync( a.ready );
}

//

function reflectInherit( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectInherit' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.proto1'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.proto1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, ' + reflector::reflect.proto1 reflected 6 file(s)' ) );
    test.true( _.strHas( op.output, /.*out\/debug1.* <- .*proto.*/ ) );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/debug1', './out/debug1/File.js', './out/debug1/File.s', './out/debug1/File.test.js', './out/debug1/some.test', './out/debug1/some.test/File2.js', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.proto2'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.proto2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, ' + reflector::reflect.proto2 reflected 6 file(s)' ) );
    test.true( _.strHas( op.output, /.*out\/debug2.* <- .*proto.*/ ) );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/debug2', './out/debug2/File.js', './out/debug2/File.s', './out/debug2/File.test.js', './out/debug2/some.test', './out/debug2/some.test/File2.js', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.proto3'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.proto3' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, ' + reflector::reflect.proto3 reflected 6 file(s)' ) );
    test.true( _.strHas( op.output, /.*out\/debug1.* <- .*proto.*/ ) );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/debug1', './out/debug1/File.js', './out/debug1/File.s', './out/debug1/File.test.js', './out/debug1/some.test', './out/debug1/some.test/File2.js', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.proto4'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.proto4' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, ' + reflector::reflect.proto4 reflected 6 file(s)' ) );
    test.true( _.strHas( op.output, /.*out\/debug2.* <- .*proto.*/ ) );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/debug2', './out/debug2/File.js', './out/debug2/File.s', './out/debug2/File.test.js', './out/debug2/some.test', './out/debug2/some.test/File2.js', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.proto5'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.proto5' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, ' + reflector::reflect.proto5 reflected 6 file(s)' ) );
    test.true( _.strHas( op.output, /.*out\/debug2.* <- .*proto.*/ ) );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/debug2', './out/debug2/File.js', './out/debug2/File.s', './out/debug2/File.test.js', './out/debug2/some.test', './out/debug2/some.test/File2.js', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build not1'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build not1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, ' + reflector::reflect.not.test.only.js.v1 reflected 4 file(s)' ) );
    test.true( _.strHas( op.output, /.*out.* <- .*proto.*/ ) );
    var exp =
    [
      '.',
      './.will.yml',
      './out',
      './out/debug1',
      './out/debug1/File.js',
      './out/debug2',
      './out/debug2/File.js',
      './proto',
      './proto/File.js',
      './proto/File.s',
      './proto/File.test.js',
      './proto/some.test',
      './proto/some.test/File2.js'
    ]
    var files = a.find( a.routinePath );
    test.identical( files, exp );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.files1'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.files1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, / \+ reflector::reflect.files1 reflected 2 file\(s\) .*:.*out.*<-.*proto/ ), 1 );
    test.identical( _.strCount( op.output, /.*out.* <- .*proto.*/ ), 1 );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/File.js', './out/File.s', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.files2'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.files2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, / \+ reflector::reflect.files2 reflected 2 file\(s\) .*:.*out.*<-.*proto/ ), 1 );
    test.identical( _.strCount( op.output, /.*out.* <- .*proto.*/ ), 1 );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/File.js', './out/File.s', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build reflect.files3'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.build reflect.files3' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, / \+ reflector::reflect\.files3 reflected 2 file\(s\) .*:.*out.*<-.*proto/ ), 1 );
    test.identical( _.strCount( op.output, /.*out.* <- .*proto.*/ ), 1 );
    var files = a.find( a.routinePath );
    test.identical( files, [ '.', './.will.yml', './out', './out/File.js', './out/File.s', './proto', './proto/File.js', './proto/File.s', './proto/File.test.js', './proto/some.test', './proto/some.test/File2.js' ] );
    return null;
  })

  /* - */

  return a.ready;
}

reflectInherit.timeOut = 300000;

//

/*
  Check reflector inheritance from multiple ancestors.
  Check exporting single file with custom base.
  Check importing single file with custom base.
*/

function reflectInheritSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectInheritSubmodules' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.each module .export' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.routinePath );
    var exp =
    [
      '.',
      './a.will.yml',
      './b.will.yml',
      './c.will.yml',
      './submodule1.out.will.yml',
      './submodule2.out.will.yml',
      './submodule3.out.will.yml',
      './submodule4.out.will.yml',
      './module',
      './module/submodule1.will.yml',
      './module/submodule2.will.yml',
      './module/submodule3.will.yml',
      './module/submodule4.will.yml',
      './module/proto',
      './module/proto/File1.s',
      './module/proto/File2.s',
      './module/proto1',
      './module/proto1/File1.s',
      './module/proto2',
      './module/proto2/File2.s'
    ];
    test.identical( files, exp );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with a .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with a .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File1.s', './debug/File2.s' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with b .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with b .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/f1', './debug/f2' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with c .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with c .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/File1.s', './debug/File2.s' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function reflectComplexInherit( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmodules' );

  /* - */

  begin().then( () =>
  {
    test.case = '.with ab/ .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with a .export' });
  a.appStart({ execPath : '.with b .export' });
  a.appStart({ execPath : '.imply withSubmodules:1 .with ab/ .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ reflector::files.all reflected 21 file(s)' ) );
    var exp =
    [
      '.',
      './module-a.out.will.yml',
      './module-b.out.will.yml',
      './ab',
      './ab/files',
      './ab/files/a',
      './ab/files/a/File.js',
      './ab/files/b',
      './ab/files/b/-Excluded.js',
      './ab/files/b/File.js',
      './ab/files/b/File.test.js',
      './ab/files/b/File1.debug.js',
      './ab/files/b/File1.release.js',
      './ab/files/b/File2.debug.js',
      './ab/files/b/File2.release.js',
      './ab/files/dir3.test',
      './ab/files/dir3.test/File.js',
      './ab/files/dir3.test/File.test.js',
    ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, exp );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with abac/ .build';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with a .export' });
  a.appStart({ execPath : '.with b .export' });
  a.appStart({ execPath : '.with c .export' });
  a.appStart({ execPath : '.with ab/ .export' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with abac/ .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ reflector::files.all reflected 24 file(s)' ) );
    var exp =
    [
      '.',
      './module-a.out.will.yml',
      './module-b.out.will.yml',
      './module-c.out.will.yml',
      './ab',
      './ab/module-ab.out.will.yml',
      './abac',
      './abac/files',
      './abac/files/a',
      './abac/files/a/File.js',
      './abac/files/b',
      './abac/files/b/-Excluded.js',
      './abac/files/b/File.js',
      './abac/files/b/File.test.js',
      './abac/files/b/File1.debug.js',
      './abac/files/b/File1.release.js',
      './abac/files/b/File2.debug.js',
      './abac/files/b/File2.release.js',
      './abac/files/c',
      './abac/files/c/File.js',
      './abac/files/dir3.test',
      './abac/files/dir3.test/File.js',
      './abac/files/dir3.test/File.test.js',
    ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, exp );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflectMinimal();
      a.fileProvider.fileWrite( a.abs( 'proto/b/-Excluded.js' ), 'console.log( \'b/-Ecluded.js\' );' );
      return null;
    });
  }
}

reflectComplexInherit.rapidity = -1;
reflectComplexInherit.timeOut = 300000;

//

function reflectorMasks( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorMasks' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build copy.' })

  .then( ( op ) =>
  {
    test.case = 'mask directory';

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './release', './release/proto.two' ] );

    test.identical( op.exitCode, 0 );
    var outputString = `\\+ reflector::reflect.copy. reflected ${files.length-1} file\\(s\\) .* in .*`;
    test.true( _.strHas( op.output, new RegExp( outputString ) ) );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build copy.debug' })

  .then( ( op ) =>
  {
    test.case = 'mask terminal';

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/build.txt.js', './debug/manual.md', './debug/package.json', './debug/tutorial.md' ] );

    test.identical( op.exitCode, 0 );
    var outputString = `\\+ reflector::reflect.copy.debug reflected ${files.length -1} file\\(s\\) .* in .*`;
    test.true( _.strHas( op.output, new RegExp( outputString ) ) );

    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectorsCommonPrefix( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorsCommonPrefix' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.build' })

  .then( ( op ) =>
  {
    test.case = 'use two reflectors with common prefix in name';

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './debug', './debug/Source.js' ] );

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /\+ reflector::reflect.copy reflected 2 file\(s\) .* in .*/ ) );
    test.true( _.strHas( op.output, /\+ reflector::reflect.copy.second reflected 2 file\(s\) .* in .*/ ) );

    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectorOptionStep( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorOptionStep' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.build' })

  .then( ( op ) =>
  {
    test.case = 'copy proto and then use reflector to remote it';

    test.true( !a.fileProvider.fileExists( a.abs( 'out' ) ) );

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /\+ reflector::reflector.proto reflected 2 file\(s\) .* in .*/ ) );
    test.true( _.strHas( op.output, /\- step::reflector.delete deleted 2 file\(s\), at .* in .*/ ) );

    return null;
  })

  /* - */

  return a.ready;
}

//

function reflectorOptionStepThrowing( test )
{
  let context = this;
  let a = context.assetFor( test, 'reflectorOptionStepThrowing' );
  a.reflect();

  /* - */

  a.appStartNonThrowing({ execPath : '.build' })
  .then( ( op ) =>
  {
    test.case = 'try to create reflector with name of existing step using option step, should throw error';
    test.notIdentical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'step::reflector.delete deleted 0 file' ) );

    return null;
  });

  /* - */

  return a.ready;
}

// --
// hook
// --

function hookCommentOut( test )
{
  let context = this;
  let a = context.assetFor( test, 'dos' );

  /* - */

  a.ready.then( ( op ) =>
  {
    a.reflect();
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'execution_section/will.yml' ) );
    test.true( !!outfile.execution );
    return null;
  });
  a.appStart( '.with ** .do .will/hook/WillfCommentOut.js execution verbosity:5' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Comment out "execution" in module::execution_section at' ), 1 );
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'execution_section/will.yml' ) );
    test.true( !outfile.execution );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    a.reflect();
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'execution_section/will.yml' ) );
    test.true( !!outfile.execution );
    return null;
  });
  a.appStart( '.with ** .do .will/hook/WillfCommentOut.js execution dry:1 verbosity:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Comment out "execution" in module::execution_section at' ), 1 );
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'execution_section/will.yml' ) );
    test.true( !!outfile.execution );
    return null;
  });

  /* - */

  return a.ready;
}

hookCommentOut.timeOut = 300000;
hookCommentOut.description =
`
- commenting out works
- arguments passing to action works
`;

//

function hookCallInfo( test )
{
  let context = this;
  let a = context.assetFor( test, 'dos' );
  // aaa : modules for testing are still broken !!! /* Dmytro : fixed */
  // aaa : ?? /* Dmytro : a.appStart - mode : 'fork'; a.shell - mode : 'shell' */
  a.reflect();

  /* */

  a.appStart( '.clean' );
  a.appStart( '.export' );
  a.ready.then( ( op ) =>
  {
    test.case = 'setup';
    a.fileProvider.fileAppend( a.abs( 'will.yml' ), '\n' );
    test.true( a.fileProvider.fileExists( a.abs( 'out/proto' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/dos.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12' ) ) );
    return null;
  });

  /* */

  a.appStart( '.hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 1 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with . .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.with . .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 1 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with * .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.with . .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 1 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with ** .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.with . .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 9 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 1 );
    test.identical( _.strCount( op.output, 'local :' ), 4 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.imply withOut:0 ; .with ** .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.imply withOut:0 ; .with ** .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '! Outdated' ), 0 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 1 );
    test.identical( _.strCount( op.output, 'local :' ), 7 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.imply withIn:0 ; .with ** .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.imply withIn:0 ; .with ** .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 3 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 4 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

hookCallInfo.rapidity = -1;
hookCallInfo.timeOut = 600000;
hookCallInfo.description =
`
- do execute js script
- filtering option withIn works
- filtering option withOut works
- only one attempt to open outdate outfile
- action info works properly
- message with time printed afterwards
`

//

function hookGitMake( test )
{
  let context = this;
  let a = context.assetFor( test, 'dos' );

  let config = _.censor ? _.censor.configRead() : null;
  if( !config || !config.about || !config.about[ 'github.token' ] )
  return test.true( true );

  let user = config.about.user;
  const repository = `https://github.com/${user}/New2`;

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  });

  a.appStart({ execPath : '.module.new New2/' });
  a.ready.then( ( op ) =>
  {
    var exp = [ '.', './will.yml' ];
    var files = a.find( a.abs( 'New2' ) );
    test.identical( files, exp );
    return repositoryDelete( false );
  });

  a.appStart({ execPath : '.with New2/ .hook.call GitMake v:3' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.git.isRepository({ remotePath : `https://github.com/${ user }/New2` }) );
    test.identical( _.strCount( op.output, `Making repository for module::New2 at` ), 1 );
    test.identical( _.strCount( op.output, `localPath :` ), 1 );
    test.identical( _.strCount( op.output, /remotePath : .*\/New2/ ), 1 );
    test.identical( _.strCount( op.output, `> git ls-remote https://github.com/${ user }/New2` ), 1 );

    var exp = [ '.', './will.yml' ];
    var files = a.find( a.abs( 'New2' ) );
    test.identical( files, exp );

    return null;
  });

  a.ready.finally( () => repositoryDelete( true ) );

  /* - */

  return a.ready;

  /* */

  function repositoryDelete( throwing )
  {
    return _.git.repositoryDelete
    ({
      remotePath : repository,
      token : config.about[ 'github.token' ],
      throwing,
    });
  }
}

hookGitMake.timeOut = 300000;

//

function hookPrepare( test )
{
  let context = this;
  let a = context.assetFor( test, 'dos' );

  let config = _.censor ? _.censor.configRead() : null;
  if( !config || !config.about || !config.about[ 'github.token' ] )
  return test.true( true );
  if( !config.path || !config.path.remoteRepository )
  return test.true( true );

  let user = config.about.user;

  /* - */

  a.ready.then( () =>
  {
    a.reflect();
    return null;
  });

  /* - */

  a.ready.then( ( op ) =>
  {
    var exp = [];
    var files = a.find( a.abs( 'wNew2' ) );
    test.identical( files, exp );
    return _.git.repositoryDelete
    ({
      remotePath : `https://github.com/${user}/wNew2`,
      token : config.about[ 'github.token' ],
    });
  });

  a.appStart({ execPath : '.with wNew2/ .module.new.with prepare v:3' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, `Making repository for module::wNew2 at` ), 1 );
    test.identical( _.strCount( op.output, `localPath :` ), 1 );
    test.identical( _.strCount( op.output, `remotePath : git+https:///github.com/${user}/wNew2` ), 1 );
    test.identical( _.strCount( op.output, `Making remote repository https://github.com/${user}/wNew2` ), 1 );
    test.identical( _.strCount( op.output, `Making a new local repository at` ), 1 );
    test.identical( _.strCount( op.output, `git init .` ), 1 );
    test.identical( _.strCount( op.output, `git remote add origin https://github.com/${user}/wNew2` ), 1 );
    test.identical( _.strCount( op.output, `git push -u origin --all --follow-tags` ), 1 );
    test.identical( _.strCount( op.output, `> ` ), 12 );
    test.ge( _.strCount( op.output, `+ hardLink` ), 1 );

    var exp =
    [
      '.',
      './-will.yml',
      './.eslintrc.yml',
      './.ex.will.yml',
      './.gitattributes',
      './.gitignore',
      './.im.will.yml',
      './LICENSE',
      './README.md',
      './was.package.json',
      './.circleci',
      './.circleci/config.yml',
      './.github',
      './.github/workflows',
      './.github/workflows/Test.yml',
      './proto',
      './proto/Integration.test.s',
      './proto/wtools',
      './proto/node_modules/Tools',
      './proto/wtools/abase',
      './proto/wtools/amid',
      './proto/wtools/atop',
      './sample',
      './sample/Sample.html',
      './sample/Sample.s'
    ];
    var files = a.find( a.abs( 'wNew2' ) );
    test.identical( files, exp );

    return null;
  });

  a.ready.finally( () =>
  {
    return _.git.repositoryDelete
    ({
      remotePath : `https://github.com/${user}/wNew2`,
      token : config.about[ 'github.token' ],
    });
  });

  /* */

  a.ready.then( ( op ) =>
  {
    var exp = [];
    var files = a.find( a.abs( 'wNew3/wNew4' ) );
    test.identical( files, exp );
    return _.git.repositoryDelete
    ({
      remotePath : `https://github.com/${user}/wNew4`,
      token : config.about[ 'github.token' ],
    });
  });

  a.appStart({ execPath : '.with wNew3/wNew4 .module.new.with prepare v:3' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, `Making repository for module::wNew4 at` ), 1 );
    test.identical( _.strCount( op.output, `localPath :` ), 1 );
    test.identical( _.strCount( op.output, `remotePath : git+https:///github.com/${user}/wNew4` ), 1 );
    test.identical( _.strCount( op.output, `Making remote repository https://github.com/${user}/wNew4` ), 1 );
    test.identical( _.strCount( op.output, `Making a new local repository at` ), 1 );
    test.identical( _.strCount( op.output, `git init .` ), 1 );
    test.identical( _.strCount( op.output, `git remote add origin https://github.com/${user}/wNew4` ), 1 );
    test.identical( _.strCount( op.output, `git push -u origin --all --follow-tags` ), 1 );
    test.identical( _.strCount( op.output, `> ` ), 12 );
    test.ge( _.strCount( op.output, `+ hardLink` ), 1 );

    var exp =
    [
      '.',
      './-wNew4.will.yml',
      './.eslintrc.yml',
      './.ex.will.yml',
      './.gitattributes',
      './.gitignore',
      './.im.will.yml',
      './LICENSE',
      './README.md',
      './was.package.json',
      './.circleci',
      './.circleci/config.yml',
      './.github',
      './.github/workflows',
      './.github/workflows/Test.yml',
      './proto',
      './proto/Integration.test.s',
      './proto/wtools',
      './proto/node_modules/Tools',
      './proto/wtools/abase',
      './proto/wtools/amid',
      './proto/wtools/atop',
      './sample',
      './sample/Sample.html',
      './sample/Sample.s'
    ];
    var files = a.find( a.abs( 'wNew3' ) );
    test.identical( files, exp );

    return null;
  });

  a.ready.finally( () =>
  {
    return _.git.repositoryDelete
    ({
      remotePath : `https://github.com/${user}/wNew4`,
      token : config.about[ 'github.token' ],
    });
  });

  /* - */

  return a.ready;

} /* end of function hookPrepare */

hookPrepare.timeOut = 300000;

//

function hookHlink( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitConflict' );

  /* - */

  a.ready.then( ( op ) =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), '\ncopy' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), '\ncopy' );
    return null;
  });

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell( `git clone original clone` );

  a.appStart( '.with original/ .call hlink beeping:0' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .call hlink beeping:0';

    test.identical( _.strHas( op.output, '+ hardLink' ), true );
    test.true( a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( !a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'original/f1.txt' ) ) );
    test.true( !a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    return null;
  });

  a.appStart( '.with clone/ .call hlink beeping:0' )
  .then( ( op ) =>
  {
    test.case = '.with clone/ .call hlink beeping:0';

    test.identical( _.strHas( op.output, '+ hardLink' ), true );
    test.true( a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( !a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'original/f1.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    return null;
  });

  /* - */

  return a.ready;
}

hookHlink.description =
`
- same files are hardlinked
- same files from different modules are not hardlinked
`;
hookHlink.timeOut = 300000;

//

function hookGitPull( test )
{
  if( !_.censor )
  return test.true( true );

  const context = this;
  const a = context.assetFor( test, 'gitPush' );

  const config = { path : { hlink : a.abs( '..' ) } };
  const profile = `test-${ _.intRandom( 1000000 ) }`;
  _.censor.configSet({ profileDir : profile, set : config });

  /* - */

  begin().then( () =>
  {
    test.case = '.call GitPull - succefull pulling';
    return null;
  });
  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.call GitPull profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply v:0 .call GitPull v:0 - succefull pulling';
    return null;
  });
  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.imply v:0 .call GitPull v:0 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    return null;
  });

  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.call GitPull profile:${ profile }` })
  .then( ( op ) =>
  {
    test.case = '.with clone/ .call GitPull - succefull pulling with hardlinks';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:2 .with clone/ .call GitPull - succefull pulling';
    return null;
  })
  a.appStart( `.imply withSubmodules:2 .with clone/ .call GitPull profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  a.ready.finally( () => { _.censor.profileDel( profile ); return null });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });

    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( ( op ) =>
    {
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
      return null;
    });
    a.shell({ currentPath, execPath : 'git commit -am second' });
    return a.ready;
  }
}

hookGitPull.timeOut = 300000;

//

function hookGitPullConflict( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitConflict' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  a.ready.then( ( op ) =>
  {
    a.reflect();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  })

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell( `git clone original clone` );
  a.ready.then( ( op ) =>
  {
    test.case = 'hardlink';

    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    var exp =
`
original/f.txt
copy
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .call GitPull v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'has local changes';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
copy
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
clone
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
clone
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .call GitPull v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
copy
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;
}

hookGitPullConflict.timeOut = 300000;
hookGitPullConflict.description =
`
- pull done
- conflict is not obstacle to relink files
- if conflict then application returns error code
`

//

function hookGitPush( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitPush v:1 - succefull pushing of commit';
    return null;
  });

  a.appStart( '.with original/ .call GitPush v:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, ' * [new branch]      master -> master' ), 1 );
    // test.identical( _.strCount( op.output, 'Branch \'master\' set up to track remote branch \'master\' from \'origin\'.' ), 1 );
    test.identical( _.strCount( op.output, /Branch .*master.* set up to track remote branch .*master.* from .*origin.*/), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitPush v:0 - succefull pushing of tag';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  });

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -a v1.0 -m v1.0' });

  a.appStart( '.with original/ .call GitPush v:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 2 );
    test.identical( _.strCount( op.output, ' * [new tag]         v1.0 -> v1.0' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitPush - second run, nothing to push';
    return null;
  });

  a.appStart( '.with original/ .call GitPush' );
  a.appStart( '.with original/ .call GitPush' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '. Read 1 willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitPush - error on pushing, remote repository does not exist';
    a.fileProvider.filesDelete( a.abs( 'repo' ) );
    return null;
  });

  a.appStartNonThrowing( '.with original/ .call GitPush' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '. Read 1 willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );
    test.identical( _.strCount( op.output, '> git push -u origin --all' ), 1 );
    test.identical( _.strCount( op.output, 'fatal: \'../repo\' does not appear to be a git repository' ), 2 );
    test.identical( _.strCount( op.output, 'fatal: Could not read from remote repository.' ), 2 );
    test.identical( _.strCount( op.output, 'Please make sure you have the correct access rights' ), 2 );
    test.identical( _.strCount( op.output, 'and the repository exists.' ), 2 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });

    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

//

function hookGitReset( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitReset' );

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .call GitReset - resetting of current directory';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with clone/ .call GitReset' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .call GitReset dry:1 - with option dry';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/F.txt' ), 'F.txt' );
    return null;
  });

  a.appStart( '.with clone/ .call GitReset dry:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );
    test.identical( _.strCount( op.output, 'Uncommitted changes, would be reseted :' ), 1 );
    test.identical( _.strCount( op.output, 'M File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M proto/File.js' ), 1 );
    test.identical( _.strCount( op.output, 'Uncommitted changes, would be cleaned :' ), 1 );
    test.identical( _.strCount( op.output, '?? F.txt' ), 0 );

    var exp =
`
console.log( 'File.js' );
console.log( "new line" );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
new line
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    a.fileProvider.fileDelete( a.abs( 'clone/F.txt' ) );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .call GitReset removingUntracked:1 - resetting of untracked files, but not ignored';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/proto/File2.js'), 'console.log( \'File2.js\' );' );
    a.fileProvider.fileWrite( a.abs( 'clone/File2.txt'), 'File2.txt' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './File2.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './proto/File2.js'
    ];
    test.identical( got, exp );

    return null;
  });

  a.appStart( '.with clone/ .call GitReset removingUntracked:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .call GitReset removingUntracked:1 removingIgnored:1 - resetting of untracked and ignored files';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/proto/File2.js'), 'console.log( \'File2.js\' );' );
    a.fileProvider.fileWrite( a.abs( 'clone/File2.txt'), 'File2.txt' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './File2.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './proto/File2.js'
    ];
    test.identical( got, exp );

    return null;
  });

  a.appStart( '.with clone/ .call GitReset removingUntracked:1 removingIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .call GitReset removingUntracked:1 removingIgnored:1';
    test.description = 'resetting of untracked and ignored files but not subrepository'
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.dirMake( a.abs( 'clone/sub' ) );
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' )\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );

    return null;
  });

  a.shell({ currentPath : a.abs( 'clone/sub' ), execPath : 'git init' });
  a.ready.then( () =>
  {
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );
    return null;
  });

  a.appStart( '.with clone/ .call GitReset removingUntracked:1 removingIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .call GitReset removingUntracked:1 removingIgnored:1 removingSubrepositories:1';
    test.description = 'resetting of untracked, ignored files and subrepository'
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.dirMake( a.abs( 'clone/sub' ) );
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' )\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );

    return null;
  });

  a.shell({ currentPath : a.abs( 'clone/sub' ), execPath : 'git init' });
  a.ready.then( () =>
  {
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );
    return null;
  });

  a.appStart( '.with clone/ .call GitReset removingUntracked:1 removingIgnored:1 removingSubrepositories:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .call GitReset v:0 - verbosity:0';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with clone/ .call GitReset v:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::gitReset' ), 0 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 0 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {

    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });

    let currentPath = a.abs( 'clone' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

hookGitReset.rapidity = -1;

//

function hookGitSyncConflict( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitConflict' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    var exp =
`
original/f.txt
copy
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
clone
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
clone
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .call GitSync -am "second" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, '> git add' ), 1 );
    test.identical( _.strCount( op.output, '> git commit' ), 1 );
    test.identical( _.strCount( op.output, '> git push' ), 0 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
copy
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( ( op ) =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
      return null;
    });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    return a.ready;
  }
}

hookGitSyncConflict.timeOut = 300000;
hookGitSyncConflict.description =
`
- pull done
- conflict is not obstacle to relink files
- if conflict then application returns error code
`;

//

function hookGitSyncRestoreHardLinksWithShared( test )
{
  let context = this;

  if( !_.censor )
  return test.true( true );

  let temp = context.suiteTempPath;
  context.suiteTempPath = _.path.join( _.path.dir( temp ), 'willbe' ); /* Dmytro : suiteTempPath has extension .tmp, it is filtered by provider.filesFind */
  let a = context.assetFor( test, 'gitPush' );
  a.reflect();

  /* */

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }
  let linkPath = config.path.hlink;

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( () =>
  {
    test.case = 'hardlink';
    hardlink( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) );
    hardlink( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .call GitSync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, `Command ".with clone/ .call GitSync profile:${ profile }"` ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 0 );
    test.identical( _.strCount( op.output, '> git add --all' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
    test.identical( _.strCount( op.output, '1 file changed, 1 insertion(+)' ), 1 );
    test.identical( _.strCount( op.output, '> git pull' ), 1 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 1 hardlinks' ), 1 );

    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    var exp =
`
original/f.txt
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( context.suiteTempPath );
    a.fileProvider.filesDelete( profileDir );
    context.suiteTempPath = temp;
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( ( op ) =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    return a.ready;
  }

  /* */

  function hardlink( src, dst )
  {
    a.fileProvider.hardLink
    ({
      srcPath : src,
      dstPath : dst,
      sync : 1,
    });
  }
}

//

function hookGitSyncArguments( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitConflict' );

  if( !_.censor )
  return test.true( true );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let linkPath = config.path.hlink;

  /* */

  begin();
  a.appStartNonThrowing( `.with clone/ .call GitSync -am "second commit" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '> git add' ), 1 );
    test.identical( _.strCount( op.output, '> git commit' ), 1 );
    test.identical( _.strCount( op.output, '> git push' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    a.fileProvider.filesDelete( context.suiteTempPath );
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( ( op ) =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
      return null;
    });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( ( op ) =>
    {
      a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
      return null;
    });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
    return a.ready;
  }
}

hookGitSyncArguments.timeOut = 300000;
hookGitSyncArguments.description =
`
- quoted argument passed to git through willbe properly
`;

//

function hookGitTag( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitTag name:v1.0 - add tag, only option name';
    return null;
  });

  a.appStart( '.with original/ .call GitTag name:v1.0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v1.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v1.0' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitTag name:v2.0 description:"Version 2.0" - add tag with description';
    return null;
  });

  a.appStart( '.with original/ .call GitTag name:v2.0 description:"Version 2.0"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v2.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /v2.0\s+Version 2.0/ ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitTag name:v3.0 description:"Version 3.0" light:1 - add tag, only option name';
    return null;
  });

  a.appStart( '.with original/ .call GitTag name:v3.0 description:"Version 3.0" light:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v3.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v3.0' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitTag name:v4.0 description:"Version 4.0" dry:1 - option dry, should not add tag';
    return null;
  });

  a.appStart( '.with original/ .call GitTag name:v4.0 description:"Version 4.0" dry:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /v4.0\s+Version 4.0/ ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/ .call GitTag name:v4.0 description:"Version 4.0" v:0 - verbosity';
    return null;
  });

  a.appStart( '.with original/ .call GitTag name:v4.0 description:"Version 4.0" v:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /v4.0\s+Version 4.0/ ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

hookGitTag.rapidity = -1;

//

function hookWasPackageExtendWillfile( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  begin().then( () =>
  {
    test.case = 'extend unnamed willfiles without options';
    return null;
  });

  a.appStart( '.call WasPackageExtendWillfile' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ writing' ), 1 );
    test.identical( _.strCount( op.output, '.ex.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '.im.will.yml' ), 1 );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.name, 'NpmFromWillfile' );
    test.identical( config.about.version, '0.0.0' );
    test.identical( config.about.description, 'To check the conversion' );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.submodule ).length, 3 );
    test.identical( config.submodule.eslint.enabled, 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'extend unnamed willfiles with options';
    return null;
  });

  a.appStart( '.call WasPackageExtendWillfile submodulesDisabling:1 v:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ writing' ), 1 );
    test.identical( _.strCount( op.output, '.ex.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '.im.will.yml' ), 1 );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.name, 'NpmFromWillfile' );
    test.identical( config.about.version, '0.0.0' );
    test.identical( config.about.description, 'To check the conversion' );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.submodule ).length, 3 );
    test.identical( config.submodule.eslint.enabled, 0 );

    return null;
  });

  /* */

  a.appStartNonThrowing( '.call WasPackageExtendWillfile unknown:1' )
  .then( ( op ) =>
  {
    test.case = 'unknown option, should throw error';
    test.notIdentical( op.exitCode, 0 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect
      ({
        reflectMap :
        {
          [ a.abs( context.assetsOriginalPath, 'willfileFromNpm/package.json' ) ] : a.abs( 'was.package.json' ),
          [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' )
        }
      });
      return null;
    });
  }
}

//

function hookPublishCheckPackageJsonFormatting( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  let config, tagOriginal, tag, moduleName;
  a.fileProvider.dirMake( a.abs( '.' ) );

  let botUser = 'wtools-bot';
  let botRepo = 'PublishCommandTest1';
  let botPass = process.env.PRIVATE_WTOOLS_BOT_NPM_PASS;
  let botEmail = process.env.PRIVATE_WTOOLS_BOT_EMAIL;
  if( !_.process.insideTestContainer() || !botPass || !botEmail )
  return test.true( true );

  a.start = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    mode : 'spawn',
    outputGraying : 1,
    throwingExitCode : 1,
  });

  /* - */

  repoPrepare();
  setVersionInWasPackageJson();
  a.shell( 'git commit -am .' )

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is changed, should publish';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    a.fileProvider.fileAppend( a.abs( 'doc/VersionLog.txt' ), `${ config.version }\n` );
    return null;
  });

  a.appStart( `.imply withSubmodules:0 .call publish tag:latest` );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown( a.abs( 'package.json' ) );
    let moduleName = a.fileProvider.fileReadUnknown( a.abs( '.ex.will.yml' ) ).about.name;

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .call publish tag:latest"` ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 0 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 2 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `> git commit -am "."` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `> git add --all` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag latest` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'check formatting of package.json';
    return null;
  });

  a.shell( 'npm i' );
  a.shell( 'git diff' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( op.output, '' );
    return null;
  });

  /* */

  npmLogout();

  /* - */

  return a.ready;

  /* */

  function repoPrepare()
  {
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( '.' ) ); return null } );
    a.shell( `git clone https://github.com/${ botUser }/${ botRepo }.git .` );
    a.shell( 'npm i -g npm-cli-login' );
    a.shell
    ({
      execPath : `npm-cli-login -u ${ botUser } -p ${ botPass } -e ${ botEmail } --quotes`,
      outputPiping : 0,
      inputMirroring : 0
    });

    a.ready.then( () =>
    {
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });
    return a.ready;
  }

  /* */

  function setVersionInWasPackageJson()
  {
    return a.ready.then( () =>
    {
      let moduleName = botRepo.toLowerCase();
      let filePath = a.abs( 'was.package.json' );
      let config = a.fileProvider.fileReadUnknown( filePath );
      let lastVersion = _.npm.remoteVersion( `npm:///${ moduleName }!latest` );
      config.version = lastVersion;
      a.fileProvider.fileWriteUnknown({ filePath, data : config });
      return null;
    });
  }

  /* */

  function npmLogout()
  {
    a.shell( 'npm logout' );
  }
}

//

// function hookPublish2( test )
// {
//   let context = this;
//   let a = context.assetFor( test, 'gitPush' );
//
//   /* */
//
//   begin().then( () =>
//   {
//     test.case = '.with original/ .call publish2 tag:alpha dry:1 - committing and pushing';
//     a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
//     a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
//     return null;
//   })
//
//   a.appStart( '.with original/ .call publish2 tag:alpha dry:1' )
//   .then( ( op ) =>
//   {
//     test.identical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, '. Opened .' ), 1 );
//     test.identical( _.strCount( op.output, '> git add --all' ), 1 );
//     test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
//     test.identical( _.strCount( op.output, '> git push -u origin --all' ), 1 );
//     test.identical( _.strCount( op.output, '+ Publishing module::clone at' ), 1 );
//     test.identical( _.strCount( op.output, '{- Symbol maybe -}' ), 1 );
//     test.identical( _.strCount( op.output, 'Done hook::publish2 tag:alpha dry:1' ), 1 );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
//   .then( ( op ) =>
//   {
//     test.identical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, /\s\./ ), 1 );
//     return null;
//   })
//
//   /* */
//
//   a.ready.then( () =>
//   {
//     test.case = '.with original/ .call publish2 tag:alpha dry:1 - only pulling';
//     a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add --all' });
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am second' });
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
//
//   a.appStart( '.with original/ .call publish2 tag:alpha dry:1' )
//   .then( ( op ) =>
//   {
//     test.identical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, '. Opened .' ), 1 );
//     test.identical( _.strCount( op.output, '> git pull' ), 1 );
//     test.identical( _.strCount( op.output, '> git add --all' ), 0 );
//     test.identical( _.strCount( op.output, '> git commit -am "."' ), 0 );
//     test.identical( _.strCount( op.output, '> git push -u origin --all' ), 0 );
//     test.identical( _.strCount( op.output, '+ Publishing module::clone at' ), 1 );
//     test.identical( _.strCount( op.output, '{- Symbol maybe -}' ), 1 );
//     test.identical( _.strCount( op.output, 'Done hook::publish2 tag:alpha dry:1' ), 1 );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
//
//   /* */
//
//   a.ready.then( () =>
//   {
//     test.case = '.with original/ .call publish2 tag:alpha dry:1 - pulling, committing and pushing';
//     a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
//     a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add --all' });
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am third' });
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
//
//   a.appStart( '.with original/ .call publish2 tag:alpha dry:1' )
//   .then( ( op ) =>
//   {
//     test.identical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, '. Opened .' ), 1 );
//     test.identical( _.strCount( op.output, '> git pull' ), 1 );
//     test.identical( _.strCount( op.output, '> git add --all' ), 1 );
//     test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
//     test.identical( _.strCount( op.output, '> git push -u origin --all' ), 1 );
//     test.identical( _.strCount( op.output, '+ Publishing module::clone at' ), 1 );
//     test.identical( _.strCount( op.output, '{- Symbol maybe -}' ), 1 );
//     test.identical( _.strCount( op.output, 'Done hook::publish2 tag:alpha dry:1' ), 1 );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
//
//   /* */
//
//   a.ready.then( () =>
//   {
//     test.case = '.with original/ .call publish2 tag:alpha dry:1 force:1 - forced pulling, committing and pushing';
//     a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
//     a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add --all' });
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am fourth' });
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
//
//   a.appStart( '.with original/ .call publish2 tag:alpha dry:1 force:1' )
//   .then( ( op ) =>
//   {
//     test.identical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, '. Opened .' ), 1 );
//     test.identical( _.strCount( op.output, '> git pull' ), 1 );
//     test.identical( _.strCount( op.output, '> git add --all' ), 1 );
//     test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
//     test.identical( _.strCount( op.output, '> git push -u origin --all' ), 1 );
//     test.identical( _.strCount( op.output, '+ Publishing module::clone at' ), 1 );
//     test.identical( _.strCount( op.output, '{- Symbol maybe -}' ), 0 );
//     test.identical( _.strCount( op.output, 'Done hook::publish2 tag:alpha dry:1' ), 1 );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
//
//   /* */
//
//   a.appStart( '.with original/ .call publish2 tag:alpha dry:1 force:1' )
//   a.appStart( '.with original/ .call publish2 tag:alpha dry:1 force:1' )
//   .then( ( op ) =>
//   {
//     test.case = '.with original/ .call publish2 tag:alpha dry:1 - nothing to publish';
//     test.identical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, '. Opened .' ), 1 );
//     test.identical( _.strCount( op.output, '> git pull' ), 0 );
//     test.identical( _.strCount( op.output, '> git add --all' ), 0 );
//     test.identical( _.strCount( op.output, '> git commit -am "."' ), 0 );
//     test.identical( _.strCount( op.output, '> git push -u origin --all' ), 0 );
//     test.identical( _.strCount( op.output, '+ Publishing module::clone at' ), 1 );
//     test.identical( _.strCount( op.output, '{- Symbol maybe -}' ), 0 );
//     test.identical( _.strCount( op.output, ' x Nothing to publish in clone' ), 0 );
//     test.identical( _.strCount( op.output, 'Done hook::publish2 tag:alpha dry:1' ), 1 );
//     return null;
//   })
//   a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
//
//   /* - */
//
//   a.appStartNonThrowing( '.with original/ .call publish2' )
//   .then( ( op ) =>
//   {
//     test.case = 'without option `tag`, should throw error';
//     test.notIdentical( op.exitCode, 0 );
//     test.identical( _.strCount( op.output, 'Expects option {-tag-}' ), 1 );
//
//     return null;
//   });
//
//   /* - */
//
//   return a.ready;
//
//   /* */
//
//   function begin()
//   {
//     a.ready.then( () =>
//     {
//       a.reflect();
//       a.fileProvider.dirMake( a.abs( 'repo' ) );
//       return null;
//     });
//     a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
//     let currentPath = a.abs( 'original' );
//     a.shell({ currentPath, execPath : 'git init' });
//     a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
//     a.shell({ currentPath, execPath : 'git add --all' });
//     a.shell({ currentPath, execPath : 'git commit -am first' });
//     a.shell({ currentPath, execPath : 'git push -u origin --all' });
//     a.shell( 'git clone repo/ clone' );
//     return a.ready;
//   }
// }

//

function verbositySet( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply verbosity:3 ; .build' });
  a.ready.finally( ( err, op ) =>
  {
    test.case = '.imply verbosity:3 ; .build';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )

    test.identical( _.strCount( op.output, '.imply verbosity:3 ; .build' ), 1 );
    test.identical( _.strCount( op.output, / \. Opened .+\/\.im\.will\.yml/ ), 1 );
    test.identical( _.strCount( op.output, / \. Opened .+\/\.ex\.will\.yml/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open module::submodules / relation::ModuleForTesting1' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open module::submodules / relation::ModuleForTesting2a' ), 0 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, /Building .*module::submodules \/ build::debug\.raw.*/ ), 1 );
    test.identical( _.strCount( op.output, ' + 2/2 submodule(s) of module::submodules were downloaded' ), 1 );
    test.identical( _.strCount( op.output, ' + 0/2 submodule(s) of module::submodules were downloaded' ), 0 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, / - .*step::delete.out.debug.* deleted 0 file\(s\)/ ), 1 );
    test.identical( _.strCount( op.output, ' + reflector::reflect.proto.debug reflected 2 file(s)' ), 1 );
    test.identical( _.strCount( op.output, ' + reflector::reflect.submodules reflected' ), 1 );
    test.identical( _.strCount( op.output, /Built .*module::submodules \/ build::debug\.raw.*/ ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply verbosity:2 ; .build' });
  a.ready.finally( ( err, op ) =>
  {
    test.case = '.imply verbosity:2 ; .build';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )

    test.identical( _.strCount( op.output, '.imply verbosity:2 ; .build' ), 1 );
    test.identical( _.strCount( op.output, / \. Opened .+\/\.im\.will\.yml/ ), 0 );
    test.identical( _.strCount( op.output, / \. Opened .+\/\.ex\.will\.yml/ ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open relation::ModuleForTesting1' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open relation::ModuleForTesting2a' ), 0 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, /Building .*module::submodules \/ build::debug\.raw.*/ ), 1 );
    test.identical( _.strCount( op.output, ' + 2/2 submodule(s) of module::submodules were downloaded' ), 1 );
    test.identical( _.strCount( op.output, ' + 0/2 submodule(s) of module::submodules were downloaded' ), 0 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, / - .*step::delete.out.debug.* deleted 0 file\(s\)/ ), 1 );
    test.identical( _.strCount( op.output, ' + reflector::reflect.proto.debug reflected 2 file(s)' ), 1 );
    test.identical( _.strCount( op.output, ' + reflector::reflect.submodules reflected' ), 1 );
    test.identical( _.strCount( op.output, /Built .*module::submodules \/ build::debug\.raw.*/ ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply verbosity:1 ; .build' });
  a.ready.finally( ( err, op ) =>
  {
    test.case = '.imply verbosity:1 ; .build';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )

    test.identical( _.strCount( op.output, '.imply verbosity:1 ; .build' ), 1 );
    test.identical( _.strCount( op.output, / \. Opened .+\/\.im\.will\.yml/ ), 0 );
    test.identical( _.strCount( op.output, / \. Opened .+\/\.ex\.will\.yml/ ), 0 );
    test.identical( _.strCount( op.output, ' ! Failed to open relation::ModuleForTesting1' ), 0 );
    test.identical( _.strCount( op.output, ' ! Failed to open relation::ModuleForTesting2a' ), 0 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 0 );

    test.identical( _.strCount( op.output, /Building .*module::submodules \/ build::debug\.raw.*/ ), 0 );
    test.identical( _.strCount( op.output, ' + 2/2 submodule(s) of module::submodules were downloaded' ), 0 );
    test.identical( _.strCount( op.output, ' + 0/2 submodule(s) of module::submodules were downloaded' ), 0 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 0 );
    test.identical( _.strCount( op.output, ' - Deleted' ), 0 );
    test.identical( _.strCount( op.output, ' + reflect.proto.debug reflected 2 file(s) ' ), 0 )
    test.identical( _.strCount( op.output, ' + reflect.submodules reflected' ), 0 );
    test.identical( _.strCount( op.output, /Built .*module::submodules \/ build::debug\.raw.*/ ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

verbositySet.timeOut = 600000;

//

/*
  Check verbosity field of step::files.delete.
  Check logging of step::files.delete.
*/

function verbosityStepDelete( test )
{
  let context = this;
  let a = context.assetFor( test, 'verbosityStepDelete' );
  a.appStart = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    mode : 'spawn',
    ready : a.ready,
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.build files.delete.vd';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.build files.delete.vd' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 0 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 0 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.vd.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 1 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.build files.delete.v0';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.build files.delete.v0' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 0 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 0 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v0.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, 'Deleted' ), 0 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.build files.delete.v1';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.build files.delete.v1' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 0 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 0 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v1.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 1 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.build files.delete.v3';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.build files.delete.v3' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 1 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 1 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 1 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v3.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 1 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.imply v:0 ; .build files.delete.vd';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.imply v:0 ; .build files.delete.vd' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 0 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 0 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.vd.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.true( 2 <=_.strLinesCount( op.output ) && _.strLinesCount( op.output ) <= 3 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.imply v:8 ; .build files.delete.v0';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.imply v:8 ; .build files.delete.v0' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 0 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 0 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v0.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 0 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.imply v:9 ; .build files.delete.v0';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.imply v:9 ; .build files.delete.v0' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 1 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 1 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 1 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v0.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 1 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.imply v:1 ; .build files.delete.v3';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.imply v:1 ; .build files.delete.v3' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 0 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 0 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 0 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v3.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 1 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.imply v:2 ; .build files.delete.v3';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.imply v:2 ; .build files.delete.v3' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'proto' ) ) );

    test.identical( _.strCount( op.output, /3 at .*\/verbosityStepDelete\/proto\// ), 1 );
    test.identical( _.strCount( op.output, '2 at ./A' ), 1 );
    test.identical( _.strCount( op.output, '1 at ./B' ), 1 );
    test.identical( _.strCount( op.output, /- .*step::files.delete.v3.* deleted 3 file\(s\), at .*\/verbosityStepDelete\/proto\// ), 1 );

    var files = a.find( a.abs( 'proto' ) );
    test.identical( files, [ '.' ] );

    return null;
  })

  /* - */

  return a.ready;
}

verbosityStepDelete.timeOut = 600000;
verbosityStepDelete.rapidity = -1;

//

/*
  Checks printing name of step before it execution
*/

function verbosityStepPrintName( test )
{
  let context = this;
  let a = context.assetFor( test, 'verbosityStepPrintName' );
  a.appStart = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    mode : 'spawn',
    ready : a.ready,
  })

  /* - */

  a.ready
  .then( ( arg ) =>
  {
    a.reflect();
    return arg;
  })

  a.appStart({ execPath : '.imply v:4 ; .build' })

  .then( ( op ) =>
  {
    test.description = '.imply v:4 ; .build';

    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Building .*module::verbosityStepPrintName \/ build::debug/ ), 1 );
    test.identical( _.strCount( op.output, /: .*reflector::reflect.file.*/ ), 1 );
    test.identical( _.strCount( op.output, '+ reflector::reflect.file reflected 1 file(s)' ), 1 );
    test.identical( _.strCount( op.output, '/verbosityStepPrintName/ : ./out <- ./file in' ), 1 );
    test.identical( _.strCount( op.output, /.*>.*node -e "console.log\( 'shell.step' \)"/ ), 1 );
    test.identical( _.strCount( op.output, /at.* .*verbosityStepPrintName/ ), 2 );
    test.identical( _.strCount( op.output, 'shell.step' ), 2 );
    test.identical( _.strCount( op.output, /: .*step::delete.step.*/ ), 1 );
    test.identical( _.strCount( op.output, /1 at .*\/out/ ), 1 );
    test.identical( _.strCount( op.output, /1 at \./ ), 1 );
    test.identical( _.strCount( op.output, /- .*step::delete.step.* deleted 1 file\(s\), at .*verbosityStepPrintName\/out.*/ ), 1 );
    test.identical( _.strCount( op.output, /Built .*module::verbosityStepPrintName \/ build::debug.* in / ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( ( arg ) =>
  {
    a.reflect();
    return arg;
  })

  a.appStart({ execPath : '.imply v:3 ; .build' })

  .then( ( op ) =>
  {
    test.description = '.imply v:3 ; .build';

    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Building .*module::verbosityStepPrintName \/ build::debug/ ), 1 );
    test.identical( _.strCount( op.output, /: .*reflector::reflect.file.*/ ), 0 );
    test.identical( _.strCount( op.output, '+ reflector::reflect.file reflected 1 file(s)' ), 1 );
    test.identical( _.strCount( op.output, '/verbosityStepPrintName/ : ./out <- ./file' ), 1 );
    test.identical( _.strCount( op.output, /.*>.*node -e "console.log\( 'shell.step' \)"/ ), 1 );
    test.identical( _.strCount( op.output, /at.* .*verbosityStepPrintName/ ), 1 );
    test.identical( _.strCount( op.output, 'shell.step' ), 2 );
    test.identical( _.strCount( op.output, /: .*step::delete.step.*/ ), 0 );
    test.identical( _.strCount( op.output, /1 at .*\/out/ ), 0 );
    test.identical( _.strCount( op.output, /1 at \./ ), 0 );
    test.identical( _.strCount( op.output, /- .*step::delete.step.* deleted 1 file\(s\), at .*verbosityStepPrintName\/out.*/ ), 1 );
    test.identical( _.strCount( op.output, /Built .*module::verbosityStepPrintName \/ build::debug.* in / ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( ( arg ) =>
  {
    a.reflect();
    return arg;
  })

  a.appStart({ execPath : '.imply v:2 ; .build' })

  .then( ( op ) =>
  {
    test.description = '.imply v:2 ; .build';

    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Building .*module::verbosityStepPrintName \/ build::debug/ ), 1 );
    test.identical( _.strCount( op.output, /: .*reflector::reflect.file.*/ ), 0 );
    test.identical( _.strCount( op.output, ' + reflector::reflect.file reflected 1 file(s)' ), 1 );
    test.identical( _.strCount( op.output, '/verbosityStepPrintName/ : ./out <- ./file in' ), 1 );
    test.identical( _.strCount( op.output, /.*>.*node -e "console.log\( 'shell.step' \)"/ ), 1 );
    test.identical( _.strCount( op.output, /at.* .*verbosityStepPrintName/ ), 1 );
    test.identical( _.strCount( op.output, 'shell.step' ), 1 );
    test.identical( _.strCount( op.output, /: .*step::delete.step.*/ ), 0 );
    test.identical( _.strCount( op.output, /1 at .*\/out/ ), 0 );
    test.identical( _.strCount( op.output, /1 at \./ ), 0 );
    test.identical( _.strCount( op.output, /- .*step::delete.step.* deleted 1 file\(s\), at .*verbosityStepPrintName\/out.*/ ), 1 );
    test.identical( _.strCount( op.output, /Built .*module::verbosityStepPrintName \/ build::debug.* in / ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( ( arg ) =>
  {
    a.reflect();
    return arg;
  })

  a.appStart({ execPath : '.imply v:1 ; .build' })

  .then( ( op ) =>
  {
    test.description = '.imply v:1 ; .build';

    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Building .*module::verbosityStepPrintName \/ build::debug/ ), 0 );
    test.identical( _.strCount( op.output, /: .*reflector::reflect.file.*/ ), 0 );
    test.identical( _.strCount( op.output, ' + reflector::reflect.file.* reflected 1 file(s) .* : .*out.* <- .*file.* in ' ), 0 );
    test.identical( _.strCount( op.output, /.*>.*node -e "console.log\( 'shell.step' \)"/ ), 0 );
    test.identical( _.strCount( op.output, /at.* .*verbosityStepPrintName/ ), 0 );
    test.identical( _.strCount( op.output, 'shell.step' ), 0 );
    test.identical( _.strCount( op.output, /: .*step::delete.step.*/ ), 0 );
    test.identical( _.strCount( op.output, /1 at .*\/out/ ), 0 );
    test.identical( _.strCount( op.output, /1 at \./ ), 0 );
    test.identical( _.strCount( op.output, /- .*step::delete.step.* deleted 1 file\(s\), at .*verbosityStepPrintName\/out.*/ ), 0 );
    test.identical( _.strCount( op.output, /Built .*module::verbosityStepPrintName \/ build::debug.* in / ), 1 );

    return null;
  })

  /* - */

  /*
  Building module::verbosityStepPrintName / build::debug
   : reflector::reflect.file
   + reflector::reflect.file reflected 1 file(s) /C/pro/web/Dave/git/trunk/builder/include/wtools/atop/will.test/asset/verbosityStepPrintName/ : out <- file in 0.290s
 > node -e "console.log( 'shell.step' )"
   at /C/pro/web/Dave/git/trunk/builder/include/wtools/atop/will.test/asset/verbosityStepPrintName
shell.step
   : step::delete.step
     1 at /C/pro/web/Dave/git/trunk/builder/include/wtools/atop/will.test/asset/verbosityStepPrintName/out
     1 at .
   - step::delete.step deleted 1 file(s), at /C/pro/web/Dave/git/trunk/builder/include/wtools/atop/will.test/asset/verbosityStepPrintName/out0.017s
  Built module::verbosityStepPrintName / build::debug in 0.643s
  */

  return a.ready;
} /* end of function verbosityStepPrintName */

verbosityStepPrintName.rapidity = -1;

//

function modulesTreeDotless( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoDotlessSingleExported' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply v:1 ; .modules.tree withLocalPath:1';
    return null;
  });

  a.appStart({ execPath : '.imply v:1 ; .modules.tree withLocalPath:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+-- module::' ), 2 );
    test.identical( _.strCount( op.output, 'modulesTreeDotless/' ), 2 );
    test.identical( _.strCount( op.output, 'modulesTreeDotless/sub' ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.modules.tree withLocalPath:1'
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .modules.tree withLocalPath:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+-- module::' ), 2 );
    test.identical( _.strCount( op.output, 'modulesTreeDotless/' ), 4 );
    test.identical( _.strCount( op.output, 'modulesTreeDotless/sub' ), 2 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function modulesTreeLocal( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmodules' );

  /* - */

  begin().then( () =>
  {
    test.case = '.imply v:1 ; .with */* .modules.tree';
    return null;
  });

  a.appStart({ execPath : '.imply v:1 ; .with */* .modules.tree' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '-- module::' ), 19 );

    let exp =
`
Command ".imply v:1 ; .with */* .modules.tree"
 +-- module::module-x
 |
 +-- module::module-ab-named
 | +-- module::module-a
 | +-- module::module-b
 |
 +-- module::module-bc-named
 | +-- module::module-b
 | +-- module::module-c
 |
 +-- module::module-aabc
 | +-- module::module-a
 | +-- module::module-ab
 | | +-- module::module-a
 | | +-- module::module-b
 | +-- module::module-c
 |
 +-- module::module-abac
   +-- module::module-ab
   | +-- module::module-a
   | +-- module::module-b
   +-- module::module-a
   +-- module::module-c
`

    test.equivalent( op.output, exp );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.fileWrite( a.abs( 'proto/b/-Excluded.js' ), 'console.log( \'b/-Ecluded.js\' );' );
      return null;
    });
  }
}

//

function modulesTreeHierarchyRemote( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( '.module' ) );
  let submodulesZ = a.fileProvider.fileReadUnknown( a.abs( 'z.will.yml' ) ).submodule;
  let submodulesA = a.fileProvider.fileReadUnknown( a.abs( 'group1/a.will.yml' ) ).submodule;
  let submodulesB = a.fileProvider.fileReadUnknown( a.abs( 'group1/b.will.yml' ) ).submodule;
  let submodulesA0 = a.fileProvider.fileReadUnknown( a.abs( 'group1/group10/a0.will.yml' ) ).submodule;
  let submodulesC = a.fileProvider.fileReadUnknown( a.abs( 'group2/c.will.yml' ) ).submodule;
  let keysZ = _.props.keys( submodulesZ );
  let keysA = _.props.keys( submodulesA );
  let keysB = _.props.keys( submodulesB );
  let keysA0 = _.props.keys( submodulesA0 );
  let keysC = _.props.keys( submodulesC );

  /* - */

  a.appStart({ execPath : '.imply withSubmodules:2 .with * .modules.tree' })
  .then( ( op ) =>
  {
    test.case = '.with * .modules.tree';
    test.identical( op.exitCode, 0 );

    let exp =
`
 +-- module::z
   +-- module::${ keysZ[ 0 ] }
   | +-- module::${ keysA[ 0 ] }
   | +-- module::${ keysA[ 1 ] }
   | +-- module::${ keysA[ 2 ] }
   |   +-- module::${ keysA0[ 0 ] }
   |   +-- module::${ keysA0[ 1 ] }
   +-- module::${ keysZ[ 1 ] }
   | +-- module::${ keysB[ 0 ] }
   | +-- module::${ keysB[ 1 ] }
   +-- module::${ keysZ[ 2 ] }
   | +-- module::${ keysC[ 0 ] }
   | | +-- module::${ keysA0[ 0 ] }
   | | +-- module::${ keysA0[ 1 ] }
   | +-- module::${ keysC[ 1 ] }
   +-- module::${ keysZ[ 3 ] }
`;

    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 16 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 5 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.imply withSubmodules:2 .with * .modules.tree withRemotePath:1' })
  .then( ( op ) =>
  {
    test.case = '.with * .modules.tree withRemotePath:1';
    test.identical( op.exitCode, 0 );

    let exp =
`
 +-- module::z
   +-- module::${ keysZ[ 0 ] }
   | +-- module::${ keysA[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesA[ keysA[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysA[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesA[ keysA[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysA[ 2 ] }
   |   +-- module::${ keysA0[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   |   +-- module::${ keysA0[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   +-- module::${ keysZ[ 1 ] }
   | +-- module::${ keysB[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesB[ keysB[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysB[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesB[ keysB[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   +-- module::${ keysZ[ 2 ] }
   | +-- module::${ keysC[ 0 ] }
   | | +-- module::${ keysA0[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | | +-- module::${ keysA0[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysC[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group2' ), submodulesC[ keysC[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   +-- module::${ keysZ[ 3 ] } - path::remote:=${ a.abs( submodulesZ[ keysZ[ 3 ] ] ).replace( /\/(!.*$)/, '$1' ) }
`;

    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 16 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 5 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.imply withSubmodules:2 .with * .modules.tree withLocalPath:1' })
  .then( ( op ) =>
  {
    test.case = '.with * .modules.tree withLocalPath:1';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, '+-- module::' ), 16 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 5 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.imply withSubmodules:2 .with ** .modules.tree' })
  .then( ( op ) =>
  {
    test.case = '.with ** .modules.tree';
    test.identical( op.exitCode, 0 );

    let exp =
`
 +-- module::z
   +-- module::${ keysZ[ 0 ] }
   | +-- module::${ keysA[ 0 ] }
   | +-- module::${ keysA[ 1 ] }
   | +-- module::${ keysA[ 2 ] }
   |   +-- module::${ keysA0[ 0 ] }
   |   +-- module::${ keysA0[ 1 ] }
   +-- module::${ keysZ[ 1 ] }
   | +-- module::${ keysB[ 0 ] }
   | +-- module::${ keysB[ 1 ] }
   +-- module::${ keysZ[ 2 ] }
   | +-- module::${ keysC[ 0 ] }
   | | +-- module::${ keysA0[ 0 ] }
   | | +-- module::${ keysA0[ 1 ] }
   | +-- module::${ keysC[ 1 ] }
   +-- module::${ keysZ[ 3 ] }
`;

    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 16 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 5 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.imply withSubmodules:2 .with ** .modules.tree withRemotePath:1' })
  .then( ( op ) =>
  {
    test.case = '.with ** .modules.tree withRemotePath:1';
    test.identical( op.exitCode, 0 );

    let exp =
`
 +-- module::z
   +-- module::${ keysZ[ 0 ] }
   | +-- module::${ keysA[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesA[ keysA[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysA[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesA[ keysA[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysA[ 2 ] }
   |   +-- module::${ keysA0[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   |   +-- module::${ keysA0[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   +-- module::${ keysZ[ 1 ] }
   | +-- module::${ keysB[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesB[ keysB[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysB[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1' ), submodulesB[ keysB[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   +-- module::${ keysZ[ 2 ] }
   | +-- module::${ keysC[ 0 ] }
   | | +-- module::${ keysA0[ 0 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 0 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | | +-- module::${ keysA0[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group1/group10' ), submodulesA0[ keysA0[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   | +-- module::${ keysC[ 1 ] } - path::remote:=${ a.abs( a.abs( 'group2' ), submodulesC[ keysC[ 1 ] ] ).replace( /\/(!.*$)/, '$1' ) }
   +-- module::${ keysZ[ 3 ] } - path::remote:=${ a.abs( submodulesZ[ keysZ[ 3 ] ] ).replace( /\/(!.*$)/, '$1' ) }
`;

    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 16 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 5 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.imply withSubmodules:2 .with ** .modules.tree withLocalPath:1' })
  .then( ( op ) =>
  {
    test.case = '.with ** .modules.tree withLocalPath:1';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, '+-- module::' ), 16 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 5 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

modulesTreeHierarchyRemote.rapidity = -1;
modulesTreeHierarchyRemote.timeOut = 300000;

//

function modulesTreeHierarchyRemoteDownloaded( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( '.module' ) );
  let submodulesZ = a.fileProvider.fileReadUnknown( a.abs( 'z.will.yml' ) ).submodule;
  let submodulesA = a.fileProvider.fileReadUnknown( a.abs( 'group1/a.will.yml' ) ).submodule;
  let submodulesB = a.fileProvider.fileReadUnknown( a.abs( 'group1/b.will.yml' ) ).submodule;
  let submodulesA0 = a.fileProvider.fileReadUnknown( a.abs( 'group1/group10/a0.will.yml' ) ).submodule;
  let submodulesC = a.fileProvider.fileReadUnknown( a.abs( 'group2/c.will.yml' ) ).submodule;
  let keysZ = _.props.keys( submodulesZ );
  let keysA = _.props.keys( submodulesA );
  let keysB = _.props.keys( submodulesB );
  let keysA0 = _.props.keys( submodulesA0 );
  let keysC = _.props.keys( submodulesC );

  /* - */

  a.appStart({ execPath : '.with * .submodules.download recursive:2' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with * .modules.tree withRemotePath:1' });
  a.ready.then( ( op ) =>
  {
    test.case = '.with * .modules.tree withRemotePath:1';
    test.identical( op.exitCode, 0 );

    let exp =
`
 +-- module::z
   +-- module::a
   | +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git!gamma
   | | +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   | | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   | | +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::a0
   |   +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   |   | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   |   | +-- module::Testing - path::remote:=npm:///wTesting
   |   +-- module::wModuleForTesting2a - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2a.git/
   |     +-- module::ModuleForTesting2 - path::remote:=git+https://${ a.path.current() }/group1/group10/.module/ModuleForTesting2a/github.com/Wandalen/wModuleForTesting2.git!gamma
   |     +-- module::Testing - path::remote:=npm:///wTesting
   +-- module::b
   | +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   | | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   | | +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::wModuleForTesting12 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting12.git/
   |   +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git!gamma
   |   +-- module::ModuleForTesting2 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2.git!gamma
   |   +-- module::Testing - path::remote:=npm:///wTesting
   +-- module::c
   | +-- module::a0
   | | +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   | | | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   | | | +-- module::Testing - path::remote:=npm:///wTesting
   | | +-- module::wModuleForTesting2a - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2a.git/
   | |   +-- module::ModuleForTesting2 - path::remote:=git+https://${ a.path.current() }/group1/group10/.module/ModuleForTesting2a/github.com/Wandalen/wModuleForTesting2.git!gamma
   | |   +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::wModuleForTesting12ab - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting12ab.git/
   |   +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   |   +-- module::ModuleForTesting1a - path::remote:=npm:///wmodulefortesting1a!gamma
   |   +-- module::ModuleForTesting1b - path::remote:=npm:///wmodulefortesting1b!gamma
   |   +-- module::ModuleForTesting2 - path::remote:=npm:///wmodulefortesting2!gamma
   |   +-- module::ModuleForTesting2a - path::remote:=npm:///wmodulefortesting2a!gamma
   |   +-- module::ModuleForTesting2b - path::remote:=npm:///wmodulefortesting2b!gamma
   |   +-- module::ModuleForTesting12 - path::remote:=npm:///wmodulefortesting12!gamma
   |   +-- module::Testing - path::remote:=npm:///wTesting
   +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
     +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
     +-- module::Testing - path::remote:=npm:///wTesting
`;

    console.log( op.output );
    console.log( exp );
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 67 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 11 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting2a' ), 8 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

modulesTreeHierarchyRemoteDownloaded.timeOut = 300000;

//

/*
cls && will.local .with group1/group10/a0 .clean recursive:2 && will.local .with group1/group10/a0 .export && local-debug-will .with group1/a .export
*/

function modulesTreeHierarchyRemotePartiallyDownloaded( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( '.module' ) );

  /* - */

  a.appStart({ execPath : '.with group1/group10/a0 .export' });
  a.appStart({ execPath : '.with group1/a .export' });
  a.appStart({ execPath : '.with * .modules.tree withRemotePath:1' });

  a.ready.then( ( op ) =>
  {
    test.case = '.imply withSubmodules:2 .with * .modules.tree withRemotePath:1';
    test.identical( op.exitCode, 0 );

    let exp =
`
 +-- module::z
   +-- module::a
   | +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git!gamma
   | | +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   | | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   | | +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::a0
   |   +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   |   | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   |   | +-- module::Testing - path::remote:=npm:///wTesting
   |   +-- module::wModuleForTesting2a - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2a.git/
   |     +-- module::ModuleForTesting2 - path::remote:=git+https://${ a.path.current() }/group1/group10/.module/ModuleForTesting2a/github.com/Wandalen/wModuleForTesting2.git!gamma
   |     +-- module::Testing - path::remote:=npm:///wTesting
   +-- module::b
   | +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   | | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   | | +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::wModuleForTesting12 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting12.git/
   |   +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git!gamma
   |   +-- module::ModuleForTesting2 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2.git!gamma
   |   +-- module::Testing - path::remote:=npm:///wTesting
   +-- module::c
   | +-- module::a0
   | | +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
   | | | +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   | | | +-- module::Testing - path::remote:=npm:///wTesting
   | | +-- module::wModuleForTesting2a - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2a.git/
   | |   +-- module::ModuleForTesting2 - path::remote:=git+https://${ a.path.current() }/group1/group10/.module/ModuleForTesting2a/github.com/Wandalen/wModuleForTesting2.git!gamma
   | |   +-- module::Testing - path::remote:=npm:///wTesting
   | +-- module::wModuleForTesting12ab - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting12ab.git/
   |   +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
   |   +-- module::ModuleForTesting1a - path::remote:=npm:///wmodulefortesting1a!gamma
   |   +-- module::ModuleForTesting1b - path::remote:=npm:///wmodulefortesting1b!gamma
   |   +-- module::ModuleForTesting2 - path::remote:=npm:///wmodulefortesting2!gamma
   |   +-- module::ModuleForTesting2a - path::remote:=npm:///wmodulefortesting2a!gamma
   |   +-- module::ModuleForTesting2b - path::remote:=npm:///wmodulefortesting2b!gamma
   |   +-- module::ModuleForTesting12 - path::remote:=npm:///wmodulefortesting12!gamma
   |   +-- module::Testing - path::remote:=npm:///wTesting
   +-- module::wModuleForTesting1b - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1b.git/
     +-- module::ModuleForTesting1 - path::remote:=npm:///wmodulefortesting1!gamma
     +-- module::Testing - path::remote:=npm:///wTesting
`

    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 58 );
    test.identical( _.strCount( op.output, '+-- module::z' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::a' ), 3 );
    test.identical( _.strCount( op.output, '+-- module::a0' ), 2 );
    test.identical( _.strCount( op.output, '+-- module::b' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::c' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::wModuleForTesting1' ), 9 );
    test.identical( _.strCount( op.output, '+-- module::wModuleForTesting1b' ), 10 );
    test.identical( _.strCount( op.output, '+-- module::wModuleForTesting2a' ), 7 );
    test.identical( _.strCount( op.output, '+-- module::wModuleForTesting12' ), 0 ); /* xxx */
    test.identical( _.strCount( op.output, '+-- module::wModuleForTesting12ab' ), 0 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1' ), 0 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting1b' ), 0 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting2a' ), 0 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::ModuleForTesting12ab' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

modulesTreeHierarchyRemotePartiallyDownloaded.timeOut = 300000;

//

function modulesTreeDisabledAndCorrupted( test )
{
  let context = this;
  let a = context.assetFor( test, 'manyFew' );
  a.reflectMinimal();

  /* - */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.submodules.download' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with ** .modules.tree withRemotePath:1' });

  a.ready.then( ( op ) =>
  {
    test.case = '.with * .modules.tree withRemotePath:1';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( '.im.will.yml' ) );

/*
 +-- module::many
 | +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git/!delta
 | +-- module::wModuleForTesting2 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2.git/!delta
 | | +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git/!delta
 | +-- module::wModuleForTesting12 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting12.git/!delta
 |   +-- module::wModuleForTesting1 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting1.git/!delta
 |   +-- module::wModuleForTesting2 - path::remote:=git+https:///github.com/Wandalen/wModuleForTesting2.git/!delta
 |
 +-- module::corrupted
*/

    test.identical( _.strCount( op.output, 'git+https:///github.com/Wandalen/wModuleForTesting1.git' ), 3 );
    test.ge( _.strCount( op.output, /git\+https\:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git!\w+/ ), 1 );
    test.identical( _.strCount( op.output, 'git+https:///github.com/Wandalen/wModuleForTesting2.git' ), 2 );
    test.ge( _.strCount( op.output, /git\+https\:\/\/\/github\.com\/Wandalen\/wModuleForTesting2\.git!\w+/ ), 1 );
    test.identical( _.strCount( op.output, 'git+https:///github.com/Wandalen/wModuleForTesting12.git' ), 1 );
    test.identical( _.strCount( op.output, '+-- module::' ), 8 );
    test.identical( _.strCount( op.output, /\+-- module::.* - path::remote:=/ ), 6 );

    return null;
  });

  /* - */

  return a.ready;
}

modulesTreeDisabledAndCorrupted.timeOut = 300000;

//

function listSingleModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'single' );
  a.appStart = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    mode : 'spawn',
    ready : a.ready,
  })
  a.reflect();

  /* - */

  a.appStart({ execPath : '.resources.list' })
  .then( ( op ) =>
  {
    test.case = 'list';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `name : 'single'` ) );
    test.true( _.strHas( op.output, `description : 'Module for testing'` ) );
    test.true( _.strHas( op.output, `version : '0.0.1'` ) );
    return null;
  })

  /* - */

  a.appStart({ execPath : '.about.list' })
  .then( ( op ) =>
  {
    test.case = '.about.list'

    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, `name : 'single'` ));
    test.true( _.strHas( op.output, `description : 'Module for testing'` ));
    test.true( _.strHas( op.output, `version : '0.0.1'` ));
    test.true( _.strHas( op.output, `enabled : 1` ));
    test.true( _.strHas( op.output, `interpreters :` ));
    test.true( _.strHas( op.output, `'nodejs >= 10.0.0'` ));
    test.true( _.strHas( op.output, `'chrome >= 60.0.0'` ));
    test.true( _.strHas( op.output, `'firefox >= 60.0.0'` ));
    test.true( _.strHas( op.output, `'nodejs >= 10.0.0'` ));
    test.true( _.strHas( op.output, `keywords :` ));
    test.true( _.strHas( op.output, `'wModuleForTesting1'` ));

    return null;
  })

  /* - */

  a.appStart({ execPath : '.paths.list' })
  .then( ( op ) =>
  {
    test.case = '.paths.list';
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, `proto : proto` ) );
    test.true( _.strHas( op.output, `in : .` ) );
    test.true( _.strHas( op.output, `out : out` ) );
    test.true( _.strHas( op.output, `out.debug : out/debug` ) );
    test.true( _.strHas( op.output, `out.release : out/release` ) );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.paths.list predefined:1' })
  .then( ( op ) =>
  {
    test.case = '.paths.list predefined:1';
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, `module.willfiles :` ) );
    test.true( _.strHas( op.output, `module.peer.willfiles :` ) );
    test.true( _.strHas( op.output, `module.dir : /` ) );
    test.true( _.strHas( op.output, `module.common : /` ) );
    test.true( _.strHas( op.output, `local : /` ) );
    test.true( _.strHas( op.output, `will :` ) );
    test.true( !_.strHas( op.output, `proto : proto` ) );
    test.true( !_.strHas( op.output, `in : .` ) );
    test.true( !_.strHas( op.output, `out : out` ) );
    test.true( !_.strHas( op.output, `out.debug : out/debug` ) );
    test.true( !_.strHas( op.output, `out.release : out/release` ) );
    test.identical( _.strCount( op.output, ':' ), 12 );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.paths.list predefined:0' })
  .then( ( op ) =>
  {
    test.case = '.paths.list predefined:0';
    test.identical( op.exitCode, 0 );

    test.true( !_.strHas( op.output, `module.willfiles :` ) );
    test.true( !_.strHas( op.output, `module.peer.willfiles :` ) );
    test.true( !_.strHas( op.output, `module.dir : .` ) );
    test.true( !_.strHas( op.output, `module.common : ./` ) );
    test.true( !_.strHas( op.output, `local : .` ) );
    test.true( !_.strHas( op.output, `will :` ) );
    test.true( _.strHas( op.output, `proto : proto` ) );
    test.true( _.strHas( op.output, `in : .` ) );
    test.true( _.strHas( op.output, `out : out` ) );
    test.true( _.strHas( op.output, `out.debug : out/debug` ) );
    test.true( _.strHas( op.output, `out.release : out/release` ) );
    test.identical( _.strCount( op.output, ':' ), 6 );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.submodules.list' })
  .then( ( op ) =>
  {
    test.case = 'submodules list'
    test.identical( op.exitCode, 0 );
    test.true( op.output.length >= 1 );
    return null;
  })

  /* - */

  a.appStart({ execPath : '.reflectors.list' })
  .then( ( op ) =>
  {
    test.case = 'reflectors.list'
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'reflector::reflect.proto.' ) );
    test.true( _.strHas( op.output, `path::proto : path::out.*=1` ) );
    test.true( _.strHas( op.output, `reflector::reflect.proto.debug` ) );
    test.true( _.strHas( op.output, `path::proto : path::out.*=1` ) );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.steps.list' })
  .then( ( op ) =>
  {
    test.case = 'steps.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'step::reflect.proto.' ))
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ))
    test.true( _.strHas( op.output, 'step::reflect.proto.raw' ))
    test.true( _.strHas( op.output, 'step::reflect.proto.debug.raw' ))
    test.true( _.strHas( op.output, 'step::export.proto' ))

    return null;
  })

  /* - */

  a.appStart({ execPath : '.builds.list' })
  .then( ( op ) =>
  {
    test.case = '.builds.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'build::debug.raw' ));
    test.true( _.strHas( op.output, 'build::debug.compiled' ));
    test.true( _.strHas( op.output, 'build::release.raw' ));
    test.true( _.strHas( op.output, 'build::release.compiled' ));
    test.true( _.strHas( op.output, 'build::all' ));

    return null;
  })

  /* - */

  a.appStart({ execPath : '.exports.list' })
  .then( ( op ) =>
  {
    test.case = '.exports.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'build::proto.export' ));
    test.true( _.strHas( op.output, 'steps : ' ));
    test.true( _.strHas( op.output, 'build::debug.raw' ));
    test.true( _.strHas( op.output, 'step::export.proto' ));

    return null;
  })

  /* - */ /* To test output by command with glob and criterion args*/

  a.appStart({ execPath : '.resources.list *a* predefined:0' })
  .then( ( op ) =>
  {
    test.case = 'resources list globs negative';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'path::out.release' ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.raw' ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug.raw' ) );
    test.true( _.strHas( op.output, 'build::debug.raw' ) );
    test.true( _.strHas( op.output, 'build::release.raw' ) );
    test.true( _.strHas( op.output, 'build::release.compiled' ) );
    test.true( _.strHas( op.output, 'build::all' ) );
    test.identical( _.strCount( op.output, '::' ), 21 );

    return null;
  })

  a.appStart({ execPath : '.resources.list *p* debug:1' })
  .then( ( op ) =>
  {
    test.case = 'resources list globs negative';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflector::predefined.debug.v1' ) );
    test.true( !_.strHas( op.output, 'reflector::predefined.debug.v2' ) );
    test.true( _.strHas( op.output, 'reflector::reflect.proto.debug' ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug.raw' ) );
    test.true( _.strHas( op.output, 'step::export.proto' ) );
    test.true( _.strHas( op.output, 'build::debug.compiled' ) );
    test.true( _.strHas( op.output, 'build::proto.export' ) );
    test.identical( _.strCount( op.output, '::' ), 22 );

    return null;
  })

  /* Glob using positive test */
  a.appStart({ execPath : '.resources.list *proto*' })
  .then( ( op ) =>
  {
    test.case = '.resources.list *proto*';
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'reflector::reflect.proto.' ) );

    test.true( _.strHas( op.output, 'step::reflect.proto.' ) );
    test.true( _.strHas( op.output, `files.reflect` ) );

    test.true( _.strHas( op.output, 'build::proto.export' ) );
    test.true( _.strHas( op.output, `step::export.proto` ) );

    return null;
  })

  /* Glob and criterion using negative test */
  a.appStart({ execPath : '.resources.list *proto* debug:0' })
  .then( ( op ) =>
  {
    test.case = 'globs and criterions negative';
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, `out.debug : './out/debug'` ) );
    test.true( !_.strHas( op.output, `reflector::reflect.proto.debug` ) );
    test.true( !_.strHas( op.output, 'step::reflect.proto.debug' ) );
    test.true( !_.strHas( op.output, 'build::debug.raw' ) );

    return null;
  })

  /* Glob and criterion using positive test */
  a.appStart({ execPath : '.resources.list *proto* debug:0 predefined:0' })
  .then( ( op ) =>
  {
    test.case = 'globs and criterions positive';
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'path::proto' ) );

    test.true( _.strHas( op.output, 'reflector::reflect.proto.' ) );

    test.true( _.strHas( op.output, 'step::reflect.proto.' ) );
    test.true( _.strHas( op.output, `files.reflect` ) );

    test.identical( _.strCount( op.output, '::' ), 12 );

    return null;
  })

  /* Glob and two criterions using negative test */
  a.appStart({ execPath : '.resources.list * debug:1 raw:0 predefined:0' })
  .then( ( op ) =>
  {
    test.case = '.resources.list * debug:1 raw:0 predefined:0';
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, `path::out.debug` ) );
    test.true( _.strHas( op.output, `reflector::reflect.proto.debug` ) );
    test.true( _.strHas( op.output, `step::reflect.proto.debug` ) );
    test.true( _.strHas( op.output, `step::export.proto` ) );
    test.true( _.strHas( op.output, `build::debug.compiled` ) );
    test.true( _.strHas( op.output, `build::proto.export` ) );
    test.identical( _.strCount( op.output, '::' ), 20 );

    return null;
  })

  /* Glob and two criterion using positive test */
  a.appStart({ execPath : '.resources.list * debug:0 raw:1' })
  .then( ( op ) =>
  {
    test.case = '.resources.list * debug:0 raw:1';
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'step::reflect.proto.raw' ) );
    test.true( _.strHas( op.output, 'build::release.raw' ) );
    test.identical( _.strCount( op.output, '::' ), 7 );

    return null;
  })

  return a.ready;
}

listSingleModule.rapidity = -1;

//

function listWithSubmodulesSimple( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflect();

  a.appStart({ execPath : '.resources.list' })

  .then( ( op ) =>
  {
    test.case = '.resources.list';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `name : 'submodules'` ) );
    test.true( _.strHas( op.output, `description : 'Module for testing'` ) );
    test.true( _.strHas( op.output, `version : '0.0.1'` ) );
    return null;
  })

  return a.ready;
}

//

function listWithSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.submodules.list' })

  .then( ( op ) =>
  {
    test.case = '.submodules.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'relation::ModuleForTesting1' ) );
    test.true( _.strHas( op.output, 'relation::ModuleForTesting2a' ) );
    return null;
  })

  /* - */

  a.appStart({ execPath : '.reflectors.list' })

  .then( ( op ) =>
  {
    test.case = 'reflectors.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflector::reflect.proto.' ))
    test.true( _.strHas( op.output, `reflector::reflect.proto.debug` ))
    return null;
  })

  /* - */

  a.appStart({ execPath : '.steps.list' })

  .then( ( op ) =>
  {
    test.case = 'steps.list'
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'step::delete.out.debug' ))
    test.true( _.strHas( op.output, 'step::reflect.proto.' ))
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ))
    test.true( _.strHas( op.output, 'step::reflect.submodules' ))
    test.true( _.strHas( op.output, 'step::export.proto' ))

    return null;
  })

  /* - */

  a.appStart({ execPath : '.builds.list' })

  .then( ( op ) =>
  {
    test.case = '.builds.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'build::debug.raw' ));
    test.true( _.strHas( op.output, 'build::debug.compiled' ));
    test.true( _.strHas( op.output, 'build::release.raw' ));
    test.true( _.strHas( op.output, 'build::release.compiled' ));

    return null;
  })

  /* - */

  a.appStart({ execPath : '.exports.list' })

  .then( ( op ) =>
  {
    test.case = '.exports.list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'build::proto.export' ));
    test.true( _.strHas( op.output, 'steps : ' ));
    test.true( _.strHas( op.output, 'build::debug.raw' ));
    test.true( _.strHas( op.output, 'step::export.proto' ));

    return null;
  })

  /* - */

  a.appStart({ execPath : '.about.list' })

  .then( ( op ) =>
  {
    test.case = '.about.list'

    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, `name : 'submodules'` ));
    test.true( _.strHas( op.output, `description : 'Module for testing'` ));
    test.true( _.strHas( op.output, `version : '0.0.1'` ));
    test.true( _.strHas( op.output, `enabled : 1` ));
    test.true( _.strHas( op.output, `interpreters :` ));
    test.true( _.strHas( op.output, `'nodejs >= 10.0.0'` ));
    test.true( _.strHas( op.output, `'chrome >= 60.0.0'` ));
    test.true( _.strHas( op.output, `'firefox >= 60.0.0'` ));
    test.true( _.strHas( op.output, `'nodejs >= 10.0.0'` ));
    test.true( _.strHas( op.output, `keywords :` ));
    test.true( _.strHas( op.output, `'wModuleForTesting1'` ));

    return null;
  })

  return a.ready;
}

// --
// export
// --

function exportSingle( test )
{
  let context = this;
  let a = context.assetFor( test, 'single' );
  // let outPath = a.abs( 'out' ); /* aaa : ? */ /* Dmytro : use `a.abs` */
  a.reflect();
  a.fileProvider.filesDelete( a.abs( 'out/debug' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'reflected 2 file(s)' ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, 'Exported module::single / build::proto.export with 2 file(s) in') );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './Single.s' ] );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './single.out.will.yml', './debug', './debug/Single.s' ] );

    test.true( a.fileProvider.fileExists( a.abs( 'out/single.out.will.yml' ) ) )
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/single.out.will.yml' ) );
    outfile = outfile.module[ outfile.root[ 0 ] ];

    let reflector = outfile.reflector[ 'exported.files.proto.export' ];
    test.identical( reflector.src.basePath, '.' );
    test.identical( reflector.src.prefixPath, 'path::exported.dir.proto.export' );
    test.identical( reflector.src.filePath, { 'path::exported.files.proto.export' : '' } );

    return null;
  })

  /* - */

  .then( () =>
  {
    test.case = '.export.proto'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.export proto.export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exported .*module::single \/ build::proto.export.* in/ ) );
    test.true( _.strHas( op.output, 'reflected 2 file(s)' ) );
    test.true( _.strHas( op.output, 'Exported module::single / build::proto.export with 2 file(s) in' ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './Single.s' ] );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './single.out.will.yml', './debug', './debug/Single.s' ] );

    test.true( a.fileProvider.fileExists( a.abs( 'out/single.out.will.yml' ) ) )
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/single.out.will.yml' ) );
    outfile = outfile.module[ outfile.root[ 0 ] ];

    let reflector = outfile.reflector[ 'exported.files.proto.export' ];
    let expectedFilePath =
    {
      '.' : '',
      'Single.s' : '',
    }
    test.identical( reflector.src.basePath, '.' );
    test.identical( reflector.src.prefixPath, 'path::exported.dir.proto.export' );
    test.identical( reflector.src.filePath, { 'path::exported.files.proto.export' : '' } );

    return null;
  })

  return a.ready;
}

//

function exportWithExistedGitRepository( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithDefaultPaths' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export';
    return null;
  });

  a.shell( 'git init' );
  a.appStart( '.export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Exporting module::ExportWithDefaultPaths' ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, 'Exported module::ExportWithDefaultPaths / build::export' ) );

    let config = a.fileProvider.fileReadUnknown( a.abs( 'out/ExportWithDefaultPaths.out.will.yml' ) );
    let path = config.module[ 'ExportWithDefaultPaths.out' ].path;
    test.identical( path.download, { criterion : { predefined : 1 }, path : '..' } );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'reexport';
    return null;
  });

  a.appStart( '.export' )
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Exporting module::ExportWithDefaultPaths' ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, 'Exported module::ExportWithDefaultPaths / build::export' ) );

    let config = a.fileProvider.fileReadUnknown( a.abs( 'out/ExportWithDefaultPaths.out.will.yml' ) )
    let path = config.module[ 'ExportWithDefaultPaths.out' ].path;
    test.identical( path.download, { criterion : { predefined : 1 }, path : '..' } );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportItself( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportItself' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export';
    a.reflect();
    return null;
  });

  a.appStart( '.with v1 .clean' );
  a.appStart( '.with v1 .submodules.download' );

  a.appStart( '.with v1 .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.routinePath );
    test.gt( files.length, 50 );

    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, /Exported module::experiment \/ build::export with .* file\(s\) in/ ) );

    return null;
  });

  /* - */

  return a.ready;
}

//

/*
  Submodule Submodule is deleted, so exporting should fail.
*/

function exportNonExportable( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoExported' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( 'out' ) );
  a.fileProvider.filesDelete( a.abs( 'super.out' ) );

  /* - */

  a.appStart({ execPath : '.with super .clean' })
  a.appStart({ args : [ '.with super .export debug:1' ], throwingExitCode : 0 })

  .then( ( op ) =>
  {
    test.true( op.exitCode !== 0 );

    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'rror' ), 3 );
    test.identical( _.strCount( op.output, '====' ), 0 );

    test.identical( _.strCount( op.output, 'module::supermodule / relation::Submodule is not opened' ), 1 );
    test.identical( _.strCount( op.output, 'Failed module::supermodule / step::reflect.submodules.debug' ), 1 );

    // test.identical( _.strCount( op.output, /Exporting is impossible because .*module::supermodule \/ submodule::Submodule.* is broken!/ ), 1 );
    // test.identical( _.strCount( op.output, /Failed .*module::supermodule \/ step::export.*/ ), 1 );

    return null;
  })

  return a.ready;
}

//

function exportPurging( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMinimal' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( 'out' ) );
  a.fileProvider.filesDelete( a.abs( 'super.out' ) );

  /* - */

  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.true( op.exitCode === 0 );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( './out/ExportMinimal.out.will.yml' ) );
    test.identical( outfile.module[ 'ExportMinimal.out' ].about.version, '0.0.0' );
    outfile.module[ 'ExportMinimal.out' ].about.version = '3.3.3';

    a.fileProvider.fileWrite
    ({
      filePath : a.abs( './out/ExportMinimal.out.will.yml' ),
      data : outfile,
      encoding : 'yml',
    });

    var outfile = a.fileProvider.fileReadUnknown( a.abs( './out/ExportMinimal.out.will.yml' ) );
    test.identical( outfile.module[ 'ExportMinimal.out' ].about.version, '3.3.3' );

    return null;
  })

  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.description = 'second .export';
    test.true( op.exitCode === 0 );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( './out/ExportMinimal.out.will.yml' ) );
    test.identical( outfile.module[ 'ExportMinimal.out' ].about.version, '3.3.3' );

    return null;
  })

  a.appStart({ execPath : '.export.purging' })
  .then( ( op ) =>
  {
    test.description = '.export.purging';
    test.true( op.exitCode === 0 );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( './out/ExportMinimal.out.will.yml' ) );
    test.identical( outfile.module[ 'ExportMinimal.out' ].about.version, '0.0.0' );

    return null;
  })

  /* - */

  return a.ready;
}

//

function exportStringrmal( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesMixed' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with module/ModuleForTesting12.informal .export'
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.with module/ModuleForTesting12.informal .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Exported .*module::ModuleForTesting12.informal \/ build::export.* in/ ), 1 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './ModuleForTesting12.informal.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/ModuleForTesting12.informal.out.will.yml' ) );
    outfile = outfile.module[ 'ModuleForTesting12.informal.out' ];
    var expected =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.informal.out.will.yml`
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.informal.out`
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.informal.will.yml`
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.informal.will.yml`
      },
      'in' :
      {
        'path' : `.`
      },
      'out' :
      {
        'path' : `.`
      },
      // 'remote' :
      // {
      //   'criterion' : { 'predefined' : 1 }
      // },
      'download' : { 'path' : `../.module/ModuleForTesting12`, 'criterion' : { 'predefined' : 1 } },
      'export' : { 'path' : `{path::download}/proto/**` },
      'exported.dir.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' : `../.module/ModuleForTesting12/proto`
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      },
    }
    delete outfile.path[ 'exported.files.export' ];
    test.identical( outfile.path, expected );
    test.identical( outfile.path.download.path, '../.module/ModuleForTesting12' );
    test.identical( outfile.path.remote.path, undefined );
    // test.identical( outfile.path.remote.path, 'git+https:///github.com/Wandalen/wModuleForTesting12.git' );
    // logger.log( _.entity.exportJson( outfile.path ) );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with module/ModuleForTesting12.informal .export -- second'
    return null;
  })

  a.appStart({ execPath : '.with module/ModuleForTesting12.informal .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Exported .*module::ModuleForTesting12.informal \/ build::export.* in/ ), 1 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './ModuleForTesting12.informal.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/ModuleForTesting12.informal.out.will.yml' ) );
    outfile = outfile.module[ 'ModuleForTesting12.informal.out' ];
    var expected =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.informal.out.will.yml`
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.informal.out`
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.informal.will.yml`
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.informal.will.yml`
      },
      'in' :
      {
        'path' : `.`
      },
      'out' :
      {
        'path' : `.`
      },
      // 'remote' :
      // {
      //   'criterion' : { 'predefined' : 1 }
      // },
      'download' : { 'path' : `../.module/ModuleForTesting12`, 'criterion' : { 'predefined' : 1 } },
      'export' : { 'path' : `{path::download}/proto/**` },
      'exported.dir.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' : `../.module/ModuleForTesting12/proto`
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      },
    }
    delete outfile.path[ 'exported.files.export' ];
    test.identical( outfile.path, expected );
    test.identical( outfile.path.download.path, '../.module/ModuleForTesting12' );
    test.identical( outfile.path.remote.path, undefined );
    // test.identical( outfile.path.remote.path, 'git+https:///github.com/Wandalen/wModuleForTesting12.git' );
    // logger.log( _.entity.exportJson( outfile.path ) );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with module/ModuleForTesting12ab.informal .export'
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.with module/ModuleForTesting12ab.informal .export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Exported .*module::ModuleForTesting12ab.informal \/ build::export.* in/ ), 1 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './ModuleForTesting12ab.informal.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/ModuleForTesting12ab.informal.out.will.yml' ) );
    outfile = outfile.module[ 'ModuleForTesting12ab.informal.out' ];
    var expected =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12ab.informal.out.will.yml`
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12ab.informal.out`
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12ab.informal.will.yml`
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12ab.informal.will.yml`
      },
      'in' :
      {
        'path' : `.`
      },
      'out' :
      {
        'path' : `.`
      },
      // 'remote' :
      // {
      //   'criterion' : { 'predefined' : 1 }
      // },
      'download' : { 'path' : `../.module/ModuleForTesting12ab`, 'criterion' : { 'predefined' : 1 } },
      'export' : { 'path' : `{path::download}/proto/**` },
      'exported.dir.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' : `../.module/ModuleForTesting12ab/proto`
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      }
    }
    delete outfile.path[ 'exported.files.export' ];
    test.identical( outfile.path, expected );
    test.identical( outfile.path.download.path, '../.module/ModuleForTesting12ab' );
    test.identical( outfile.path.remote.path, undefined );
    // test.identical( outfile.path.remote.path, 'npm:///wmodulefortesting12ab' );
    // logger.log( _.entity.exportJson( outfile.path ) );

    return null;
  })

  /* - */

  return a.ready;
}

exportStringrmal.timeOut = 300000;
exportStringrmal.description =
`
- local path and remote path of exported informal module should be preserved and in proper form
- second export should work properly
`

//

function exportWithReflector( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithReflector' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( 'out/debug' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export'
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  a.appStart({ execPath : '.export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './exportWithReflector.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/exportWithReflector.out.will.yml' ) );

    return null;
  })

  return a.ready;
}

//

function exportToRoot( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportToRoot' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.export' })

  .then( ( op ) =>
  {
    test.case = '.export'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exporting .*module::exportToRoot \/ build::proto\.export.*/ ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, /Exported .*module::exportToRoot \/ build::proto\.export.* in/ ) );
    test.true( a.fileProvider.fileExists( a.abs( 'exportToRoot.out.will.yml' ) ) )
    return null;
  })

  return a.ready;
}

//

function exportMixed( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesMixed' );
  a.reflect();

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.each module .export';
    return null;
  })

  a.appStart({ execPath : '.each module .export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exporting .*module::ModuleForTesting12ab\.informal \/ build::export.*/ ) );
    test.true( _.strHas( op.output, ' + reflector::download reflected' ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, /Exported .*module::ModuleForTesting12ab\.informal \/ build::export.* in/ ) );
    test.true( _.strHas( op.output, 'out/ModuleForTesting12.informal.out.will.yml' ) );
    test.true( _.strHas( op.output, 'out/ModuleForTesting12ab.informal.out.will.yml' ) );

    test.true( a.fileProvider.isTerminal( a.abs( 'out/ModuleForTesting12.informal.out.will.yml' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'out/ModuleForTesting12ab.informal.out.will.yml' ) ) );

    var files = a.find( a.abs( 'module' ) );
    test.identical( files, [ '.', './ModuleForTesting12.informal.will.yml', './ModuleForTesting12ab.informal.will.yml' ] );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './ModuleForTesting12.informal.out.will.yml', './ModuleForTesting12ab.informal.out.will.yml' ] );

    var expected = [ 'ModuleForTesting12.informal.will.yml', 'ModuleForTesting12ab.informal.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( 'module' ) );
    test.identical( files, expected );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/ModuleForTesting12.informal.out.will.yml' ) );
    outfile = outfile.module[ 'ModuleForTesting12.informal.out' ];
    var expected =
    {
      'download' :
      {
        'src' : { 'prefixPath' : 'path::remote', 'filePath' : { '.' : '.' } },
        'dst' : { 'prefixPath' : 'path::download' },
        'mandatory' : 1,
      },
      'exported.export' :
      {
        'src' :
        {
          'filePath' : { '**' : '' },
          'prefixPath' : '../.module/ModuleForTesting12/proto'
        },
        'criterion' : { 'export' : 1, 'default' : 1, 'generated' : 1 },
        'mandatory' : 1,
      },
      'exported.files.export' :
      {
        'recursive' : 0,
        'mandatory' : 1,
        'src' : { 'filePath' : { 'path::exported.files.export' : '' }, 'basePath' : '.', 'prefixPath' : 'path::exported.dir.export', 'recursive' : 0 },
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 }
      }
    }
    test.identical( outfile.reflector, expected );
    test.identical( outfile.reflector[ 'exported.files.export' ], expected[ 'exported.files.export' ] );

    var expected =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.informal.out.will.yml`
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.informal.out`
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.informal.will.yml`
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.informal.will.yml`,
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..',
      },
      'in' :
      {
        'path' : `.`
      },
      'out' :
      {
        'path' : `.`
      },
      // 'remote' :
      // {
      //   'criterion' : { 'predefined' : 1 }
      // },
      'download' : { 'path' : `../.module/ModuleForTesting12`/*, 'criterion' : { 'predefined' : 1 }*/ },
      'export' : { 'path' : `{path::download}/proto/**` },
      'exported.dir.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' : `../.module/ModuleForTesting12/proto`
      },
      'exported.files.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' :
        [
          `../.module/ModuleForTesting12/proto`,
          `../.module/ModuleForTesting12/proto/wtools`,
          `../.module/ModuleForTesting12/proto/node_modules/Tools`,
          `../.module/ModuleForTesting12/proto/wtools/abase`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/Include.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l1`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l1/Define.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l1/ModuleForTesting12.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l1/Workpiece.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l3`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Accessor.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Class.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Complex.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Like.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto.test`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto.test/Class.test.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto.test/Complex.test.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto.test/Like.test.s`,
          `../.module/ModuleForTesting12/proto/wtools/abase/l3_proto.test/ModuleForTesting12.test.s`
        ]
      }
    }
    test.identical( outfile.path, expected );
    // logger.log( _.entity.exportJson( outfile.path ) );

    var expected =
    {
      'export' :
      {
        'version' : '0.1.0',
        'recursive' : 0,
        'withIntegrated' : 2,
        'tar' : 0,
        'criterion' : { 'default' : 1, 'export' : 1 },
        'exportedReflector' : 'reflector::exported.export',
        'exportedFilesReflector' : 'reflector::exported.files.export',
        'exportedDirPath' : 'path::exported.dir.export',
        'exportedFilesPath' : 'path::exported.files.export',
      }
    }
    test.identical( outfile.exported, expected );

    var expected =
    {
      'export.common' :
      {
        'opts' : { 'export' : 'path::export', 'tar' : 0 },
        'inherit' : [ 'module.export' ]
      },
      'download' :
      {
        'opts' : { 'reflector' : 'reflector::download*', 'verbosity' : null },
        'inherit' : [ 'files.reflect' ]
      }
    }
    test.identical( outfile.step, expected );

    var expected =
    {
      'export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1 },
        'steps' : [ 'step::download', 'step::export.common' ]
      }
    }
    test.identical( outfile.build, expected );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.build';
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build' })

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exporting .*module::ModuleForTesting12ab.informal.* \/ build::export/ ) );
    test.true( _.strHas( op.output, /\+ reflector::download reflected .* file\(s\)/ ) );
    test.true( _.strHas( op.output, '+ Write out willfile' ) );
    test.true( _.strHas( op.output, /Exported .*module::ModuleForTesting12ab.informal.* \/ build::export/ ) );
    test.true( _.strHas( op.output, 'out/ModuleForTesting12.informal.out.will.yml' ) );
    test.true( _.strHas( op.output, 'out/ModuleForTesting12ab.informal.out.will.yml' ) );
    test.true( _.strHas( op.output, 'Reloading submodules' ) );

    test.true( _.strHas( op.output, /- .*step::delete.out.debug.* deleted 0 file\(s\), at/ ) );
    test.true( _.strHas( op.output, ' + reflector::reflect.proto.debug reflected' ) );
    test.true( _.strHas( op.output, ' + reflector::reflect.submodules reflected' ) );

    test.identical( _.strCount( op.output, ' ! Failed to open' ), 4 );

    test.true( a.fileProvider.isTerminal( a.abs( 'out/ModuleForTesting12.informal.out.will.yml' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'out/ModuleForTesting12ab.informal.out.will.yml' ) ) );

    var files = a.find( a.abs( 'module' ) );
    test.identical( files, [ '.', './ModuleForTesting12.informal.will.yml', './ModuleForTesting12ab.informal.will.yml' ] );
    var files = a.find( a.abs( 'out' ) );
    test.gt( files.length, 70 );

    var expected = [ 'ModuleForTesting12.informal.will.yml', 'ModuleForTesting12ab.informal.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( 'module' ) );
    test.identical( files, expected );

    var expected = [ 'wtools', 'WithSubmodules.s' ];
    var files = a.fileProvider.dirRead( a.abs( 'out/debug' ) );
    test.identical( files, expected );

    return null;
  })

  /* - */

  return a.ready;
}

exportMixed.timeOut = 300000;

//

function exportSecond( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportSecond' );

  /* - */

  begin();

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.export';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.export' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, '+ Write out willfile' ), 2 );
    test.identical( _.strCount( op.output, 'Exported module::ExportSecond / build::export with 6 file(s) in' ), 1 );

    test.true( a.fileProvider.isTerminal( a.abs( 'out/ExportSecond.out.will.yml' ) ) );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './ExportSecond.out.will.yml', './debug', './debug/.NotExecluded.js', './debug/File.js' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/ExportSecond.out.will.yml' ) );

    outfile = outfile.module[ 'ExportSecond.out' ];

    var expected =
    {
      'reflect.proto.' :
      {
        'src' :
        {
          'filePath' : { 'path::proto' : 'path::out.*=1' },
          'prefixPath' : ''
        },
        'dst' : { 'prefixPath' : '' },
        'criterion' : { 'debug' : 0 },
        'inherit' : [ 'predefined.*' ],
      },
      'reflect.proto.debug' :
      {
        'src' :
        {
          'filePath' : { 'path::proto' : 'path::out.*=1' }
        },
        'criterion' : { 'debug' : 1 },
        'inherit' : [ 'predefined.*' ],
      },
      'exported.doc.export' :
      {
        'src' :
        {
          'filePath' : { '**' : '' },
          'prefixPath' : '../doc'
        },
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
        'mandatory' : 1,
        'dstRewritingOnlyPreserving' : 1,
        'linkingAction' : 'hardLinkMaybe',
      },
      'exported.files.doc.export' :
      {
        'src' :
        {
          'filePath' : { 'path::exported.files.doc.export' : '' },
          'basePath' : '.',
          'prefixPath' : 'path::exported.dir.doc.export',
          'recursive' : 0
        },
        'recursive' : 0,
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
      },
      'exported.proto.export' :
      {
        'src' :
        {
          'filePath' : { '**' : '' },
          'prefixPath' : '../proto'
        },
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
        'mandatory' : 1,
        'dstRewritingOnlyPreserving' : 1,
        'linkingAction' : 'hardLinkMaybe',
      },
      'exported.files.proto.export' :
      {
        'src' :
        {
          'filePath' : { 'path::exported.files.proto.export' : '' },
          'basePath' : '.',
          'prefixPath' : 'path::exported.dir.proto.export',
          'recursive' : 0
        },
        'recursive' : 0,
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
      }
    };
    test.identical( outfile.reflector, expected );

    var expected =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : 'ExportSecond.out.will.yml'
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : 'ExportSecond.out'
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ]
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ]
      },
      'download' :
      {
        'criterion' : { 'predefined' : 1 }
      },
      'in' :
      {
        'path' : '.'
      },
      'temp' : { 'path' : '.' },
      'out' :
      {
        'path' : '.'
      },
      'out.debug' :
      {
        'criterion' : { 'debug' : 1 },
        'path' : 'debug/*'
      },
      'out.release' :
      {
        'criterion' : { 'debug' : 0 },
        'path' : 'release/*'
      },
      'proto' : { 'path' : '../proto/**' },
      'doc' : { 'path' : '../doc/**' },
      'exported.dir.doc.export' :
      {
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
        'path' : '../doc'
      },
      'exported.files.doc.export' :
      {
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
        'path' : [ '../doc', '../doc/File.md' ]
      },
      'exported.dir.proto.export' :
      {
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
        'path' : '../proto'
      },
      'exported.files.proto.export' :
      {
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
        'path' : [ '../proto', '../proto/-NotExecluded.js', '../proto/.NotExecluded.js', '../proto/File.js' ]
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      }
    };
    test.identical( outfile.path, expected );

    var expected =
    {
      'doc.export' :
      {
        version : '0.0.0',
        recursive : 0,
        withIntegrated : 2,
        tar : 0,
        criterion : { doc : 1, export : 1 },
        exportedReflector : 'reflector::exported.doc.export',
        exportedFilesReflector : 'reflector::exported.files.doc.export',
        exportedDirPath : 'path::exported.dir.doc.export',
        exportedFilesPath : 'path::exported.files.doc.export',
      },
      'proto.export' :
      {
        version : '0.0.0',
        recursive : 0,
        withIntegrated : 2,
        tar : 0,
        criterion : { proto : 1, export : 1 },
        exportedReflector : 'reflector::exported.proto.export',
        exportedFilesReflector : 'reflector::exported.files.proto.export',
        exportedDirPath : 'path::exported.dir.proto.export',
        exportedFilesPath : 'path::exported.files.proto.export',
      }
    };
    test.identical( outfile.exported, expected );

    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.export';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.export' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, '+ Write out willfile' ), 2 );
    test.identical( _.strCount( op.output, 'Exported module::ExportSecond / build::export with 6 file(s) in' ), 1 );

    test.true( a.fileProvider.isTerminal( a.abs( 'out/ExportSecond.out.will.yml' ) ) );

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './ExportSecond.out.will.yml', './debug', './debug/.NotExecluded.js', './debug/File.js' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/ExportSecond.out.will.yml' ) );

    outfile = outfile.module[ 'ExportSecond.out' ]

    var expected =
    {
      'reflect.proto.' :
      {
        'src' :
        {
          'filePath' : { 'path::proto' : 'path::out.*=1' },
          'prefixPath' : ''
        },
        'dst' : { 'prefixPath' : '' },
        'criterion' : { 'debug' : 0 },
        'inherit' : [ 'predefined.*' ],
      },
      'reflect.proto.debug' :
      {
        'src' :
        {
          'filePath' : { 'path::proto' : 'path::out.*=1' }
        },
        'criterion' : { 'debug' : 1 },
        'inherit' : [ 'predefined.*' ],
      },
      'exported.doc.export' :
      {
        'src' :
        {
          'filePath' : { '**' : '' },
          'prefixPath' : '../doc'
        },
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
        'mandatory' : 1,
        'dstRewritingOnlyPreserving' : 1,
        'linkingAction' : 'hardLinkMaybe',
      },
      'exported.files.doc.export' :
      {
        'src' :
        {
          'filePath' : { 'path::exported.files.doc.export' : '' },
          'basePath' : '.',
          'prefixPath' : 'path::exported.dir.doc.export',
          'recursive' : 0
        },
        'recursive' : 0,
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
      },
      'exported.proto.export' :
      {
        'src' :
        {
          'filePath' : { '**' : '' },
          'prefixPath' : '../proto'
        },
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
        'mandatory' : 1,
        'dstRewritingOnlyPreserving' : 1,
        'linkingAction' : 'hardLinkMaybe',
      },
      'exported.files.proto.export' :
      {
        'src' :
        {
          'filePath' : { 'path::exported.files.proto.export' : '' },
          'basePath' : '.',
          'prefixPath' : 'path::exported.dir.proto.export',
          'recursive' : 0
        },
        'recursive' : 0,
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
      }
    };
    test.identical( outfile.reflector, expected );

    var expected =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : 'ExportSecond.out.will.yml'
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : 'ExportSecond.out'
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ]
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ]
      },
      'download' :
      {
        'criterion' : { 'predefined' : 1 }
      },
      'in' :
      {
        'path' : '.'
      },
      'temp' : { 'path' : '.' },
      'out' :
      {
        'path' : '.'
      },
      'out.debug' :
      {
        'criterion' : { 'debug' : 1 },
        'path' : 'debug/*'
      },
      'out.release' :
      {
        'criterion' : { 'debug' : 0 },
        'path' : 'release/*'
      },
      'proto' : { 'path' : '../proto/**' },
      'doc' : { 'path' : '../doc/**' },
      'exported.dir.doc.export' :
      {
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
        'path' : '../doc'
      },
      'exported.files.doc.export' :
      {
        'criterion' : { 'doc' : 1, 'export' : 1, 'generated' : 1 },
        'path' : [ '../doc', '../doc/File.md' ]
      },
      'exported.dir.proto.export' :
      {
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
        'path' : '../proto'
      },
      'exported.files.proto.export' :
      {
        'criterion' : { 'proto' : 1, 'export' : 1, 'generated' : 1 },
        'path' : [ '../proto', '../proto/-NotExecluded.js', '../proto/.NotExecluded.js', '../proto/File.js' ]
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      }
    };
    test.identical( outfile.path, expected );

    var expected =
    {
      'doc.export' :
      {
        version : '0.0.0',
        recursive : 0,
        withIntegrated : 2,
        tar : 0,
        criterion : { doc : 1, export : 1 },
        exportedReflector : 'reflector::exported.doc.export',
        exportedFilesReflector : 'reflector::exported.files.doc.export',
        exportedDirPath : 'path::exported.dir.doc.export',
        exportedFilesPath : 'path::exported.files.doc.export',
      },
      'proto.export' :
      {
        version : '0.0.0',
        recursive : 0,
        withIntegrated : 2,
        tar : 0,
        criterion : { proto : 1, export : 1 },
        exportedReflector : 'reflector::exported.proto.export',
        exportedFilesReflector : 'reflector::exported.files.proto.export',
        exportedDirPath : 'path::exported.dir.proto.export',
        exportedFilesPath : 'path::exported.files.proto.export',
      }
    };
    test.identical( outfile.exported, expected );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.fileRename({ srcPath : a.abs( 'proto/NotExecluded1.js' ), dstPath : a.abs( 'proto/-NotExecluded.js' ) });
      a.fileProvider.fileRename({ srcPath : a.abs( 'proto/NotExecluded2.js' ), dstPath : a.abs( 'proto/.NotExecluded.js' ) });
      return null;
    });
  }
}

exportSecond.timeOut = 300000;

//

function exportSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.export'
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  })

  return a.appStart({ execPath : '.export' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( a.fileProvider.isTerminal( a.abs( 'out/debug/wtools/testing/l1/ModuleForTesting1.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'out/debug/wtools/testing/l3/testing2a/ModuleForTesting2a.s' ) ) );
    test.true( a.fileProvider.isTerminal( a.abs( 'out/submodules.out.will.yml' ) ) );
    test.true( _.strHas( op.output, /Exported .*module::submodules \/ build::proto\.export.* in/ ) );

    var files = a.find( a.abs( 'out' ) );
    test.true( files.length > 10 );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, [ 'debug', 'submodules.out.will.yml' ] );

    return null;
  })

  return a.ready;
}

//

function exportMultiple( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMultiple' );
  a.reflect();

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.export debug:1';
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'out' ) );

    return null;
  })

  a.appStart({ execPath : '.export debug:1' })

  .then( ( op ) =>
  {

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './submodule.debug.out.tgs', './submodule.out.will.yml', './debug', './debug/File.debug.js' ] );
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'Read 2 willfile(s) in' ) );
    test.true( _.strHas( op.output, /Exported module::submodule \/ build::export.debug with 2 file\(s\) in .*/ ) );
    test.true( _.strHas( op.output, 'Write out archive' ) );
    test.true( _.strHas( op.output, 'Write out willfile' ) );
    test.true( _.strHas( op.output, 'submodule.debug.out.tgs' ) );
    test.true( _.strHas( op.output, 'out/submodule.out.will.yml' ) );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/submodule.out.will.yml' ) );

    outfile = outfile.module[ 'submodule.out' ];

    var exported =
    {
      'export.debug' :
      {
        version : '0.0.1',
        recursive : 0,
        withIntegrated : 2,
        tar : 1,
        criterion :
        {
          default : 1,
          debug : 1,
          raw : 1,
          export : 1
        },
        exportedReflector : 'reflector::exported.export.debug',
        exportedFilesReflector : 'reflector::exported.files.export.debug',
        exportedDirPath : 'path::exported.dir.export.debug',
        exportedFilesPath : 'path::exported.files.export.debug',
        archiveFilePath : 'path::archiveFile.export.debug',
      }
    }

    test.identical( outfile.exported, exported );

    var exportedReflector =
    {
      // src : { filePath : { '.' : '' }, prefixPath : 'debug' },
      src : { filePath : { '**' : '' }, prefixPath : 'debug' },
      mandatory : 1,
      criterion :
      {
        default : 1,
        debug : 1,
        raw : 1,
        export : 1,
        generated : 1,
      },
      dstRewritingOnlyPreserving : 1,
      linkingAction : 'hardLinkMaybe',
    }
    test.identical( outfile.reflector[ 'exported.export.debug' ], exportedReflector );
    // logger.log( _.entity.exportJson( outfile.reflector ) );

    var exportedReflectorFiles =
    {
      recursive : 0,
      // mandatory : 1,
      src :
      {
        filePath : { 'path::exported.files.export.debug' : '' },
        basePath : '.',
        prefixPath : 'path::exported.dir.export.debug',
        recursive : 0,
      },
      criterion :
      {
        default : 1,
        debug : 1,
        raw : 1,
        export : 1,
        generated : 1,
      },
      // dstRewritingOnlyPreserving : 1,
      // linkingAction : 'hardLinkMaybe',
    }

    test.identical( outfile.reflector[ 'exported.files.export.debug' ], exportedReflectorFiles );

    let outfilePath =
    {
      'module.willfiles' :
      {
        'path' : 'submodule.out.will.yml',
        'criterion' : { 'predefined' : 1 }
      },
      'module.original.willfiles' :
      {
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ],
        'criterion' : { 'predefined' : 1 }
      },
      'module.peer.willfiles' :
      {
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ],
        'criterion' : { 'predefined' : 1 }
      },
      'download' :
      {
        'criterion' : { 'predefined' : 1 }
      },
      'module.common' :
      {
        'path' : 'submodule.out',
        'criterion' : { 'predefined' : 1 }
      },
      // 'remote' :
      // {
      //   'criterion' : { 'predefined' : 1 }
      // },
      'proto' : { 'path' : '../proto' },
      'temp' : { 'path' : '.' },
      'in' :
      {
        'path' : '.',
      },
      'out' :
      {
        'path' : '.',
      },
      'out.debug' :
      {
        'path' : 'debug',
        'criterion' : { 'debug' : 1 }
      },
      'out.release' :
      {
        'path' : 'release',
        'criterion' : { 'debug' : 0 }
      },
      'exported.dir.export.debug' :
      {
        'path' : 'debug',
        'criterion' :
        {
          'default' : 1,
          'debug' : 1,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'exported.files.export.debug' :
      {
        'path' : [ 'debug', 'debug/File.debug.js' ],
        'criterion' :
        {
          'default' : 1,
          'debug' : 1,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'archiveFile.export.debug' :
      {
        'path' : 'submodule.debug.out.tgs',
        'criterion' :
        {
          'default' : 1,
          'debug' : 1,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      }
    }
    test.identical( outfile.path, outfilePath );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.export debug:1';
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'out' ) );

    return null;
  })

  a.appStart({ execPath : '.export debug:1' })
  a.appStart({ execPath : '.export debug:0' })
  a.appStart({ execPath : '.export debug:0' })

  .then( ( op ) =>
  {

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './submodule.debug.out.tgs', './submodule.out.tgs', './submodule.out.will.yml', './debug', './debug/File.debug.js', './release', './release/File.release.js' ] );
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'Read 3 willfile(s) in' ) );
    test.true( _.strHas( op.output, /Exported module::submodule \/ build::export. with 2 file\(s\) in .*/ ) );
    test.true( _.strHas( op.output, 'Write out archive' ) );
    test.true( _.strHas( op.output, 'Write out willfile' ) );
    test.true( _.strHas( op.output, 'submodule.out.tgs' ) );
    test.true( _.strHas( op.output, 'out/submodule.out.will.yml' ) );

    var outfileData = a.fileProvider.fileRead( a.abs( 'out/submodule.out.will.yml' ) );
    test.true( outfileData.length > 1000 );
    test.true( !_.strHas( outfileData, a.abs( '../..' ) ) );
    test.true( !_.strHas( outfileData, a.path.nativize( a.abs( '../..' ) ) ) );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/submodule.out.will.yml' ) );
    outfile = outfile.module[ 'submodule.out' ]
    var exported =
    {
      'export.debug' :
      {
        version : '0.0.1',
        recursive : 0,
        withIntegrated : 2,
        tar : 1,
        criterion :
        {
          default : 1,
          debug : 1,
          raw : 1,
          export : 1
        },
        exportedReflector : 'reflector::exported.export.debug',
        exportedFilesReflector : 'reflector::exported.files.export.debug',
        exportedDirPath : 'path::exported.dir.export.debug',
        exportedFilesPath : 'path::exported.files.export.debug',
        archiveFilePath : 'path::archiveFile.export.debug',
      },
      'export.' :
      {
        version : '0.0.1',
        recursive : 0,
        withIntegrated : 2,
        tar : 1,
        criterion :
        {
          default : 1,
          debug : 0,
          raw : 1,
          export : 1
        },
        exportedReflector : 'reflector::exported.export.',
        exportedFilesReflector : 'reflector::exported.files.export.',
        exportedDirPath : 'path::exported.dir.export.',
        exportedFilesPath : 'path::exported.files.export.',
        archiveFilePath : 'path::archiveFile.export.',
      },
    }
    test.identical( outfile.exported, exported );

    var exportedReflector =
    {
      mandatory : 1,
      src :
      {
        filePath : { '**' : '' },
        prefixPath : 'debug',
      },
      criterion :
      {
        default : 1,
        debug : 1,
        raw : 1,
        export : 1,
        generated : 1,
      },
      dstRewritingOnlyPreserving : 1,
      linkingAction : 'hardLinkMaybe',
    }
    test.identical( outfile.reflector[ 'exported.export.debug' ], exportedReflector );
    // logger.log( _.entity.exportJson( outfile.reflector[ 'exported.export.debug' ] ) );

    var exportedReflector =
    {
      mandatory : 1,
      src :
      {
        // filePath : { '.' : '' },
        filePath : { '**' : '' },
        prefixPath : 'release'
      },
      criterion :
      {
        default : 1,
        debug : 0,
        raw : 1,
        export : 1,
        generated : 1,
      },
      dstRewritingOnlyPreserving : 1,
      linkingAction : 'hardLinkMaybe',
    }
    // logger.log( _.entity.exportJson( outfile.reflector[ 'exported.export.' ] ) );
    test.identical( outfile.reflector[ 'exported.export.' ], exportedReflector );

    var exportedReflectorFiles =
    {
      recursive : 0,
      // mandatory : 1,
      src :
      {
        filePath : { 'path::exported.files.export.debug' : '' },
        basePath : '.',
        prefixPath : 'path::exported.dir.export.debug',
        recursive : 0,
      },
      criterion :
      {
        default : 1,
        debug : 1,
        raw : 1,
        export : 1,
        generated : 1,
      },
      // dstRewritingOnlyPreserving : 1,
      // linkingAction : 'hardLinkMaybe',
    }

    test.identical( outfile.reflector[ 'exported.files.export.debug' ], exportedReflectorFiles );

    var exportedReflectorFiles =
    {
      recursive : 0,
      // mandatory : 1,
      src :
      {
        filePath : { 'path::exported.files.export.' : '' },
        basePath : '.',
        prefixPath : 'path::exported.dir.export.',
        recursive : 0,
      },
      criterion :
      {
        default : 1,
        debug : 0,
        raw : 1,
        export : 1,
        generated : 1,
      },
      // dstRewritingOnlyPreserving : 1,
      // linkingAction : 'hardLinkMaybe',
    }

    test.identical( outfile.reflector[ 'exported.files.export.' ], exportedReflectorFiles );

    let outfilePath =
    {
      'module.willfiles' :
      {
        'path' : 'submodule.out.will.yml',
        'criterion' : { 'predefined' : 1 }
      },
      'module.original.willfiles' :
      {
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ],
        'criterion' : { 'predefined' : 1 }
      },
      'module.peer.willfiles' :
      {
        'path' : [ '../.ex.will.yml', '../.im.will.yml' ],
        'criterion' : { 'predefined' : 1 }
      },
      'download' :
      {
        'criterion' : { 'predefined' : 1 }
      },
      'module.common' :
      {
        'path' : 'submodule.out',
        'criterion' : { 'predefined' : 1 }
      },
      // 'remote' :
      // {
      //   'criterion' : { 'predefined' : 1 }
      // },
      'proto' : { 'path' : '../proto' },
      'temp' : { 'path' : '.' },
      'in' :
      {
        'path' : '.',
      },
      'out' :
      {
        'path' : '.',
      },
      'out.debug' :
      {
        'path' : 'debug',
        'criterion' : { 'debug' : 1 }
      },
      'out.release' :
      {
        'path' : 'release',
        'criterion' : { 'debug' : 0 }
      },
      'exported.dir.export.debug' :
      {
        'path' : 'debug',
        'criterion' :
        {
          'default' : 1,
          'debug' : 1,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'exported.files.export.debug' :
      {
        'path' : [ 'debug', 'debug/File.debug.js' ],
        'criterion' :
        {
          'default' : 1,
          'debug' : 1,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'archiveFile.export.debug' :
      {
        'path' : 'submodule.debug.out.tgs',
        'criterion' :
        {
          'default' : 1,
          'debug' : 1,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'exported.dir.export.' :
      {
        'path' : 'release',
        'criterion' :
        {
          'default' : 1,
          'debug' : 0,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'exported.files.export.' :
      {
        'path' : [ 'release', 'release/File.release.js' ],
        'criterion' :
        {
          'default' : 1,
          'debug' : 0,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'archiveFile.export.' :
      {
        'path' : 'submodule.out.tgs',
        'criterion' :
        {
          'default' : 1,
          'debug' : 0,
          'raw' : 1,
          'export' : 1,
          'generated' : 1,
        }
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      },
    }
    test.identical( outfile.path, outfilePath );
    // logger.log( _.entity.exportJson( outfile.path ) );

    return null;
  })

  /* - */

  return a.ready;
}

//

function exportImportMultiple( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMultiple' );

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = 'export submodule';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.with . .export debug:0' });
  a.appStart({ execPath : '.with . .export debug:1' });
  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './submodule.debug.out.tgs',
      './submodule.out.tgs',
      './submodule.out.will.yml',
      './debug',
      './debug/File.debug.js',
      './release',
      './release/File.release.js'
    ];
    test.identical( files, exp );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Exported module::submodule / build::export.debug with 2 file(s)' ) );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.imply withSubmodules:1 .with super .export debug:0';
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .with super .export debug:0' });
  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'super.out' ) );
    var exp =
    [
      '.',
      './supermodule.out.tgs',
      './supermodule.out.will.yml',
      './release',
      './release/File.release.js'
    ];
    test.identical( files, exp );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Exported module::supermodule / build::export. with 2 file(s)' ) );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.imply withSubmodules:1 .with super .clean dry:1';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .with super .clean dry:1' });
  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'super.out' ) );
    var exp =
    [
      '.',
      './supermodule.out.tgs',
      './supermodule.out.will.yml',
      './release',
      './release/File.release.js'
    ];
    test.identical( files, exp );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '5 at ' ) );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.imply withSubmodules:1 .with super .clean';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .with super .clean' });
  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'super.out' ) );
    test.identical( files, [] );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted 5 file(s)' ) );

    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.imply withSubmodules:1 .with super .export debug:0 ; .with super .export debug:1';
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStart({ execPath : '.with . .export debug:0' });
  a.appStart({ execPath : '.with . .export debug:1' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export debug:0' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export debug:1' });

  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'super.out' ) );
    var exp =
    [
      '.',
      './supermodule.debug.out.tgs',
      './supermodule.out.tgs',
      './supermodule.out.will.yml',
      './debug',
      './debug/File.debug.js',
      './release',
      './release/File.release.js'
    ];
    test.identical( files, exp );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Exported module::supermodule / build::export.debug with 2 file(s)' ) );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.imply withSubmodules:1 .with super .clean dry:1';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:1 .with super .clean dry:1' });
  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'super.out' ) );
    var exp =
    [
      '.',
      './supermodule.debug.out.tgs',
      './supermodule.out.tgs',
      './supermodule.out.will.yml',
      './debug',
      './debug/File.debug.js',
      './release',
      './release/File.release.js'
    ];
    test.identical( files, exp );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '8 at ' ) );
    test.true( _.strHas( op.output, 'Clean will delete 8 file(s)' ) );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = '.with super .clean';
    return null;
  });

  a.appStart({ execPath : '.with super .clean' });
  a.ready.then( ( op ) =>
  {
    var files = a.find( a.abs( 'super.out' ) );
    test.identical( files, [] );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted 8 file(s)' ) );
    return null;
  });

  /* - */

  return a.ready;
}

exportImportMultiple.rapidity = -1;

//

function exportBroken( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMultipleBroken' );

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = '.export debug:1';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.export debug:1' })
  .then( ( op ) =>
  {

    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './submodule.debug.out.tgs', './submodule.out.will.yml', './debug', './debug/File.debug.js' ] );
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'out/debug' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/release' ) ) );

    test.true( _.strHas( op.output, 'submodule.debug.out.tgs' ) );
    test.true( _.strHas( op.output, 'out/submodule.out.will.yml' ) );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/submodule.out.will.yml' ) );
    outfile = outfile.module[ 'submodule.out' ];

    var exported =
    {
      'export.debug' :
      {
        version : '0.0.1',
        recursive : 0,
        withIntegrated : 2,
        tar : 1,
        criterion :
        {
          default : 1,
          debug : 1,
          raw : 1,
          export : 1
        },
        exportedReflector : 'reflector::exported.export.debug',
        exportedFilesReflector : 'reflector::exported.files.export.debug',
        exportedDirPath : 'path::exported.dir.export.debug',
        exportedFilesPath : 'path::exported.files.export.debug',
        archiveFilePath : 'path::archiveFile.export.debug',
      }
    };
    test.identical( outfile.exported, exported );

    var exportedReflector =
    {
      mandatory : 1,
      src :
      {
        filePath : { '**' : '' },
        prefixPath : 'debug'
      },
      criterion :
      {
        generated : 1,
        default : 1,
        debug : 1,
        raw : 1,
        export : 1
      },
      dstRewritingOnlyPreserving : 1,
      linkingAction : 'hardLinkMaybe',
    }
    test.identical( outfile.reflector[ 'exported.export.debug' ], exportedReflector );

    var exportedReflectorFiles =
    {
      recursive : 0,
      src :
      {
        filePath : { 'path::exported.files.export.debug' : '' },
        basePath : '.',
        prefixPath : 'path::exported.dir.export.debug',
        recursive : 0,
      },
      criterion :
      {
        generated : 1,
        default : 1,
        debug : 1,
        raw : 1,
        export : 1
      },
    }

    test.identical( outfile.reflector[ 'exported.files.export.debug' ], exportedReflectorFiles );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportDoc( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMultipleDoc' );

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = 'export submodule';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    a.fileProvider.filesDelete( a.abs( 'doc.out' ) );
    return null;
  });

  a.appStart({ execPath : '.with . .export export.doc' });
  a.appStart({ execPath : '.with . .export export.debug' });
  a.appStart({ execPath : '.with . .export export.' });
  a.appStart({ execPath : '.imply withSubmodules:1 .with doc .build doc:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './submodule.default-debug-raw.out.tgs',
      './submodule.default-raw.out.tgs',
      './submodule.out.will.yml',
      './debug',
      './debug/File.debug.js',
      './release',
      './release/File.release.js'
    ];
    test.identical( files, exp );

    var files = a.find( a.abs( 'doc.out' ) );
    test.identical( files, [ '.', './file.md' ] );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportImport( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoExported' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export';
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export debug:0' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export debug:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.fileProvider.dirRead( a.abs( 'super.out' ) );
    test.identical( files, [ 'debug', 'release', 'supermodule.out.will.yml' ] );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportBrokenNoreflector( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportBrokenNoreflector' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.with submodule .reflectors.list predefined:0'
    return null;
  })

  a.appStart({ execPath : '.with submodule .reflectors.list predefined:0' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::' ), 2 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::reflect.proto' ), 1 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::exported.files.export' ), 1 );
    return null;
  })

  a.appStart({ execPath : '.with module/submodule .export' })
  a.appStart({ execPath : '.with submodule .reflectors.list predefined:0' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::' ), 3 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::reflect.proto' ), 1 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::exported.export' ), 1 );
    test.identical( _.strCount( op.output, 'module::submodule / reflector::exported.files.export' ), 1 );
    return null;
  })

  return a.ready;
} /* end of function exportBrokenNoreflector */

exportBrokenNoreflector.description =
`
removed reflector::exported.export is not obstacle to list out file
`

exportBrokenNoreflector.timeOut = 500000;

//

function exportCourrputedOutfileUnknownSection( test )
{
  let context = this;
  let a = context.assetFor( test, 'corruptedOutfileUnknownSection' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with sub .export debug:1';
    return null;
  });

  a.appStart( '.with sub .export debug:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'sub.out' ) );
    test.identical( files, [ '.', './sub.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'sub.out/sub.out.will.yml' ) );
    outfile = outfile.module[ 'sub.out' ];
    var exported = _.setFrom( _.props.keys( _.select( outfile, 'exported/*' ) ) );
    var exp = _.setFrom( [ 'export.debug' ] );
    test.identical( exported, exp );

    test.identical( _.strCount( op.output, '. Read 2 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, '! Failed to open .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Out-willfile should not have section(s) : "unknown_section"' ), 1 );
    test.identical( _.strCount( op.output, /Exported module::sub \/ build::export.debug with .* file\(s\) in .*/ ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportCourruptedOutfileSyntax( test )
{
  let context = this;
  let a = context.assetFor( test, 'corruptedOutfileSyntax' );
  a.reflect();

  /* */

  a.appStart( '.with sub .export debug:1' )
  .then( ( op ) =>
  {
    test.case = '.with sub .export debug:1';
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'sub.out' ) );
    test.identical( files, [ '.', './sub.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'sub.out/sub.out.will.yml' ) );
    outfile = outfile.module[ 'sub.out' ]
    var exported = _.setFrom( _.props.keys( _.select( outfile, 'exported/*' ) ) );
    var exp = _.setFrom( [ 'export.debug' ] );
    test.identical( exported, exp );

    test.identical( _.strCount( op.output, '. Read 2 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, '! Failed to open .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open willfile' ), 1 );
    var exp = 'Failed to convert from "string" to "structure" by encoder yaml:string.utf8->structure';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, /Exported .*module::sub \/ build::export.debug.*/ ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportCourruptedSubmodulesDisabled( test )
{
  let context = this;
  let a = context.assetFor( test, 'corruptedSubmodulesDisabled' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.with super .export debug:1';
    return null;
  })

  a.appStart( '.with super .export debug:1' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'super.out' ) );
    test.identical( files, [ '.', './supermodule.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'super.out/supermodule.out.will.yml' ) );
    var exported = _.setFrom( _.props.keys( _.select( outfile.module[ outfile.root[ 0 ] ], 'exported/*' ) ) );
    var exp = _.setFrom( [ 'export.debug' ] );
    test.identical( exported, exp );

    test.identical( _.strCount( op.output, '. Read 2 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 3 file(s) in' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportDisabledModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportDisabledModule' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export';
    a.reflect();
    return null;
  });

  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/disabled.out.will.yml' ) );
    var exp = _.setFrom
    ([
      'disabled.out',
      '../',
      '../.module/ModuleForTesting1/',
      '../.module/ModuleForTesting1/out/wModuleForTesting1.out',
      '../.module/ModuleForTesting2/',
      '../.module/ModuleForTesting2/out/wModuleForTesting2.out'
    ]);
    var got = _.setFrom( _.props.keys( outfile.module ) );
    test.identical( got, exp );

    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with . .export';
    a.reflect();
    return null;
  });

  a.appStart( '.with . .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/disabled.out.will.yml' ) );
    var exp = _.setFrom
    ([
      'disabled.out',
      '../',
      '../.module/ModuleForTesting1/',
      '../.module/ModuleForTesting1/out/wModuleForTesting1.out',
      '../.module/ModuleForTesting2/',
      '../.module/ModuleForTesting2/out/wModuleForTesting2.out'
    ]);
    var got = _.setFrom( _.props.keys( outfile.module ) );
    test.identical( got, exp );

    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with * .export';
    a.reflect();
    return null;
  });

  a.appStartNonThrowing( '.with * .export' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var exp = [ 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Found no willfile at' ), 1 );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withDisabled:1; .with * .export';
    a.reflect();
    return null;
  });

  a.appStartNonThrowing( '.imply withDisabled:1; .with * .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/disabled.out.will.yml' ) );
    var exp = _.setFrom
    ([
      'disabled.out',
      '../',
      '../.module/ModuleForTesting1/',
      '../.module/ModuleForTesting1/out/wModuleForTesting1.out',
      '../.module/ModuleForTesting2/',
      '../.module/ModuleForTesting2/out/wModuleForTesting2.out'
    ]);
    var got = _.setFrom( _.props.keys( outfile.module ) );
    test.identical( got, exp );

    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

exportDisabledModule.rapidity = -1;
exportDisabledModule.timeOut = 300000;
exportDisabledModule.description =
`
- disabled module should be exported if picked explicitly
- disabled module should not be exported if picked with glob
`;

//

function exportOutdated( test )
{
  let context = this;
  let a = context.assetFor( test, 'inconsistentOutfile' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.with sub .export debug:1';
    return null;
  })

  a.appStart( '.with sub .export debug:1' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'sub.out' ) );
    test.identical( files, [ '.', './sub.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'sub.out/sub.out.will.yml' ) );
    outfile = outfile.module[ 'sub.out' ];
    var exported = _.setFrom( _.props.keys( _.select( outfile, 'exported/*' ) ) );
    var exp = _.setFrom( [ 'export.debug' ] );
    test.identical( exported, exp );

    test.identical( _.strCount( op.output, '. Read 2 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, /Exported .*module::sub \/ build::export.debug.*/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'export release, but input willfile is changed';
    a.fileProvider.fileAppend( a.abs( 'sub.ex.will.yml' ), '\n' );
    return null;
  })

  a.appStart( '.with sub .export debug:0' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var files = a.find( a.abs( 'sub.out' ) );
    test.identical( files, [ '.', './sub.out.will.yml' ] );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'sub.out/sub.out.will.yml' ) );
    outfile = outfile.module[ 'sub.out' ];
    var exported = _.setFrom( _.props.keys( _.select( outfile, 'exported/*' ) ) );
    var exp = _.setFrom( [ 'export.' ] );
    test.identical( exported, exp );

    test.identical( _.strCount( op.output, '. Read 2 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, '! Outdated .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open willfile' ), 0 );
    test.identical( _.strCount( op.output, 'Out-willfile is inconsistent with its in-willfiles' ), 0 );
    test.identical( _.strCount( op.output, /Exported .*module::sub \/ build::export.*/ ), 1 );

    return null;
  })

  /* - */

  return a.ready;
}

//

function exportWholeModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWhole' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export whole module using in path';
    return null;
  });

  a.appStart({ execPath : '.with module/ .export' });
  a.appStart({ execPath : '.imply withSubmodules:1 .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './.will.yml', './proto', './proto/File1.s', './proto/dir', './proto/dir/File2.s' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function exportRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'resolvePathOfSubmodulesExported' );

  /* - */

  begin();

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with ab/ .export.recursive -- first';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with ab/ .export.recursive' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp = [ '.', './module-a.out.will.yml', './module-b.out.will.yml', './ab', './ab/module-ab.out.will.yml' ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, exp )

    var exp = 'Exported module::module-ab / module::module-a / build::proto.export with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    var exp = 'Exported module::module-ab / module::module-b / build::proto.export with 8 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::module-ab / build::proto.export with 13 file(s) in' ), 1 );
    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with ab/ .export.recursive -- second';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with ab/ .export.recursive' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp = [ '.', './module-a.out.will.yml', './module-b.out.will.yml', './ab', './ab/module-ab.out.will.yml' ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, exp )

    var exp = 'Exported module::module-ab / module::module-a / build::proto.export with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    var exp = 'Exported module::module-ab / module::module-b / build::proto.export with 8 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::module-ab / build::proto.export with 13 file(s) in' ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflectMinimal();
      a.fileProvider.fileWrite( a.abs( 'proto/b/-Excluded.js' ), 'console.log( \'b/-Ecluded.js\' );' );
      a.fileProvider.filesDelete( a.abs( 'out' ) );
      return null;
    });
  }
}

//

function exportRecursiveUsingSubmodule( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMultipleExported' );
  a.reflectMinimal();
  a.fileProvider.filesDelete( a.abs( 'super.out' ) );
  a.fileProvider.filesDelete( a.abs( 'sub.out' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with super .export.recursive debug:1 -- first';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export.recursive debug:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub.out',
      './sub.out/submodule.debug.out.tgs',
      './sub.out/submodule.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './super.out',
      './super.out/supermodule.debug.out.tgs',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::submodule / build::export.debug with 2 file(s)';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 2 file(s) in' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with super .export.recursive debug:1 -- second';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export.recursive debug:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub.out',
      './sub.out/submodule.debug.out.tgs',
      './sub.out/submodule.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './super.out',
      './super.out/supermodule.debug.out.tgs',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::submodule / build::export.debug with 2 file(s)';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 2 file(s) in' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with super .export.recursive debug:0 -- first';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export.recursive debug:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub.out',
      './sub.out/submodule.debug.out.tgs',
      './sub.out/submodule.out.tgs',
      './sub.out/submodule.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './sub.out/release',
      './sub.out/release/File.release.js',
      './super.out',
      './super.out/supermodule.debug.out.tgs',
      './super.out/supermodule.out.tgs',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/release',
      './super.out/release/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::submodule / build::export. with 2 file(s)';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export. with 2 file(s) in' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with super .export.recursive debug:0 -- second'
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with super .export.recursive debug:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './.ex.will.yml',
      './.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub.out',
      './sub.out/submodule.debug.out.tgs',
      './sub.out/submodule.out.tgs',
      './sub.out/submodule.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './sub.out/release',
      './sub.out/release/File.release.js',
      './super.out',
      './super.out/supermodule.debug.out.tgs',
      './super.out/supermodule.out.tgs',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/release',
      './super.out/release/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::submodule / build::export. with 2 file(s)';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export. with 2 file(s) in' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

exportRecursiveUsingSubmodule.timeOut = 300000;

//

function exportRecursiveLocal( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmodules' );

  /* - */

  begin();

  /* */

  a.appStart({ execPath : '.with */* .clean' });
  a.appStart({ execPath : '.imply withSubmodules:2 .with */* .export' });
  a.ready.then( ( op ) =>
  {
    test.case = 'first';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 9 );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with ab/ .resources.list' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );

    test.identical( _.strCount( op.output, 'About' ), 1 );
    test.identical( _.strCount( op.output, 'module::module-ab / path::export' ), 1 );
    test.true( _.strCount( op.output, 'module::module-ab /' ) >= 53 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.imply withSubmodules:2 .with */* .export' });
  a.ready.then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 9 );
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with ab/ .resources.list' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );

    test.identical( _.strCount( op.output, 'About' ), 1 );
    test.identical( _.strCount( op.output, 'module::module-ab / path::export' ), 1 );
    test.true( _.strCount( op.output, 'module::module-ab /' ) >= 53 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflectMinimal();
      a.fileProvider.fileWrite( a.abs( 'proto/b/-Excluded.js' ), 'console.log( \'b/-Ecluded.js\' );' );
      return null;
    });
  }
}

exportRecursiveLocal.rapidity = -1;
exportRecursiveLocal.timeOut = 300000;

//

function exportDotless( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoDotlessExported' );
  a.reflectMinimal();
  a.fileProvider.filesDelete( a.abs( 'super.out' ) );
  a.fileProvider.filesDelete( a.abs( 'sub.out' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .export.recursive debug:1';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .export.recursive debug:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './ex.will.yml',
      './im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/ex.will.yml',
      './sub/im.will.yml',
      './sub.out',
      './sub.out/sub.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './super.out',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/debug/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::sub / build::export.debug with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 3 file(s) in' ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with . .export.recursive debug:0';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with . .export.recursive debug:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './ex.will.yml',
      './im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/ex.will.yml',
      './sub/im.will.yml',
      './sub.out',
      './sub.out/sub.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './sub.out/release',
      './sub.out/release/File.release.js',
      './super.out',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/debug/File.release.js',
      './super.out/release',
      './super.out/release/File.debug.js',
      './super.out/release/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::sub / build::export. with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export. with 3 file(s) in' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

exportDotless.timeOut = 300000;

//

function exportDotlessSingle( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoDotlessSingleExported' );
  a.reflectMinimal();
  a.fileProvider.filesDelete( a.abs( 'super.out' ) );
  a.fileProvider.filesDelete( a.abs( 'sub.out' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export.recursive debug:1';
    return null;
  });

  a.appStart({ execPath : '.export.recursive debug:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml',
      './sub.out',
      './sub.out/sub.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './super.out',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/debug/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::sub / build::export.debug with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 3 file(s) in' ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with . .export.recursive debug:0';
    return null;
  });

  a.appStart({ execPath : '.imply withSubmodules:2 .with . .export.recursive debug:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml',
      './sub.out',
      './sub.out/sub.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './sub.out/release',
      './sub.out/release/File.release.js',
      './super.out',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/debug/File.release.js',
      './super.out/release',
      './super.out/release/File.debug.js',
      './super.out/release/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::sub / build::export. with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export. with 3 file(s) in' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

exportDotlessSingle.timeOut = 300000;

//

function exportTracing( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoDotlessSingleExported' );
  a.reflectMinimal();
  a.fileProvider.filesDelete( a.abs( 'super.out' ) );
  a.fileProvider.filesDelete( a.abs( 'sub.out' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .export.recursive debug:1';
    return null;
  });

  a.appStartNonThrowing({ execPath : '.imply withSubmodules:2 .export.recursive debug:1', currentPath : a.abs( './proto' ) });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml',
      './sub.out',
      './sub.out/sub.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './super.out',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/debug/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::sub / build::export.debug with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 3 file(s) in' ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .with . .export.recursive debug:1';
    return null;
  });

  a.appStartNonThrowing({ execPath : '.imply withSubmodules:2 .with . .export.recursive debug:1', currentPath : a.abs( './proto' ) });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.description = 'files';
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml',
      './sub.out',
      './sub.out/sub.out.will.yml',
      './sub.out/debug',
      './sub.out/debug/File.debug.js',
      './super.out',
      './super.out/supermodule.out.will.yml',
      './super.out/debug',
      './super.out/debug/File.debug.js',
      './super.out/debug/File.release.js'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '**/+**' : 0 } });
    test.identical( files, exp );

    var exp = 'Exported module::supermodule / module::sub / build::export.debug with 2 file(s) in';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::supermodule / build::export.debug with 3 file(s) in' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

exportTracing.timeOut = 300000;

//

function exportRewritesOutFile( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportRewritesOutFile' );
  a.reflectMinimal();
  a.fileProvider.fileCopy( a.abs( 'copy.will.yml' ), a.abs( '.will.yml' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export module with two exports'
    return null;
  });

  a.appStart({ execPath : '.export export1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'out/exportRewritesOutFile.out.will.yml' ) ) );
    let outFile = a.fileProvider.fileRead({ filePath : a.abs( 'out/exportRewritesOutFile.out.will.yml' ), encoding : 'yaml' });
    let build = outFile.module[ outFile.root[ 0 ] ].build;
    test.identical( _.props.keys( build ), [ 'export1', 'export2' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'remove second export build then export again';
    a.fileProvider.fileCopy( a.abs( '.will.yml' ), a.abs( '.will.single-export.yml' ) )
    return null;
  });

  a.appStart({ execPath : '.export export1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'out/exportRewritesOutFile.out.will.yml' ) ) );
    let outFile = a.fileProvider.fileRead({ filePath : a.abs( 'out/exportRewritesOutFile.out.will.yml' ), encoding : 'yaml' });
    let build = outFile.module[ outFile.root[ 0 ] ].build;
    test.identical( _.props.keys( build ), [ 'export1' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'restore second export, then export again';
    a.fileProvider.fileCopy( a.abs( '.will.yml' ), a.abs( 'copy.will.yml' ) )
    return null;
  });

  a.appStart({ execPath : '.export export1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( 'out/exportRewritesOutFile.out.will.yml' ) ) );
    let outFile = a.fileProvider.fileRead({ filePath : a.abs( 'out/exportRewritesOutFile.out.will.yml' ), encoding : 'yaml' });
    let build = outFile.module[ outFile.root[ 0 ] ].build;
    test.identical( _.props.keys( build ), [ 'export1', 'export2' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function exportWithRemoteSubmodulesMin( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemoteMin' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export';
    return null;
  });

  a.appStart( '.with group1/a .export' );
  a.appStart( '.imply withSubmodules:2 .with z .export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 12 );
    test.identical( _.strCount( op.output, '+ 2/4 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::z were downloaded' ), 1 );

    var exp =
    [
      '.',
      './z.will.yml',
      './.module',
      './group1',
      './group1/a.will.yml',
      './group1/.module',
      './group1/out',
      './group1/out/a.out.will.yml',
      './group1/out/debug',
      './group1/out/debug/node_modules',
      './group1/out/debug/node_modules/wmodulefortesting1',
      './group1/out/debug/node_modules/wmodulefortesting1b',
      './group1/out/debug/wtools',
      './group1/out/debug/wtools/testing',
      './group1/out/debug/wtools/testing/Common.s',
      './group1/out/debug/wtools/testing/l1',
      './group1/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group1/out/debug/wtools/testing/l3',
      './group1/out/debug/wtools/testing/l3/testing1b',
      './group1/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './out',
      './out/z.out.will.yml',
      './out/debug',
      './out/debug/node_modules',
      './out/debug/node_modules/wmodulefortesting1',
      './out/debug/node_modules/wmodulefortesting1a',
      './out/debug/node_modules/wmodulefortesting1b',
      './out/debug/wtools',
      './out/debug/wtools/testing',
      './out/debug/wtools/testing/Common.s',
      './out/debug/wtools/testing/l1',
      './out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './out/debug/wtools/testing/l2',
      './out/debug/wtools/testing/l2/testing1a',
      './out/debug/wtools/testing/l2/testing1a/ModuleForTesting1a.s',
      './out/debug/wtools/testing/l3',
      './out/debug/wtools/testing/l3/testing1b',
      './out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
    ];
    var files = a.findNoModules( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

exportWithRemoteSubmodulesMin.timeOut = 600000;
exportWithRemoteSubmodulesMin.description =
`
exporting of hierarchy with remote submodules throw no error and produce out files
`;

//

function exportWithRemoteSubmodulesMinRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemoteMin' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export'
    return null;
  });

  a.appStart( '.with "**" .clean' );
  a.appStart( '.imply withSubmodules:2 .with "**" .export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 12 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::z / module::a were downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/4 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::z were downloaded' ), 1 );

    var exp =
    [
      '.',
      './z.will.yml',
      './.module',
      './group1',
      './group1/a.will.yml',
      './group1/.module',
      './group1/out',
      './group1/out/a.out.will.yml',
      './group1/out/debug',
      './group1/out/debug/node_modules',
      './group1/out/debug/node_modules/wmodulefortesting1',
      './group1/out/debug/node_modules/wmodulefortesting1b',
      './group1/out/debug/wtools',
      './group1/out/debug/wtools/testing',
      './group1/out/debug/wtools/testing/Common.s',
      './group1/out/debug/wtools/testing/l1',
      './group1/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group1/out/debug/wtools/testing/l3',
      './group1/out/debug/wtools/testing/l3/testing1b',
      './group1/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './out',
      './out/z.out.will.yml',
      './out/debug',
      './out/debug/node_modules',
      './out/debug/node_modules/wmodulefortesting1',
      './out/debug/node_modules/wmodulefortesting1a',
      './out/debug/node_modules/wmodulefortesting1b',
      './out/debug/wtools',
      './out/debug/wtools/testing',
      './out/debug/wtools/testing/Common.s',
      './out/debug/wtools/testing/l1',
      './out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './out/debug/wtools/testing/l2',
      './out/debug/wtools/testing/l2/testing1a',
      './out/debug/wtools/testing/l2/testing1a/ModuleForTesting1a.s',
      './out/debug/wtools/testing/l3',
      './out/debug/wtools/testing/l3/testing1b',
      './out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
    ];
    var files = a.findNoModules( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

exportWithRemoteSubmodulesMinRecursive.description =
`
exporting of hierarchy with remote submodules throw no error and produce out files
`;

//

function exportWithRemoteSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export';
    return null;
  });

  a.appStart( '.with group1/group10/a0 .clean' );
  a.appStart( '.with group1/a .clean' );
  a.appStart( '.with group1/b .clean' );
  a.appStart( '.with group2/c .clean' );
  a.appStart( '.with group1/group10/a0 .export' );
  a.appStart( '.imply withSubmodules:1 .with group1/a .export' );
  a.appStart( '.imply withSubmodules:1 .with group1/b .export' );
  a.appStart( '.imply withSubmodules:2 .with group2/c .export' );
  a.appStart( '.imply withSubmodules:2 .with z .export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 24 );
    test.identical( _.strCount( op.output, '+ 1/8 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/4 submodule(s) of module::z were downloaded' ), 1 );

    var exp =
    [
      '.',
      './.module',
      './.module/ModuleForTesting1b',
      './.module/ModuleForTesting1b/.circleci',
      './.module/ModuleForTesting1b/.github',
      './.module/ModuleForTesting1b/.github/workflows',
      './.module/ModuleForTesting1b/doc',
      './.module/ModuleForTesting1b/out',
      './.module/ModuleForTesting1b/proto',
      './.module/ModuleForTesting1b/proto/node_modules',
      './.module/ModuleForTesting1b/proto/wtools',
      './.module/ModuleForTesting1b/proto/wtools/testing',
      './.module/ModuleForTesting1b/proto/wtools/testing/l3',
      './.module/ModuleForTesting1b/proto/wtools/testing/l3/testing1b',
      './.module/ModuleForTesting1b/sample',
      './.module/ModuleForTesting1b/sample/trivial',
      './group1',
      './group1/.module',
      './group1/.module/ModuleForTesting1',
      './group1/.module/ModuleForTesting1/.circleci',
      './group1/.module/ModuleForTesting1/.github',
      './group1/.module/ModuleForTesting1/.github/workflows',
      './group1/.module/ModuleForTesting1/doc',
      './group1/.module/ModuleForTesting1/out',
      './group1/.module/ModuleForTesting1/proto',
      './group1/.module/ModuleForTesting1/proto/node_modules',
      './group1/.module/ModuleForTesting1/proto/wtools',
      './group1/.module/ModuleForTesting1/proto/wtools/testing',
      './group1/.module/ModuleForTesting1/proto/wtools/testing/l1',
      './group1/.module/ModuleForTesting1/sample',
      './group1/.module/ModuleForTesting1/sample/trivial',
      './group1/.module/ModuleForTesting12',
      './group1/.module/ModuleForTesting12/.circleci',
      './group1/.module/ModuleForTesting12/.github',
      './group1/.module/ModuleForTesting12/.github/workflows',
      './group1/.module/ModuleForTesting12/doc',
      './group1/.module/ModuleForTesting12/out',
      './group1/.module/ModuleForTesting12/proto',
      './group1/.module/ModuleForTesting12/proto/node_modules',
      './group1/.module/ModuleForTesting12/proto/wtools',
      './group1/.module/ModuleForTesting12/proto/wtools/testing',
      './group1/.module/ModuleForTesting12/proto/wtools/testing/l3',
      './group1/.module/ModuleForTesting12/proto/wtools/testing/l3/testing12',
      './group1/.module/ModuleForTesting12/sample',
      './group1/.module/ModuleForTesting12/sample/trivial',
      './group1/.module/ModuleForTesting1b',
      './group1/.module/ModuleForTesting1b/.circleci',
      './group1/.module/ModuleForTesting1b/.github',
      './group1/.module/ModuleForTesting1b/.github/workflows',
      './group1/.module/ModuleForTesting1b/doc',
      './group1/.module/ModuleForTesting1b/out',
      './group1/.module/ModuleForTesting1b/proto',
      './group1/.module/ModuleForTesting1b/proto/node_modules',
      './group1/.module/ModuleForTesting1b/proto/wtools',
      './group1/.module/ModuleForTesting1b/proto/wtools/testing',
      './group1/.module/ModuleForTesting1b/proto/wtools/testing/l3',
      './group1/.module/ModuleForTesting1b/proto/wtools/testing/l3/testing1b',
      './group1/.module/ModuleForTesting1b/sample',
      './group1/.module/ModuleForTesting1b/sample/trivial',
      './group1/group10',
      './group1/group10/.module',
      './group1/group10/.module/ModuleForTesting1',
      './group1/group10/.module/ModuleForTesting1/.circleci',
      './group1/group10/.module/ModuleForTesting1/.github',
      './group1/group10/.module/ModuleForTesting1/.github/workflows',
      './group1/group10/.module/ModuleForTesting1/doc',
      './group1/group10/.module/ModuleForTesting1/out',
      './group1/group10/.module/ModuleForTesting1/proto',
      './group1/group10/.module/ModuleForTesting1/proto/node_modules',
      './group1/group10/.module/ModuleForTesting1/proto/wtools',
      './group1/group10/.module/ModuleForTesting1/proto/wtools/testing',
      './group1/group10/.module/ModuleForTesting1/proto/wtools/testing/l1',
      './group1/group10/.module/ModuleForTesting1/sample',
      './group1/group10/.module/ModuleForTesting1/sample/trivial',
      './group1/group10/.module/ModuleForTesting1b',
      './group1/group10/.module/ModuleForTesting1b/.circleci',
      './group1/group10/.module/ModuleForTesting1b/.github',
      './group1/group10/.module/ModuleForTesting1b/.github/workflows',
      './group1/group10/.module/ModuleForTesting1b/doc',
      './group1/group10/.module/ModuleForTesting1b/out',
      './group1/group10/.module/ModuleForTesting1b/proto',
      './group1/group10/.module/ModuleForTesting1b/proto/node_modules',
      './group1/group10/.module/ModuleForTesting1b/proto/wtools',
      './group1/group10/.module/ModuleForTesting1b/proto/wtools/testing',
      './group1/group10/.module/ModuleForTesting1b/proto/wtools/testing/l3',
      './group1/group10/.module/ModuleForTesting1b/proto/wtools/testing/l3/testing1b',
      './group1/group10/.module/ModuleForTesting1b/sample',
      './group1/group10/.module/ModuleForTesting1b/sample/trivial',
      './group1/group10/out',
      './group1/group10/out/debug',
      './group1/group10/out/debug/node_modules',
      './group1/group10/out/debug/wtools',
      './group1/group10/out/debug/wtools/testing',
      './group1/group10/out/debug/wtools/testing/l1',
      './group1/group10/out/debug/wtools/testing/l3',
      './group1/group10/out/debug/wtools/testing/l3/testing1b',
      './group1/out',
      './group1/out/debug',
      './group1/out/debug/node_modules',
      './group1/out/debug/wtools',
      './group1/out/debug/wtools/testing',
      './group1/out/debug/wtools/testing/l1',
      './group1/out/debug/wtools/testing/l3',
      './group1/out/debug/wtools/testing/l3/testing12',
      './group1/out/debug/wtools/testing/l3/testing1b',
      './group2',
      './group2/.module',
      './group2/.module/ModuleForTesting12ab',
      './group2/.module/ModuleForTesting12ab/.circleci',
      './group2/.module/ModuleForTesting12ab/.github',
      './group2/.module/ModuleForTesting12ab/.github/workflows',
      './group2/.module/ModuleForTesting12ab/doc',
      './group2/.module/ModuleForTesting12ab/out',
      './group2/.module/ModuleForTesting12ab/proto',
      './group2/.module/ModuleForTesting12ab/proto/node_modules',
      './group2/.module/ModuleForTesting12ab/proto/wtools',
      './group2/.module/ModuleForTesting12ab/proto/wtools/testing',
      './group2/.module/ModuleForTesting12ab/proto/wtools/testing/l4',
      './group2/.module/ModuleForTesting12ab/proto/wtools/testing/l4/testing12ab',
      './group2/.module/ModuleForTesting12ab/sample',
      './group2/.module/ModuleForTesting12ab/sample/trivial',
      './group2/out',
      './group2/out/debug',
      './group2/out/debug/node_modules',
      './group2/out/debug/wtools',
      './group2/out/debug/wtools/testing',
      './group2/out/debug/wtools/testing/l1',
      './group2/out/debug/wtools/testing/l3',
      './group2/out/debug/wtools/testing/l3/testing1b',
      './group2/out/debug/wtools/testing/l4',
      './group2/out/debug/wtools/testing/l4/testing12ab',
      './out',
      './out/debug',
      './out/debug/node_modules',
      './out/debug/wtools',
      './out/debug/wtools/testing',
      './out/debug/wtools/testing/l1',
      './out/debug/wtools/testing/l3',
      './out/debug/wtools/testing/l3/testing12',
      './out/debug/wtools/testing/l3/testing1b',
      './out/debug/wtools/testing/l4',
      './out/debug/wtools/testing/l4/testing12ab',
    ];
    var files = a.findDirs( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

exportWithRemoteSubmodules.rapidity = -1;
exportWithRemoteSubmodules.timeOut = 400000;
exportWithRemoteSubmodules.description =
`
check there is no annoying information about lack of remote submodules of submodules
`;

//

function exportWithRemoteSubmodulesRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export';
    return null;
  });

  a.appStart( '.with "**" .clean' );
  a.appStart( '.imply withSubmodules:2 .with "**" .export.recursive' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 31 );
    test.identical( _.strCount( op.output, '+ 1/4 submodule(s) of module::z ' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/4 submodule(s) of module::z were downloaded' ), 1 );

    var exp =
    [
      '.',
      './z.will.yml',
      './.module',
      './group1',
      './group1/a.will.yml',
      './group1/b.will.yml',
      './group1/.module',
      './group1/group10',
      './group1/group10/a0.will.yml',
      './group1/group10/.module',
      './group1/group10/out',
      './group1/group10/out/a0.out.will.yml',
      './group1/group10/out/debug',
      './group1/group10/out/debug/node_modules',
      './group1/group10/out/debug/node_modules/wmodulefortesting1',
      './group1/group10/out/debug/node_modules/wmodulefortesting1b',
      './group1/group10/out/debug/wtools',
      './group1/group10/out/debug/wtools/testing',
      './group1/group10/out/debug/wtools/testing/Common.s',
      './group1/group10/out/debug/wtools/testing/l1',
      './group1/group10/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group1/group10/out/debug/wtools/testing/l3',
      './group1/group10/out/debug/wtools/testing/l3/testing1b',
      './group1/group10/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './group1/out',
      './group1/out/a.out.will.yml',
      './group1/out/b.out.will.yml',
      './group1/out/debug',
      './group1/out/debug/node_modules',
      './group1/out/debug/node_modules/wmodulefortesting1',
      './group1/out/debug/node_modules/wmodulefortesting12',
      './group1/out/debug/node_modules/wmodulefortesting1b',
      './group1/out/debug/wtools',
      './group1/out/debug/wtools/testing',
      './group1/out/debug/wtools/testing/Common.s',
      './group1/out/debug/wtools/testing/l1',
      './group1/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group1/out/debug/wtools/testing/l3',
      './group1/out/debug/wtools/testing/l3/testing12',
      './group1/out/debug/wtools/testing/l3/testing12/ModuleForTesting12.s',
      './group1/out/debug/wtools/testing/l3/testing1b',
      './group1/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './group2',
      './group2/c.will.yml',
      './group2/.module',
      './group2/out',
      './group2/out/c.out.will.yml',
      './group2/out/debug',
      './group2/out/debug/node_modules',
      './group2/out/debug/node_modules/wmodulefortesting1',
      './group2/out/debug/node_modules/wmodulefortesting12ab',
      './group2/out/debug/node_modules/wmodulefortesting1b',
      './group2/out/debug/wtools',
      './group2/out/debug/wtools/testing',
      './group2/out/debug/wtools/testing/Common.s',
      './group2/out/debug/wtools/testing/l1',
      './group2/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group2/out/debug/wtools/testing/l3',
      './group2/out/debug/wtools/testing/l3/testing1b',
      './group2/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './group2/out/debug/wtools/testing/l4',
      './group2/out/debug/wtools/testing/l4/testing12ab',
      './group2/out/debug/wtools/testing/l4/testing12ab/ModuleForTesting12ab.s',
      './out',
      './out/z.out.will.yml',
      './out/debug',
      './out/debug/node_modules',
      './out/debug/node_modules/wmodulefortesting1',
      './out/debug/node_modules/wmodulefortesting12',
      './out/debug/node_modules/wmodulefortesting12ab',
      './out/debug/node_modules/wmodulefortesting1b',
      './out/debug/wtools',
      './out/debug/wtools/testing',
      './out/debug/wtools/testing/Common.s',
      './out/debug/wtools/testing/l1',
      './out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './out/debug/wtools/testing/l3',
      './out/debug/wtools/testing/l3/testing12',
      './out/debug/wtools/testing/l3/testing12/ModuleForTesting12.s',
      './out/debug/wtools/testing/l3/testing1b',
      './out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './out/debug/wtools/testing/l4',
      './out/debug/wtools/testing/l4/testing12ab',
      './out/debug/wtools/testing/l4/testing12ab/ModuleForTesting12ab.s',
    ];
    var files = a.findNoModules( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

exportWithRemoteSubmodulesRecursive.rapidity = -1;
exportWithRemoteSubmodulesRecursive.timeOut = 800000;
exportWithRemoteSubmodulesRecursive.description =
`
check there is no annoying information about lack of remote submodules of submodules
`;

//

function exportDiffDownloadPathsRegular( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportDiffDownloadPathsRegular' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with c .export.recursive';
    a.reflect();
    return null;
  });

  a.appStart( '.imply withSubmodules:2 .with c .export.recursive' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp );

    var exp = [ 'a.out.will.yml', 'c.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Opened .' ), 28 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 2 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 6 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 10 );
    test.identical( _.strCount( op.output, '+ 6/7 submodule(s) of module::c were downloaded' ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'export recursive twice';
    a.reflect();
    return null;
  });
  a.appStart( '.imply withSubmodules:2 .with c .export.recursive' );
  a.appStart( '.imply withSubmodules:2 .with c .export.recursive' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp );

    var exp = [ 'a.out.will.yml', 'c.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 30 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 10 );
    test.identical( _.strCount( op.output, 'submodule(s) of' ), 0 );

    return null;
  });

  /* - */

  return a.ready;
}

exportDiffDownloadPathsRegular.timeOut = 300000;

//

function exportHierarchyRemote( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .export.recursive';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.appStart( '.imply withSubmodules:2 .with z .export.recursive' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );
    var exp = [ 'debug', 'z.out.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );
    var exp = [ 'a.out.will.yml', 'b.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/out' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );
    var exp = [ 'a0.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/out' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );
    var exp = [ 'c.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/out' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 31 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 3 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 4 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 12 );
    test.identical( _.strCount( op.output, '+ 4/8 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'module::z were downloaded' ), 2 );
    test.identical( _.strCount( op.output, 'were downloaded' ), 6 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:1 .with ** .export.recursive';
    a.reflect();
    return null;
  });

  a.appStart( '.imply withSubmodules:2 .with ** .clean recursive:2' );
  a.appStart( '.imply withSubmodules:2 .with ** .export.recursive' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );
    var exp = [ 'debug', 'z.out.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );
    var exp = [ 'a.out.will.yml', 'b.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/out' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );
    var exp = [ 'a0.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/out' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );
    var exp = [ 'c.out.will.yml', 'debug' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/out' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 31 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 3 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 4 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 12 );
    test.identical( _.strCount( op.output, 'module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'were downloaded' ), 8 );

    return null;
  });

  /* - */

  return a.ready;
}

exportHierarchyRemote.rapidity = -1;
exportHierarchyRemote.timeOut = 500000;
exportHierarchyRemote.description =
`
- "with module .export.recursive" should export the same number of modules as "with ** .export.recursive"
- each format of recursive export command should export each instance of each module exactly one time
- each instance of a module is exported once even if module has several instances in different location
`;

//

function exportWithDisabled( test )
{
  let context = this;
  let a = context.assetFor( test, 'brokenOut' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withDisabled:1 ; .with */* .export.recursive';
    a.reflectMinimal();
    return null;
  });

  a.appStart( '.imply withDisabled:1 ; .with */* .export.recursive' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './module1',
      './module1/.ex.will.yml',
      './module1/.im.will.yml',
      './module1/out',
      './module1/out/module1.out.will.yml',
      './module1/proto',
      './module1/proto/File1.txt',
      './module2',
      './module2/will.yml',
      './module2/out',
      './module2/out/module2.out.will.yml'
    ];
    var files = a.find( a.abs( '.' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Exported' ), 2 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strHas( op.output, '! Outdated' ), false );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withDisabled:0 ; .with */* .export.recursive';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'module1/out' ) );
    return null;
  });

  a.appStart( '.imply withDisabled:0 ; .with */* .export.recursive' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './module1',
      './module1/.ex.will.yml',
      './module1/.im.will.yml',
      './module1/proto',
      './module1/proto/File1.txt',
      './module2',
      './module2/will.yml',
      './module2/out',
      './module2/out/module2.out.will.yml'
    ];
    var files = a.find( a.abs( '.' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Exported' ), 1 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strHas( op.output, '! Outdated' ), false );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.imply withDisabled:0 ; .with */* .export';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'module1/out' ) );
    return null;
  });

  a.appStart( '.imply withDisabled:0 ; .with */* .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './module1',
      './module1/.ex.will.yml',
      './module1/.im.will.yml',
      './module1/proto',
      './module1/proto/File1.txt',
      './module2',
      './module2/will.yml',
      './module2/out',
      './module2/out/module2.out.will.yml'
    ];
    var files = a.find( a.abs( '.' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Exported' ), 1 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strHas( op.output, '! Outdated' ), false );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with */* .export.recursive';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'module1/out' ) );
    return null;
  });

  a.appStart( '.with */* .export.recursive' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './module1',
      './module1/.ex.will.yml',
      './module1/.im.will.yml',
      './module1/proto',
      './module1/proto/File1.txt',
      './module2',
      './module2/will.yml',
      './module2/out',
      './module2/out/module2.out.will.yml'
    ];
    var files = a.find( a.abs( '.' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Exported' ), 1 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strHas( op.output, '! Outdated' ), false );

    return null;
  });

  /* - */

  return a.ready;
}

exportWithDisabled.timeOut = 300000;

//

function exportOutResourceWithoutGeneratedCriterion( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportOutResourceWithoutGeneratedCriterion' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download';
    a.reflect();
    return null;
  })

  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'debug', 'wModuleForTesting12ab.out.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, exp );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/wModuleForTesting12ab.out.will.yml' ) );
    var exp =
    [
      'module.willfiles',
      'module.common',
      'module.original.willfiles',
      'module.peer.willfiles',
      'module.peer.in',
      'download',
      'repository',
      'origins',
      'bugtracker',
      'in',
      'out',
      'temp',
      'proto',
      'export',
      'doc',
      'out.raw.debug',
      'out.compiled.debug',
      'out.raw.release',
      'out.compiled.release',
      'entry.proto.no.tests',
      'entry.proto.only.tests',
      'entry.out.raw.debug.debug',
      'entry.out.raw.debug.release',
      'entry.out.compiled.debug.debug',
      'entry.out.compiled.debug.release',
      'npm.proto.entry',
      'exported.dir.proto.export',
      'exported.files.proto.export',
    ];
    var got = _.props.keys( outfile.module[ 'wModuleForTesting12ab.out' ].path );
    test.identical( _.setFrom( got ), _.setFrom( exp ) );

    return null;
  });

  /* - */

  return a.ready;
}

//

function exportImplicit( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportImplicit' );

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.with explicit/ .export';
    a.reflect();
    return null;
  })

  a.appStart( '.with explicit/ .clean' )
  a.appStart( '.with explicit/ .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Exported module::explicit / build::export with 4 file(s)' ), 1 );

    var exp = [ '.', './explicit.out.will.yml', './will.yml', './proto', './proto/File.js' ];
    var files = a.find( a.abs( 'explicit' ) );
    test.identical( files, exp );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'explicit/explicit.out.will.yml' ) );

    /* */

    var exp = [ 'export' ];
    var got = _.props.keys( outfile.module[ './' ].build );
    test.identical( got, exp );
    var exp = [];
    var got = _.props.keys( outfile.module[ './' ].step );
    test.identical( got, exp );
    var exp =
    [
      'in',
      'out',
      'module.willfiles',
      'module.original.willfiles',
      'module.peer.willfiles',
      'module.peer.in',
      'module.common',
      'download',
      'export'
    ];
    var got = _.props.keys( outfile.module[ './' ].path );
    test.identical( got, exp );
    var exp = [];
    var got = _.props.keys( outfile.module[ './' ].reflector );
    test.identical( got, exp );

    /* */

    var exp = [ 'export' ];
    var got = _.props.keys( outfile.module[ 'explicit.out' ].exported );
    test.identical( got, exp );
    var exp = [ 'export' ];
    var got = _.props.keys( outfile.module[ 'explicit.out' ].build );
    test.identical( got, exp );
    var exp = [];
    var got = _.props.keys( outfile.module[ 'explicit.out' ].step );
    test.identical( got, exp );
    var exp =
    [
      'module.willfiles',
      'module.common',
      'in',
      'out',
      'module.original.willfiles',
      'module.peer.willfiles',
      'module.peer.in',
      'download',
      'export',
      'exported.dir.export',
      'exported.files.export'
    ];
    var got = _.props.keys( outfile.module[ 'explicit.out' ].path );
    test.identical( got, exp );
    var exp = [ 'exported.export', 'exported.files.export' ];
    var got = _.props.keys( outfile.module[ 'explicit.out' ].reflector );
    test.identical( got, exp );

    /* */

    var exp = [ '.', 'will.yml', 'proto', 'proto/File.js' ];
    var got = outfile.module[ 'explicit.out' ].path[ 'exported.files.export' ].path;
    test.identical( got, exp );

    /* */

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = '.with implicit/ .export';
    a.reflect();
    return null;
  })

  a.appStart( '.with implicit/ .clean' )
  a.appStart( '.with implicit/ .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Exported module::implicit / build::export with 4 file(s)' ), 1 );

    var exp = [ '.', './implicit.out.will.yml', './will.yml', './proto', './proto/File.js' ];
    var files = a.find( a.abs( 'implicit' ) );
    test.identical( files, exp );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'implicit/implicit.out.will.yml' ) );

    /* */

    var exp = [ 'export' ];
    var got = _.props.keys( outfile.module[ './' ].build );
    test.identical( got, exp );
    var exp = [];
    var got = _.props.keys( outfile.module[ './' ].step );
    test.identical( got, exp );
    var exp =
    [
      'in',
      'out',
      'module.willfiles',
      'module.original.willfiles',
      'module.peer.willfiles',
      'module.peer.in',
      'module.common',
      'download',
      'export'
    ];
    var got = _.props.keys( outfile.module[ './' ].path );
    test.identical( got, exp );
    var exp = [];
    var got = _.props.keys( outfile.module[ './' ].reflector );
    test.identical( got, exp );

    /* */

    var exp = [ 'export' ];
    var got = _.props.keys( outfile.module[ 'implicit.out' ].exported );
    test.identical( got, exp );
    var exp = [ 'export' ];
    var got = _.props.keys( outfile.module[ 'implicit.out' ].build );
    test.identical( got, exp );
    var exp = [];
    var got = _.props.keys( outfile.module[ 'implicit.out' ].step );
    test.identical( got, exp );
    var exp =
    [
      'module.willfiles',
      'module.common',
      'in',
      'out',
      'module.original.willfiles',
      'module.peer.willfiles',
      'module.peer.in',
      'download',
      'export',
      'exported.dir.export',
      'exported.files.export'
    ];
    var got = _.props.keys( outfile.module[ 'implicit.out' ].path );
    test.identical( got, exp );
    var exp = [ 'exported.export', 'exported.files.export' ];
    var got = _.props.keys( outfile.module[ 'implicit.out' ].reflector );
    test.identical( got, exp );

    /* */

    var exp = [ '.', 'will.yml', 'proto', 'proto/File.js' ];
    var got = outfile.module[ 'implicit.out' ].path[ 'exported.files.export' ].path;
    test.identical( got, exp );

    /* */

    return null;
  })

  /* - */

  return a.ready;

}

exportImplicit.timeOut = 300000;

//

function exportAuto( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportAuto' );
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = 'export'
    return null;
  })

  a.appStart( '.clean' )
  a.appStart( '.with submodule/* .export' )
  a.appStart( '.with manual .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './auto.will.yml',
      './manual.will.yml',
      './will.yml',
      './.module',
      './.module/LocalModule.manual.out.will.yml',
      './.module/RemoteModule.manual.out.will.yml',
      './.module/RemoteModule.manual',
      './.module/RemoteModule.manual/README.md',
      './.module/RemoteModule.manual/dir',
      './.module/RemoteModule.manual/dir/SecondFile.md',
      './local',
      './local/LocalFile.txt',
      './out',
      './out/manual.out.will.yml',
      './out/files',
      './out/files/LocalFile.txt',
      './out/files/README.md',
      './out/files/dir',
      './out/files/dir/SecondFile.md',
      './submodule',
      './submodule/local.will.yml',
      './submodule/remote.will.yml'
    ]
    var files = a.find( a.routinePath );
    test.contains( files, exp );

    return null;
  })

  /* - */

  a.ready

  .then( () =>
  {
    test.case = 'export'
    return null;
  })

  a.appStart( '.clean' )
  a.appStart( '.with auto .export.recursive' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './auto.will.yml',
      './manual.will.yml',
      './will.yml',
      './.module',
      './.module/LocalModule.manual.out.will.yml',
      './.module/RemoteModule.manual.out.will.yml',
      './.module/RemoteModule.manual',
      './.module/RemoteModule.manual/README.md',
      './.module/RemoteModule.manual/dir',
      './.module/RemoteModule.manual/dir/SecondFile.md',
      './local',
      './local/LocalFile.txt',
      './out',
      './out/manual.out.will.yml',
      './out/files',
      './out/files/LocalFile.txt',
      './out/files/README.md',
      './out/files/dir',
      './out/files/dir/SecondFile.md',
      './submodule',
      './submodule/local.will.yml',
      './submodule/remote.will.yml'
    ]
    var files = a.find( a.routinePath );
    test.contains( files, exp );

    return null;
  })

  /* - */

  return a.ready;
}

exportAuto.timeOut = 300000;
exportAuto.description =
`
- auto export works similar to manual export
`;

//

function exportOutdated2( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmoduleThatHasModuleDirDeleted' );

  /* - */

  a.ready
  a.reflect();

  a.appStart( '.with module/mand/ .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'rror' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );
    test.true( a.fileProvider.fileExists( a.abs( 'module/mand/out/mand.out.will.yml' ) ) );
    var read = a.fileProvider.fileRead( a.abs( 'module/mand/.im.will.yml' ) );
    read += '\n\n';
    a.fileProvider.fileWrite( a.abs( 'module/mand/.im.will.yml' ), read );
    return null;
  })

  a.appStart( '.with module/mand/ .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'rror' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );
    test.true( a.fileProvider.fileExists( a.abs( 'module/mand/out/mand.out.will.yml' ) ) );
    return null;
  })

  /* - */

  return a.ready;
}

exportOutdated2.description =
`
- Exporting of module with outdated outfile throws no error.
`;

//

function exportWithSubmoduleThatHasModuleDirDeleted( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmoduleThatHasModuleDirDeleted' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'optional';
    a.reflect();
    test.true( !a.fileProvider.fileExists( a.abs( 'module/opt/out/opt.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/Optional.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'module/opt/.module' ) ) );
    return null;
  });

  a.appStart( '.with module/opt/ .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'rror' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );
    return null;
  });

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.abs( 'module/opt/.module' ) )
    test.true( a.fileProvider.fileExists( a.abs( 'module/opt/out/opt.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/Optional.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'module/opt/.module' ) ) );
    return null;
  });

  a.appStart( '.with Optional .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'rror' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );
    test.true( a.fileProvider.fileExists( a.abs( 'module/opt/out/opt.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/Optional.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'module/opt/.module' ) ) );

    var exp =
    [
      'Optional.out',
      '../Optional',
      '../module/opt/',
      '../module/opt/out/opt.out',
      '../module/opt/.module/ModuleForTesting2/',
      '../module/opt/.module/ModuleForTesting2/out/wModuleForTesting2.out',
    ];
    var outfile = a.fileProvider.fileReadUnknown( a.abs( 'out/Optional.out.will.yml' ) );
    test.identical( _.props.keys( outfile.module ), exp );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'mandatory';
    a.reflect();
    test.true( !a.fileProvider.fileExists( a.abs( 'module/mand/out/mand.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/Mandatory.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'module/mand/.module' ) ) );
    return null;
  })

  a.appStart( '.with module/mand/ .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'rror' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );
    return null;
  });

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.abs( 'module/mand/.module' ) );
    test.true( a.fileProvider.fileExists( a.abs( 'module/mand/out/mand.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out/Mandatory.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'module/mand/.module' ) ) );
    return null;
  });

  a.appStart( '.with Mandatory .export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::Mandatory / module::mand / opener::ModuleForTesting2 is not available' ), 0 );
    test.identical( _.strCount( op.output, 'ModuleForTesting2 is not available' ), 0 );
    test.identical( _.strCount( op.output, 'Exported module::' ), 1 );
    test.true( a.fileProvider.fileExists( a.abs( 'module/mand/out/mand.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/Mandatory.out.will.yml' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'module/mand/.module' ) ) );
    return null;
  });

  /* - */

  return a.ready;
}/* end of function exportWithSubmoduleThatHasModuleDirDeleted */

exportWithSubmoduleThatHasModuleDirDeleted.rapidity = -1;
exportWithSubmoduleThatHasModuleDirDeleted.timeOut = 150000;
exportWithSubmoduleThatHasModuleDirDeleted.description =
`
Supermodule has single submodule. Submodule has own dependency too.
Expected behaviour:
- Submodule exports own files and submodule
- Export of supermodule works even if submodules are not downloaded recursively.
`

//

function exportWithoutSubSubModules( test )
{
  let context = this;
  let a = context.assetFor( test, '4LevelsLocal' );

  a.reflect();
  a.appStart( '.with * .clean' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with l1 .export';
    return null;
  })

  a.appStart( '.with l1 .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l1.out.will.yml\n' ), 2 );
    var exp = [ '.', './l1.out.will.yml', './l1.will.yml', './l2.will.yml', './l3.will.yml', './l4.will.yml' ];
    var got = a.find( a.abs( '.' ) );
    test.identical( got, exp );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with l2 .export';
    return null;
  })

  a.appStart( '.with l2 .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l1.out.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l2.out.will.yml\n' ), 2 );
    var exp = [ '.', './l1.out.will.yml', './l1.will.yml', './l2.out.will.yml', './l2.will.yml', './l3.will.yml', './l4.will.yml' ];
    var got = a.find( a.abs( '.' ) );
    test.identical( got, exp );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with l3 .export';
    a.fileProvider.fileDelete( a.abs( 'l1.out.will.yml' ) );
    return null;
  })

  a.appStart( '.with l3 .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml\n' ), 0 );
    test.identical( _.strCount( op.output, '/l1.out.will.yml\n' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml from ../l2.out.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l1.out.will.yml from ../l2.out.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l2.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l2.out.will.yml\n' ), 3 );
    test.identical( _.strCount( op.output, '/l3.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l3.out.will.yml\n' ), 2 );
    var exp = [ '.', './l1.will.yml', './l2.out.will.yml', './l2.will.yml', './l3.out.will.yml', './l3.will.yml', './l4.will.yml' ];
    var got = a.find( a.abs( '.' ) );
    test.identical( got, exp );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with l4 .export';
    a.fileProvider.fileDelete( a.abs( 'l2.out.will.yml' ) );
    return null;
  })

  a.appStart( '.with l4 .export' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml\n' ), 0 );
    test.identical( _.strCount( op.output, '/l1.out.will.yml\n' ), 0 );
    test.identical( _.strCount( op.output, '/l1.will.yml from ../l3.out.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l1.out.will.yml from ../l3.out.will.yml\n' ), 1 );

    test.identical( _.strCount( op.output, '/l2.will.yml\n' ), 0 );
    test.identical( _.strCount( op.output, '/l2.out.will.yml\n' ), 0 );
    test.identical( _.strCount( op.output, '/l2.will.yml from ../l3.out.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l2.out.will.yml from ../l3.out.will.yml\n' ), 1 );

    test.identical( _.strCount( op.output, '/l3.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l3.out.will.yml\n' ), 5 );
    test.identical( _.strCount( op.output, '/l4.will.yml\n' ), 1 );
    test.identical( _.strCount( op.output, '/l4.out.will.yml\n' ), 2 );
    var exp = [ '.', './l1.will.yml', './l2.will.yml', './l3.out.will.yml', './l3.will.yml', './l4.out.will.yml', './l4.will.yml' ];
    var got = a.find( a.abs( '.' ) );
    test.identical( got, exp );
    return op;
  });

  /* - */

  return a.ready;
}

exportWithoutSubSubModules.timeOut = 300000;

//

function exportWithSubmoduleWithNotDownloadedSubmodule( test )
{
  let context = this;
  let a = context.assetFor( test );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.export';
    a.reflect();
    return null;
  });

  a.appStart( '.export' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Exported module::l1 / build::export with 3 file(s)' ), 1 );
    var exp =
    [
      '.',
      './l1.out.will.yml',
      './will.yml',
      './.module',
      './.module/ModuleForTesting12',
      './.module/ModuleForTesting12/.eslintrc.yml',
      './.module/ModuleForTesting12/.gitattributes',
      './.module/ModuleForTesting12/.gitignore',
      './.module/ModuleForTesting12/License',
      './.module/ModuleForTesting12/package.json',
      './.module/ModuleForTesting12/Readme.md',
      './.module/ModuleForTesting12/was.package.json',
      './.module/ModuleForTesting12/will.yml',
      './.module/ModuleForTesting12/.circleci',
      './.module/ModuleForTesting12/.circleci/config.yml',
      './.module/ModuleForTesting12/.github',
      './.module/ModuleForTesting12/.github/workflows',
      './.module/ModuleForTesting12/.github/workflows/TestAssetPublish.yml',
      './.module/ModuleForTesting12/.github/workflows/TestAssetPullRequest.yml',
      './.module/ModuleForTesting12/.github/workflows/TestAssetPush.yml',
      './.module/ModuleForTesting12/doc',
      './.module/ModuleForTesting12/doc/ModuleForTesting12.md',
      './.module/ModuleForTesting12/doc/README.md',
      './.module/ModuleForTesting12/out',
      './.module/ModuleForTesting12/out/wModuleForTesting12.out.will.yml',
      './.module/ModuleForTesting12/proto',
      './.module/ModuleForTesting12/proto/node_modules',
      './.module/ModuleForTesting12/proto/node_modules/wmodulefortesting12',
      './.module/ModuleForTesting12/proto/wtools',
      './.module/ModuleForTesting12/proto/wtools/testing',
      './.module/ModuleForTesting12/proto/wtools/testing/Common.s',
      './.module/ModuleForTesting12/proto/wtools/testing/l3',
      './.module/ModuleForTesting12/proto/wtools/testing/l3/testing12',
      './.module/ModuleForTesting12/proto/wtools/testing/l3/testing12/ModuleForTesting12.s',
      './.module/ModuleForTesting12/sample',
      './.module/ModuleForTesting12/sample/trivial',
      './.module/ModuleForTesting12/sample/trivial/Sample.s',
    ];
    var got = a.find( a.abs( '.' ) );
    test.identical( got, exp );
    return op;
  });

  /* - */

  return a.ready;
}

//

function exportMainIsGitRepository( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportMainIsGitRepository' );

  a.remotePath = a.abs( 'module' );
  a.appStart.predefined.currentPath = a.abs( 'clone' );
  a.appStartNonThrowing.predefined.currentPath = a.abs( 'clone' );

  a.shellSync = _.process.starter
  ({
    currentPath : a.abs( '.' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.moduleShellSync = _.process.starter
  ({
    currentPath : a.remotePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.init = ( o ) =>
  {
    o = o || {}

    a.ready.then( () =>
    {
      test.case = _.entity.exportString( o );

      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();
      a.moduleShellSync( 'git init' )
      a.moduleShellSync( 'git add -fA .' )
      a.moduleShellSync( 'git commit -m initial' )
      a.shellSync( 'git clone module clone' )

      return null;
    })

    return a.ready;
  }

  /* */

  a.init({ case : 'export' })
  a.appStartNonThrowing( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, /Exported .*module::exportMainIsGitRepository \/ build::proto\.export.* in/ ) );

    var files = a.find( a.abs( 'clone/out' ) );
    test.gt( files.length, 2 );

    var files = a.fileProvider.dirRead( a.abs( 'clone/out' ) );
    test.identical( files, [ 'debug', 'exportMainIsGitRepository.out.will.yml' ] );

    return null;
  })

  /* */

  return a.ready;
}

//

function exportTwoFirstIsDepOfSecond( test ) /* xxx : for Kos */
{
  let context = this;
  let a = context.assetFor( test, 'exportTwoFirstIsDepOfSecond' );
  a.reflectMinimal();

  /* - */

  a.shell( 'git clone https://github.com/Wandalen/wModuleForTesting1.git' );
  a.shell( 'git clone https://github.com/Wandalen/wModuleForTesting3.git' );

  a.appStart({ args : `.with "*/*" .export` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Out-willfile is inconsistent with its in-willfiles' ), 0 );

    test.will = 'ModuleForTesting3 should not download copy of ModuleForTesting1, but reuse already opened';
    let modulesOfTesting3 = a.fileProvider.dirRead( a.abs( 'wModuleForTesting3/.module' ) );
    test.identical( modulesOfTesting3, null );

    test.will = 'consistency of ModuleForTesting3 contains updated values for ModuleForTesting1';
    let ModuleForTesting1Out = a.fileProvider.fileReadUnknown( a.abs( 'wModuleForTesting1/out/wModuleForTesting1.out.will.yml' ) );
    let ModuleForTesting3Out = a.fileProvider.fileReadUnknown( a.abs( 'wModuleForTesting3/out/wModuleForTesting3.out.will.yml' ) );
    let expectedModule1Im = ModuleForTesting1Out.consistency[ '../.im.will.yml' ];
    let expectedModule1Ex = ModuleForTesting1Out.consistency[ '../.ex.will.yml' ];
    let gotModule1Im = ModuleForTesting3Out.consistency[ '../.module/ModuleForTesting1/.im.will.yml' ];
    let gotModule1Ex = ModuleForTesting3Out.consistency[ '../.module/ModuleForTesting1/.ex.will.yml' ];
    test.identical( gotModule1Im, expectedModule1Im );
    test.identical( gotModule1Ex, expectedModule1Ex );

    return null;
  })

  return a.ready;
}

exportTwoFirstIsDepOfSecond.description =
`
Two remote modules. First is a submodule of the second.
Exporting modules using .with */*.
Second module should not download copy of first module, but use already opened module.
Out will-file of the second module should contain updated hash and size of the in will-files of the first module.
`

//

/* aaa : Dmytro : updated test routine, used test asset without extra exporting */

function exportWithOutdatedWillbe( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithOutdatedWillbe' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export from module with outdated format of exported willfile';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ args : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Exporting module::testModule / build::export' ), 1 );
    test.identical( _.strCount( op.output, 'Options map for reflector::exported.export should not have fields : "linking"' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to make resource' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to import willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::testModule' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

exportWithOutdatedWillbe.description =
`
Reproduces situation when out file contains field that were renamed in newer version of willbe.
Uses older version of will to export the module and then tries to export module using current willbe.
Current willbe should alert user about unexpected fields.
`

//

/* aaa : for Dmytro : fix it */ /* Dmytro : fixed */

function exportCreatesOutDir( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportCreatesOutDir' );
  a.reflectMinimal();

  a.appStartNonThrowing({ args : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, /No file found at .*\/out/ ) )
    test.true( a.fileProvider.fileExists( a.abs( 'out' ) ) );
    return null;
  })

  /* */

  return a.ready;
}

exportCreatesOutDir.description =
`
Reproduces situation when out directory is not present and should be created by willbe.
`

//

/*
Import out file with non-importable path local.
Test importing of non-valid out files.
Test redownloading of currupted remote submodules.
*/

function importPathLocal( test )
{
  let context = this;
  let a = context.assetFor( test, 'importPathLocal' );

  /* xxx : replace _.path.join( modulePath */

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = 'export submodule';
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });

  a.appStart({ execPath : '.build' });
  a.ready.then( ( op ) =>
  {

    var files = a.find( a.abs( 'out' ) );
    var exp =
    [
      '.',
      './debug',
      './debug/WithSubmodules.s',
      './debug/node_modules',
      './debug/node_modules/wmodulefortesting1',
      './debug/wtools',
      './debug/wtools/testing',
      './debug/wtools/testing/Common.s',
      './debug/wtools/testing/l1',
      './debug/wtools/testing/l1/ModuleForTesting1.s',
    ];
    test.contains( files, exp );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Built .*module::submodules \/ build::debug\.raw.* in/ ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function importLocalRepo( test )
{
  let context = this;
  let a = context.assetFor( test, 'importAuto' );
  a.reflect();

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = '.with module/ModuleForTesting12 .export';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with module/ModuleForTesting12 .clean' });
  a.appStart({ execPath : '.with module/ModuleForTesting12 .export' });

  a.ready.then( ( op ) =>
  {

    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting12', 'ModuleForTesting12.out.will.yml' ] );

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\+ reflector::download reflected .* file\(s\)/ ), 1 );
    test.identical( _.strCount( op.output, /Write out willfile .*\/.module\/ModuleForTesting12.out.will.yml/ ), 1 );

    var outfile = a.fileProvider.fileReadUnknown( a.abs( '.module/ModuleForTesting12.out.will.yml' ) );
    outfile = outfile.module[ 'ModuleForTesting12.out' ];

    var expectedReflector =
    {
      'download' :
      {
        'src' :
        {
          'filePath' : { '.' : `.` },
          'prefixPath' : `path::remote`
        },
        'dst' : { 'prefixPath' : `path::download` },
        'mandatory' : 1
      },
      'exported.export' :
      {
        'src' :
        {
          'filePath' : { '**' : `` },
          'prefixPath' : `ModuleForTesting12/proto`
        },
        'mandatory' : 1,
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 }
      },
      'exported.files.export' :
      {
        'src' :
        {
          'filePath' : { 'path::exported.files.export' : `` },
          'basePath' : `.`,
          'prefixPath' : `path::exported.dir.export`,
          'recursive' : 0
        },
        'recursive' : 0,
        'mandatory' : 1,
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 }
      }
    }
    test.identical( outfile.reflector, expectedReflector );

    var expectedPath =
    {
      'module.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.out.will.yml`
      },
      'module.common' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `ModuleForTesting12.out`
      },
      'module.original.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.will.yml`
      },
      'module.peer.willfiles' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : `../module/ModuleForTesting12.will.yml`
      },
      'in' :
      {
        'path' : `.`
      },
      'out' :
      {
        'path' : `.`
      },
      'download' : { 'path' : `ModuleForTesting12` },
      'export' : { 'path' : `{path::download}/proto/**` },
      'temp' : { 'path' : `../out` },
      'exported.dir.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' : `ModuleForTesting12/proto`
      },
      'module.peer.in' :
      {
        'criterion' : { 'predefined' : 1 },
        'path' : '..'
      },
      'exported.files.export' :
      {
        'criterion' : { 'default' : 1, 'export' : 1, 'generated' : 1 },
        'path' :
        [
          `ModuleForTesting12/proto`,
          `ModuleForTesting12/proto/wtools`,
          `ModuleForTesting12/proto/node_modules/Tools`,
          `ModuleForTesting12/proto/wtools/abase`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/Include.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l1`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l1/Define.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l1/ModuleForTesting12.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l1/Workpiece.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l3`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Accessor.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Class.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Complex.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto/l3/Like.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto.test`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto.test/Class.test.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto.test/Complex.test.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto.test/Like.test.s`,
          `ModuleForTesting12/proto/wtools/abase/l3_proto.test/ModuleForTesting12.test.s`
        ]
      }
    }
    test.identical( outfile.path, expectedPath );

    return null;
  });

  /* - */

  return a.ready;
}

//

/*
 - check caching of modules in out-willfiles
*/

function importOutWithDeletedSource( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmodules' );

  /* - */

  begin().then( ( op ) =>
  {
    test.case = 'export first';
    return null;
  });

  a.appStart({ args : '.clean' });
  a.appStart({ args : '.with a .export' });
  a.appStart({ args : '.with b .export' });
  a.appStart({ args : '.with ab-named .export' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.', './module-a.out.will.yml', './module-ab-named.out.will.yml', './module-b.out.will.yml' ];
    var files = a.find( a.abs( 'out' ) );
    test.identical( files, exp );

    a.fileProvider.filesDelete( a.abs( 'a.will.yml' ) );
    a.fileProvider.filesDelete( a.abs( 'b.will.yml' ) );
    a.fileProvider.filesDelete( a.abs( 'ab' ) );
    a.fileProvider.filesDelete( a.abs( 'ab-named.will.yml' ) );

    return null;
  });

  a.appStart({ args : '.with out/module-ab-named .modules.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, ' from ' ), 5 );
    test.identical( _.strCount( op.output, 'module::module-ab-named' ), 5 );
    test.identical( _.strCount( op.output, 'module::module-ab-named / module::module-a' ), 2 );
    test.identical( _.strCount( op.output, 'module::module-ab-named / module::module-b' ), 2 );
    test.identical( _.strCount( op.output, 'module::' ), 9 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.fileWrite( a.abs( 'proto/b/-Excluded.js' ), 'console.log( \'b/-Ecluded.js\' );' );
      return null;
    });
  }
}

//

function importOutdated( test )
{
  let context = this;
  let a = context.assetFor( test, 'importOutdated' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : [ '.with module1/ .export' ] });
  a.appStart({ args : [ '.with module2/ .export' ] });
  a.ready.then( () =>
  {
    let willfilePath = a.abs( 'module1/.will.yml' );
    let willFile = a.fileProvider.fileRead({ filePath : willfilePath, encoding : 'yml' });
    willFile.path.somepath = 'somepath';
    a.fileProvider.fileWrite({ filePath : willfilePath, data : willFile, encoding : 'yml' });
    return null;
  })
  a.appStart({ args : [ '.with module1/ .export' ] });
  a.appStartNonThrowing({ args : [ '.build' ] });
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Select constraint "exported::*=1" failed with 0 elements' ), 1 );
    test.identical( _.strCount( op.output, 'Selector "submodule::*/exported::*=1/reflector::exported.files*=1"' ), 1 );
    test.identical( _.strCount( op.output, 'module::supermodule / module::submodule1 loaded from module::supermodule / module::submodule2 is outdated!' ), 1 );
    test.identical( _.strCount( op.output, `Please re-export ${a.abs( './module2/out/submodule2.out.will.yml' )} first.` ), 1 );
    return null;
  })

  /* - */

  return a.ready;
}

importOutdated.timeOut = 60000;
importOutdated.description =
`
Problem was : not clear enough information about error.
Module "module1" is re-exported after export of "module2" and becomes outdated as a part of supermodule.
Import of "module1" results with the error, because "module1" was not opened.
Modules structure:
  supermodule
    - module1
    - module2
      - module1
`;

// --
// clean
// --

function clean( test )
{
  let context = this;
  let a = context.assetFor( test, 'clean' );
  a.reflect();

  /* - */

  a.appStart({ args : [ '.with NoTemp .build' ] });

  var files;
  a.ready
  .then( () =>
  {
    files = a.findAll( a.abs( '.module' ) );
    test.gt( files.length, 20 );
    return files;
  })

  a.appStart({ execPath : '.with NoTemp .clean' })
  .then( ( op ) =>
  {
    test.case = '.clean';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + files.length + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) ); /* phantom problem ? */
    return null;
  })

  a.appStart({ execPath : '.with NoTemp .clean' })
  .then( ( op ) =>
  {
    test.case = '.with NoTemp .clean -- second';
    test.identical( op.exitCode, 0 );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* - */

  var files = [];
  a.ready
  .then( () =>
  {
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })

  a.appStart({ execPath : '.with NoBuild .clean' })
  .then( ( op ) =>
  {
    test.case = '.with NoBuild .clean';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + 0 + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* - */

  var files = [];
  a.ready
  .then( () =>
  {
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })

  a.appStart({ execPath : '.with Build .build' })
  a.appStart({ execPath : '.with Vector .clean' })
  .then( ( op ) =>
  {
    test.case = '.with NoBuild .clean';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '- Clean deleted 2 file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'out' ) ) );
    return null;
  })

  /* - */

  return a.ready;
}

clean.timeOut = 300000;

//

function cleanOptionWithSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflect();

  /* - */

  var files;
  a.appStart( '.build' );
  a.ready.then( () =>
  {
    test.case = '.clean withSubmodules:0';
    files = a.findAll( a.abs( '.module' ) ).length;
    files += a.findAll( a.abs( 'out' ) ).length;
    test.gt( files, 20 );
    return null;
  })

  a.appStart( '.clean withSubmodules:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + files + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* */

  var files;
  a.appStart( '.build' );
  a.ready.then( () =>
  {
    test.case = '.clean withSubmodules:1';
    files = a.findAll( a.abs( '.module' ) ).length;
    files += a.findAll( a.abs( 'out' ) ).length;
    test.gt( files, 20 );
    return null;
  })

  a.appStart( '.clean withSubmodules:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + files + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* */

  var files;
  a.appStart( '.build' );
  a.ready.then( () =>
  {
    test.case = '.clean withSubmodules:2';
    files = a.findAll( a.abs( '.module' ) ).length;
    files += a.findAll( a.abs( 'out' ) ).length;
    test.gt( files, 20 );
    return null;
  })

  a.appStart( '.clean withSubmodules:2' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + files + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* - */

  var files;
  a.appStart( '.build' );
  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:0 .clean';
    files = a.findAll( a.abs( '.module' ) ).length;
    files += a.findAll( a.abs( 'out' ) ).length;
    test.gt( files, 20 );
    return null;
  })

  a.appStart( '.imply withSubmodules:0 .clean' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + files + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* */

  var files;
  a.appStart( '.build' );
  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:1 .clean';
    files = a.findAll( a.abs( '.module' ) ).length;
    files += a.findAll( a.abs( 'out' ) ).length;
    test.gt( files, 20 );
    return null;
  })

  a.appStart( '.imply withSubmodules:1 .clean' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + files + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* */

  var files;
  a.appStart( '.build' );
  a.ready.then( () =>
  {
    test.case = '.imply withSubmodules:2 .clean';
    files = a.findAll( a.abs( '.module' ) ).length;
    files += a.findAll( a.abs( 'out' ) ).length;
    test.gt( files, 20 );
    return null;
  })

  a.appStart( '.imply withSubmodules:2 .clean' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* - */

  a.appStart( '.clean withSubmodules:0' )
  a.appStart( '.clean withSubmodules:0' )
  .then( ( op ) =>
  {
    test.case = '.clean withSubmodules:0 - without downloaded submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  });

  /* - */

  a.appStart( '.clean withSubmodules:2' )
  .then( ( op ) =>
  {
    test.case = '.clean withSubmodules:2 - without downloaded submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  });

  /* - */

  return a.ready;
}

cleanOptionWithSubmodules.rapidity = -1;
cleanOptionWithSubmodules.timeOut = 600000;

//

function cleanSingleModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'single' );
  a.reflect();

  /* */

  a.appStart( { execPath : [ '.build', '.clean' ] } )
  .then( ( op ) =>
  {
    test.case = '.clean '
    test.identical( op.sessions[ 0 ].exitCode, 0 );
    test.identical( op.sessions[ 1 ].exitCode, 0 );
    test.true( _.strHas( op.sessions[ 1 ].output, 'Clean deleted 0 file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )
    return null;
  });

  /* */

  a.appStart({ execPath : [ '.build', '.clean dry:1' ] })
  .then( ( op ) =>
  {
    test.case = '.clean dry:1'
    test.identical( op.sessions[ 0 ].exitCode, 0 );
    test.identical( op.sessions[ 1 ].exitCode, 0 );
    test.true( _.strHas( op.sessions[ 1 ].output, 'Clean will delete 0 file(s)' ) );
    return null;
  });

  /* - */

  return a.ready;
}

//

function cleanItself( test )
{
  let context = this;
  let a = context.assetFor( test, 'cleanItself' );

  /* - */

  begin( 'ImplicitTempAndOut' ).then( () =>
  {
    test.case = 'clean with implicit declaration of path::out';
    return null;
  });

  a.appStartNonThrowing( '.with ImplicitTempAndOut .clean' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::ImplicitTempAndOut should not delete itself' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.' ) );
    var exp =
    [
      '.module',
      'ExplicitTempAndOut.will.yml',
      'ImplicitOut.will.yml',
      'ImplicitTempAndOut.out.will.yml',
      'ImplicitTempAndOut.will.yml',
      'proto'
    ];
    test.identical( files, exp );
    return null;
  });

  /* */

  begin( 'ImplicitOut' ).then( () =>
  {
    test.case = 'clean with implicit declaration of path::out';
    return null;
  });

  a.appStartNonThrowing( '.with ImplicitOut .clean' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::ImplicitOut should not delete itself' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.' ) );
    var exp =
    [
      '.module',
      'ExplicitTempAndOut.will.yml',
      'ImplicitOut.out.will.yml',
      'ImplicitOut.will.yml',
      'ImplicitTempAndOut.will.yml',
      'proto'
    ];
    test.identical( files, exp );
    return null;
  });

  /* */

  begin( 'ExplicitTempAndOut' ).then( () =>
  {
    test.case = 'clean with explicit declaration of path::out in directory path::in';
    return null;
  });

  a.appStartNonThrowing( '.with ExplicitTempAndOut .clean' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::ExplicitTempAndOut should not delete itself' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.' ) );
    var exp =
    [
      '.module',
      'ExplicitTempAndOut.out.will.yml',
      'ExplicitTempAndOut.will.yml',
      'ImplicitOut.will.yml',
      'ImplicitTempAndOut.will.yml',
      'proto'
    ];
    test.identical( files, exp );
    return null;
  });

  /* */

  begin( 'ImplicitTempAndOut' ).then( () =>
  {
    test.case = 'dry - 1, clean with implicit declaration of path::out';
    return null;
  });

  a.appStartNonThrowing( '.with ImplicitTempAndOut .clean dry:1' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::ImplicitTempAndOut should not delete itself' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.' ) );
    var exp =
    [
      '.module',
      'ExplicitTempAndOut.will.yml',
      'ImplicitOut.will.yml',
      'ImplicitTempAndOut.out.will.yml',
      'ImplicitTempAndOut.will.yml',
      'proto'
    ];
    test.identical( files, exp );
    return null;
  });

  /* */

  begin( 'ImplicitOut' ).then( () =>
  {
    test.case = 'dry - 1, clean with implicit declaration of path::out';
    return null;
  });

  a.appStartNonThrowing( '.with ImplicitOut .clean dry:1' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::ImplicitOut should not delete itself' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.' ) );
    var exp =
    [
      '.module',
      'ExplicitTempAndOut.will.yml',
      'ImplicitOut.out.will.yml',
      'ImplicitOut.will.yml',
      'ImplicitTempAndOut.will.yml',
      'proto'
    ];
    test.identical( files, exp );
    return null;
  });

  /* */

  begin( 'ExplicitTempAndOut' ).then( () =>
  {
    test.case = 'dry - 1, clean with explicit declaration of path::out in directory path::in';
    return null;
  });

  a.appStartNonThrowing( '.with ExplicitTempAndOut .clean dry:1' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'module::ExplicitTempAndOut should not delete itself' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.' ) );
    var exp =
    [
      '.module',
      'ExplicitTempAndOut.out.will.yml',
      'ExplicitTempAndOut.will.yml',
      'ImplicitOut.will.yml',
      'ImplicitTempAndOut.will.yml',
      'proto'
    ];
    test.identical( files, exp );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin( name )
  {
    a.ready.then( () => { a.reflect(); return null } );
    a.appStart( `.with ${ name } .export` );
    return a.ready;
  }
}

//

function cleanBroken1( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesBroken1' );
  a.reflect();

  test.description = 'should handle currputed willfile properly';

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = '.clean dry:1';
    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );
    return null;
  });

  a.appStart({ execPath : '.clean dry:1' })
  .then( ( op ) =>
  {
    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, String( files.length ) + ' at ' ) );
    test.true( _.strHas( op.output, 'Clean will delete ' + String( files.length ) + ' file(s)' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.clean';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.clean' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) ); /* filesDelete issue? */
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) );
    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.clean then .export';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exported .*module::submodules \/ build::proto\.export.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.gt( files.length, 9 );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, [ 'debug', 'submodules.out.will.yml' ] );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.clean then .export twice';
    a.reflect();
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exported .*module::submodules \/ build::proto\.export.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.gt( files.length, 9 );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, [ 'debug', 'submodules.out.will.yml' ] );

    return null;
  });

  /* - */

  return a.ready;
}

//

function cleanBroken2( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesBroken2' );

  test.description = 'should handle currputed willfile properly';

  /* - */

  a.ready

  .then( ( op ) =>
  {
    test.case = '.clean dry ';
    a.reflect();
    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );

    return null;
  })

  a.appStart({ execPath : '.clean dry:1' })

  .then( ( op ) =>
  {
    test.case = '.clean dry:1';

    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, String( files.length ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) );

    return null;
  })

  /* - */

  .then( ( op ) =>
  {
    test.case = '.clean';
    a.reflect();
    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );

    return null;
  })

  a.appStart({ execPath : '.clean' })

  .then( ( op ) =>
  {
    test.case = '.clean';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) ); /* filesDelete issue? */
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) );
    return null;
  })

  /* - */

  .then( ( op ) =>
  {
    test.case = '.clean';
    a.reflect();
    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.case = '.export';

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Exported .*module::submodules \/ build::proto\.export.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.gt( files.length, 9 );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, [ 'debug', 'submodules.out.will.yml' ] );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.export';
    test.will = 'update should throw error if submodule is not downloaded but download path exists';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.export', throwingExitCode : 0 })
  .then( ( op ) =>
  {

    test.notIdentical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, /Exported .*module::submodules \/ build::proto\.export.* in/ ) );
    var expected = `Module module::submodules / opener::ModuleForTesting2 is downloaded, but it's not a git repository`;
    test.false( _.strHas( op.output, expected ) );

    var expected = `Out-willfile should not have section(s) : "brokenFile"`
    test.true( _.strHas( op.output, expected ) );

    // var files = a.find( a.abs( 'out/debug' ) );
    // test.gt( files.length, 9 );

    // var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    // test.identical( files, [ 'debug', 'submodules.out.will.yml' ] );

    var files = a.find( a.abs( 'out/debug' ) );
    test.identical( files.length, 0 );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, null );

    return null;
  })

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.export agree1';
    test.will = 'export should not throw error because submodule was updated by agree';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.imply withOut:0 .submodules.versions.agree .export', throwingExitCode : 0 })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    /* agree/update/download should not count as update of module if no change was done */
    test.identical( _.strCount( op.output, 'was updated' ), 0 );
    test.identical( _.strCount( op.output, 'to version' ), 0 );
    test.true( !_.strHas( op.output, /Module module::submodules \/ opener::ModuleForTesting2 is not downloaded, but file at .*/ ) );
    test.true( _.strHas( op.output, '+ 1/1 submodule(s) of module::submodules were agreed' ) );
    test.true( _.strHas( op.output, /Exported .*module::submodules \/ build::proto\.export.* in/ ) );

    var files = a.find( a.abs( 'out/debug' ) );
    test.gt( files.length, 9 );

    var files = a.fileProvider.dirRead( a.abs( 'out' ) );
    test.identical( files, [ 'debug', 'submodules.out.will.yml' ] );

    return null;
  })

  /* - */

  return a.ready;
}

//

function cleanBrokenSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'cleanBrokenSubmodules' );

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = 'setup';
    a.reflect();
    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files.length, 2 );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.clean dry:1' })
  .then( ( op ) =>
  {
    test.case = '.clean dry:1';

    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 4 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files.length, 2 );

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '/.module' ) );
    test.true( _.strHas( op.output, '/out' ) );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.clean' })
  .then( ( op ) =>
  {
    test.case = '.clean';

    var files = a.find( a.abs( '.module' ) );
    test.identical( files.length, 0 );
    var files = a.find( a.abs( 'out' ) );
    test.identical( files.length, 0 );

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '6 file(s)' ) );

    return null;
  })

  /* - */

  return a.ready;
}

//

function cleanHdBug( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyHdBug' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .clean recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp =
    [
      '.',
      './z.will.yml',
      './+',
      './+/z.will.yml',
      './+/.module',
      './+/.module/ModuleForTesting1',
      './+/.module/ModuleForTesting1/.gitkeep',
      './+/group1',
      './+/group1/a.will.yml',
      './+/group1/.module',
      './+/group1/.module/ModuleForTesting1',
      './+/group1/.module/ModuleForTesting1/.gitkeep',
      './+/group1/.module/ModuleForTesting1b',
      './+/group1/.module/ModuleForTesting1b/.gitkeep',
      './+/group1/group10',
      './+/group1/group10/a0.will.yml',
      './+/group1/group10/.module',
      './+/group1/group10/.module/ModuleForTesting1b',
      './+/group1/group10/.module/ModuleForTesting1b/.gitkeep',
      './+/group1/group10/.module/ModuleForTesting2a',
      './+/group1/group10/.module/ModuleForTesting2a/.gitkeep',
      './group1',
      './group1/a.will.yml',
      './group1/group10',
      './group1/group10/a0.will.yml',
    ];
    var files = a.findAll( a.abs( '.' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Opened' ), 3 );
    test.identical( _.strCount( op.output, 'Clean deleted' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function cleanNoBuild( test )
{
  let context = this;
  let a = context.assetFor( test, 'clean' );
  a.reflect();

  /* - */

  a.appStartNonThrowing({ execPath : '.with NoBuild .clean' })
  .then( ( op ) =>
  {
    test.case = '.clean -- second';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted ' + 0 + ' file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) ); /* phantom problem ? */
    return null;
  });

  a.appStartNonThrowing({ execPath : '.with NoBuild .clean' })
  .then( ( op ) =>
  {
    test.case = '.clean';
    test.identical( op.exitCode, 0 );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );
    return null;
  })

  /* - */

  a.appStartNonThrowing({ execPath : '.with NoBuild .clean -- badarg' })
  .then( ( op ) =>
  {
    test.case = '.clean -- badarg';
    test.notIdentical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'Clean deleted' ) );
    return null;
  })

  /* - */

  return a.ready;
}

//

function cleanDry( test )
{
  let context = this;
  let a = context.assetFor( test, 'clean' );
  a.reflect();

  /* - */

  a.appStart({ args : [ '.with NoTemp .submodules.update' ] });
  a.ready.then( ( op ) =>
  {
    test.true( _.strHas( op.output, '+ 2/2 submodule(s) of module::submodules were updated' ) );
    var files = a.find( a.abs( '.module' ) );
    test.gt( files.length, 50 );
    return null;
  });

  a.appStart({ args : [ '.with NoTemp .build' ] });
  a.ready.then( ( op ) =>
  {
    test.true( _.strHas( op.output, '+ 0/2 submodule(s) of module::submodules were downloaded in' ) );
    return op;
  });

  var wasFiles;

  a.appStart({ execPath : '.with NoTemp .clean dry:1' })
  .then( ( op ) =>
  {
    test.case = '.clean dry:1';

    var files = a.findAll( a.abs( 'out' ) );
    test.gt( files.length, 10 );
    var files = wasFiles = a.findAll( a.abs( '.module' ) );
    test.gt( files.length, 50 );

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, String( files.length ) + ' at ' ) );
    test.true( _.strHas( op.output, 'Clean will delete ' + String( files.length ) + ' file(s)' ) );
    test.true( a.fileProvider.isDir( a.abs( '.module' ) ) ); /* phantom problem ? */
    test.true( a.fileProvider.isDir( a.abs( 'out' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) );

    return null;
  });

  /* - */

  return a.ready;
}

cleanDry.timeOut = 300000;

//

function cleanSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'clean' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.with NoTemp .submodules.update' })
  .then( ( op ) =>
  {
    test.case = '.submodules.update'
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )

    var files = a.find( a.abs( '.module/ModuleForTesting1' ) );
    test.true( files.length >= 1 );

    var files = a.find( a.abs( '.module/ModuleForTesting2' ) );
    test.true( files.length >= 1 );

    return null;
  });

  /* */

  var files;
  a.ready.then( () =>
  {
    files = a.findAll( a.abs( '.module' ) );
    return null;
  });

  a.appStart({ execPath : '.with NoTemp .clean.submodules' })
  .then( ( op ) =>
  {
    test.case = '.clean.submodules';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `${files.length}` ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) ); /* phantom problem ? */
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) );
    return null;
  });

  /* - */

  return a.ready;
}

cleanSubmodules.timeOut = 300000;

//

function cleanMixed( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesMixed' );
  a.reflect();

  /* - */

  a.ready
  .then( ( op ) =>
  {
    test.case = '.clean';
    return null;
  })

  a.appStart({ execPath : '.build' })
  a.appStart({ execPath : '.clean' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '- Clean deleted' ) );

    test.true( !a.fileProvider.fileExists( a.abs( 'out' ) ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) );

    var expected = [ '.', './ModuleForTesting12.informal.will.yml', './ModuleForTesting12ab.informal.will.yml' ];
    var files = a.find( a.abs( 'module' ) );
    test.identical( files, expected );

    return null;
  })

  /* - */

  return a.ready;
}

//

function cleanWithInPath( test )
{
  let context = this;
  let a = context.assetFor( test, 'cleanWithInpath' );

  /* - */

  var hadFiles;
  a.ready.then( ( op ) =>
  {
    test.case = '.with module/ModuleForTesting12 .clean';
    a.reflectMinimal();
    hadFiles = a.find( a.abs( 'out' ) ).length + a.find( a.abs( '.module' ) ).length;

    return null;
  });

  a.appStart({ execPath : '.with module/ModuleForTesting12 .clean' })
  a.ready.then( ( op ) =>
  {
    var expectedFiles =
    [
      '.',
      './module',
      './module/ModuleForTesting12.will.yml',
      './module/.module',
      './module/.module/ForGit.txt',
      './module/out',
      './module/out/ForGit.txt',
      './proto',
      './proto/WithSubmodules.s'
    ];
    var files = a.find({ filePath : { [ a.routinePath ] : '', '+**' : 0 } });
    test.identical( files, expectedFiles );

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '- Clean deleted ' + hadFiles + ' file(s)' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function cleanRecursiveMin( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemoteMin' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export first';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .clean' );
  a.appStart( '.with group1/a .export' );
  a.appStart( '.with z .export' );

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 12 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::z were downloaded' ), 0 );

    var exp =
    [
      '.',
      './z.will.yml',
      './.module',
      './group1',
      './group1/a.will.yml',
      './group1/.module',
      './group1/out',
      './group1/out/a.out.will.yml',
      './group1/out/debug',
      './group1/out/debug/node_modules',
      './group1/out/debug/node_modules/wmodulefortesting1',
      './group1/out/debug/node_modules/wmodulefortesting1b',
      './group1/out/debug/wtools',
      './group1/out/debug/wtools/testing',
      './group1/out/debug/wtools/testing/Common.s',
      './group1/out/debug/wtools/testing/l1',
      './group1/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group1/out/debug/wtools/testing/l3',
      './group1/out/debug/wtools/testing/l3/testing1b',
      './group1/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './out',
      './out/z.out.will.yml',
      './out/debug',
      './out/debug/node_modules',
      './out/debug/node_modules/wmodulefortesting1',
      './out/debug/node_modules/wmodulefortesting1a',
      './out/debug/node_modules/wmodulefortesting1b',
      './out/debug/wtools',
      './out/debug/wtools/testing',
      './out/debug/wtools/testing/Common.s',
      './out/debug/wtools/testing/l1',
      './out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './out/debug/wtools/testing/l2',
      './out/debug/wtools/testing/l2/testing1a',
      './out/debug/wtools/testing/l2/testing1a/ModuleForTesting1a.s',
      './out/debug/wtools/testing/l3',
      './out/debug/wtools/testing/l3/testing1b',
      './out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
    ];
    var files = a.findNoModules( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 12 );

    var exp = [ '.', './z.will.yml', './group1', './group1/a.will.yml' ];
    var files = a.findAll( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

cleanRecursiveMin.rapidity = -1;

//

function cleanGlobMin( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemoteMin' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export first';
    return null;
  });

  a.appStart( '.with ** .clean' );
  a.appStart( '.with group1/a .export' );
  a.appStart( '.with z .export' );

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 12 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::z were downloaded' ), 0 );

    var exp =
    [
      '.',
      './z.will.yml',
      './.module',
      './group1',
      './group1/a.will.yml',
      './group1/.module',
      './group1/out',
      './group1/out/a.out.will.yml',
      './group1/out/debug',
      './group1/out/debug/node_modules',
      './group1/out/debug/node_modules/wmodulefortesting1',
      './group1/out/debug/node_modules/wmodulefortesting1b',
      './group1/out/debug/wtools',
      './group1/out/debug/wtools/testing',
      './group1/out/debug/wtools/testing/Common.s',
      './group1/out/debug/wtools/testing/l1',
      './group1/out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './group1/out/debug/wtools/testing/l3',
      './group1/out/debug/wtools/testing/l3/testing1b',
      './group1/out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
      './out',
      './out/z.out.will.yml',
      './out/debug',
      './out/debug/node_modules',
      './out/debug/node_modules/wmodulefortesting1',
      './out/debug/node_modules/wmodulefortesting1a',
      './out/debug/node_modules/wmodulefortesting1b',
      './out/debug/wtools',
      './out/debug/wtools/testing',
      './out/debug/wtools/testing/Common.s',
      './out/debug/wtools/testing/l1',
      './out/debug/wtools/testing/l1/ModuleForTesting1.s',
      './out/debug/wtools/testing/l2',
      './out/debug/wtools/testing/l2/testing1a',
      './out/debug/wtools/testing/l2/testing1a/ModuleForTesting1a.s',
      './out/debug/wtools/testing/l3',
      './out/debug/wtools/testing/l3/testing1b',
      './out/debug/wtools/testing/l3/testing1b/ModuleForTesting1b.s',
    ];
    var files = a.findNoModules( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  a.appStart( '.with ** .clean recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 12 );

    var exp = [ '.', './z.will.yml', './group1', './group1/a.will.yml' ];
    var files = a.findAll( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

cleanGlobMin.rapidity = -1;

//

/*
  check there is no annoying information about lack of remote submodules of submodules
*/

function cleanRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'export first'
    return null;
  });

  a.appStart( '.with ** .clean' );
  a.appStart( '.with group1/group10/a0 .export' );
  a.appStart( '.with group1/a .export' );
  a.appStart( '.with group1/b .export' );
  a.appStart( '.with group2/c .export' );
  a.appStart( '.with z .export' );

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 24 );
    test.identical( _.strCount( op.output, '+ 1/4 submodule(s) of module::z were downloaded' ), 1 );
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 24 );

    var exp =
    [
      '.',
      './z.will.yml',
      './group1',
      './group1/a.will.yml',
      './group1/b.will.yml',
      './group1/group10',
      './group1/group10/a0.will.yml',
      './group2',
      './group2/c.will.yml'
    ];
    var files = a.findAll( a.routinePath );
    test.identical( files, exp );

    return null;
  });

  /* - */

  return a.ready;
}

cleanRecursive.rapidity = -1;
cleanRecursive.timeOut = 500000;

//

function cleanDisabledModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportDisabledModule' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.clean';
    a.reflectMinimal();
    return null;
  });

  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  a.appStart( '.clean' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with . .clean';
    a.reflectMinimal();
    return null;
  });

  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  a.appStart( '.with . .clean' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean';
    a.reflectMinimal();
    return null;
  });

  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  a.appStartNonThrowing( '.with * .clean' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 0 );
    test.identical( _.strCount( op.output, 'Found no willfile at' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply withDisabled:1 ; .with * .clean';
    a.reflectMinimal();
    return null;
  });

  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ '.module', 'out', 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, 'Exported module::disabled / build::proto.export' ), 1 );

    return null;
  });

  a.appStart( '.imply withDisabled:1 ; .with * .clean' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'will.yml' ];
    var files = a.fileProvider.dirRead( a.routinePath );
    test.identical( files, exp );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

cleanDisabledModule.rapidity = -1;
cleanDisabledModule.timeOut = 300000;
cleanDisabledModule.description =
`
- disabled module should be cleaned if picked explicitly
- disabled module should not be cleaned if picked with glob
`

//

function cleanHierarchyRemote( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );

  /* aaa : problems with willfiles // Dmytro : fixed

about :
  name : a
  version : '0.0.0'

submodule :
  ModuleForTesting1 : git+https:///github.com/Wandalen/wModuleForTesting1.git/
  ModuleForTesting1 : git+https:///github.com/Wandalen/wModuleForTesting1.git/
  a0 : group10/a0

   */

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .clean';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with z .clean' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with * .clean' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean recursive:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with * .clean recursive:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 6 );
    test.identical( _.strCount( op.output, ' at ' ), 8 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with * .clean recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 16 );
    test.identical( _.strCount( op.output, ' at ' ), 18 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean recursive:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStartNonThrowing( '.with ** .clean recursive:1' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 0 );
    test.identical( _.strCount( op.output, ' at ' ), 0 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting1 should not delete itself' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with ** .clean recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 16 );
    test.identical( _.strCount( op.output, ' at ' ), 18 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

cleanHierarchyRemote.rapidity = -1;
cleanHierarchyRemote.timeOut = 1000000;

//

function cleanHierarchyRemoteDry( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .clean dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with z .clean dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with * .clean dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean recursive:1 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with * .clean recursive:1 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 6 );
    test.identical( _.strCount( op.output, ' at ' ), 8 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean recursive:2 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with * .clean recursive:2 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 16 );
    test.identical( _.strCount( op.output, ' at ' ), 18 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean recursive:1 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStartNonThrowing( '.with ** .clean recursive:1 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 0 );
    test.identical( _.strCount( op.output, ' at ' ), 0 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting1 should not delete itself' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean recursive:2 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with ** .clean recursive:2 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 16 );
    test.identical( _.strCount( op.output, ' at ' ), 18 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  })

  /* - */

  return a.ready;

}

cleanHierarchyRemoteDry.rapidity = -1;
cleanHierarchyRemoteDry.timeOut = 1000000;

//

function cleanSubmodulesHierarchyRemote( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .clean.submodules';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.appStart( '.with z .clean.submodules' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean.submodules';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.appStart( '.with * .clean.submodules' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean.submodules recursive:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.appStart( '.with * .clean.submodules recursive:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 3 );
    test.identical( _.strCount( op.output, ' at ' ), 5 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean.submodules recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.appStart( '.with * .clean.submodules recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 4 );
    test.identical( _.strCount( op.output, ' at ' ), 6 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean.submodules recursive:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.appStartNonThrowing( '.with ** .clean.submodules recursive:1' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var exp =  [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 0 );
    test.identical( _.strCount( op.output, ' at ' ), 0 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting1 should not delete itself' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean.submodules recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.appStart( '.with ** .clean.submodules recursive:2' );

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 4 );
    test.identical( _.strCount( op.output, ' at ' ), 6 );
    test.identical( _.strCount( op.output, '- Clean deleted' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

cleanSubmodulesHierarchyRemote.rapidity = -1;
cleanSubmodulesHierarchyRemote.timeOut = 1000000;

//

function cleanSubmodulesHierarchyRemoteDry( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .clean.submodules dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with z .clean.submodules dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean.submodules dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' )
  a.appStart( '.with * .clean.submodules dry:1' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 1 );
    test.identical( _.strCount( op.output, ' at ' ), 3 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .clean.submodules recursive:1 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' )
  a.appStart( '.with * .clean.submodules recursive:1 dry:1' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 3 );
    test.identical( _.strCount( op.output, ' at ' ), 5 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready

  .then( () =>
  {
    test.case = '.with * .clean.submodules recursive:2 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' )
  a.appStart( '.with * .clean.submodules recursive:2 dry:1' )
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 4 );
    test.identical( _.strCount( op.output, ' at ' ), 6 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean.submodules recursive:1 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStartNonThrowing( '.with ** .clean.submodules recursive:1 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 0 );
    test.identical( _.strCount( op.output, ' at ' ), 0 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting1 should not delete itself' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .clean.submodules recursive:2 dry:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with ** .submodules.download recursive:2' );
  a.appStart( '.with ** .clean.submodules recursive:2 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '. Read 19 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, ' at .' ), 4 );
    test.identical( _.strCount( op.output, ' at ' ), 6 );
    test.identical( _.strCount( op.output, '. Clean will delete' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

cleanSubmodulesHierarchyRemoteDry.rapidity = -1;
cleanSubmodulesHierarchyRemoteDry.timeOut = 1000000;

//

function cleanSpecial( test )
{
  let context = this;
  let a = context.assetFor( test, 'cleanSpecial' );
  a.reflect();

  var files = a.fileProvider.dirRead( a.abs( 'out' ) );
  var expected = [ '"#dir2"', '"@dir1"' ];
  test.identical( files, expected )

  /* - */

  a.appStart({ execPath : '.clean' })
  .then( ( op ) =>
  {
    test.case = '.clean';
    test.identical( op.exitCode, 0 );
    test.true( !a.fileProvider.fileExists( a.abs( 'out' ) ) );
    return null;
  })

  /* - */

  return a.ready;
}

//

function cleanSelfRefBug( test )
{
  let context = this;
  let a = context.assetFor( test, 'selfRefIntegrityBug' );

  /* - */

  a.ready.then( ( arg ) => a.reflect() );
  a.appStart({ execPath : '.export' })
  a.appStart({ execPath : '.clean' })
  .then( ( op ) =>
  {
    test.case = 'basic';
    test.identical( op.exitCode, 0 );
    var exp = [ '.', './will.yml', './proto', './proto/File.js' ];
    var got = a.findAll( a.abs( '.' ) );
    test.identical( got, exp );
    return null;
  })

  /* - */

  return a.ready;
}

// --
// shell
// --

function shellWithCriterion( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepShellWithCriterion' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.build A' })

  .then( ( op ) => /* xxx aaa2 : use op only for test checks. use op or arg instead of op as argument of consequence callback */ /* Dmytro : replaced */
  {
    test.description = 'should execute file A.js';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Executed-A.js' ) );
    return null;
  })

  /* - */

  a.appStart({ execPath : '.build B' })

  .then( ( op ) =>
  {
    test.description = 'should execute file B.js';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Executed-B.js' ) );

    return null;
  })

  /* - */

  return a.ready;
}

shellWithCriterion.description =
`
Checks if start step supports plural criterion and which path is selected using current value of criterion
`

//

/*
  Checks amount of output from start step depending on value of verbosity option
*/

function shellVerbosity( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepShellVerbosity' );
  a.reflectMinimal();

  /* - */

  a.appStart({ execPath : '.build verbosity.0' })
  .then( ( op ) =>
  {
    test.case = '.build verbosity.0';

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'node -e "console.log( \'message from shell\' )"' ), 0 );
    test.identical( _.strCount( op.output, a.routinePath ), 1 );
    test.identical( _.strCount( op.output, 'message from shell' ), 0 );
    test.identical( _.strCount( op.output, 'Process returned error code 0' ), 0 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.build verbosity.1' })
  .then( ( op ) =>
  {
    test.case = '.build verbosity.1';

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'node -e "console.log( \'message from shell\' )"' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath ), 1 );
    test.identical( _.strCount( op.output, 'message from shell' ), 1 );
    test.identical( _.strCount( op.output, 'Process returned error code 0' ), 0 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.build verbosity.2' })
  .then( ( op ) =>
  {
    test.case = '.build verbosity.2';

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'node -e "console.log( \'message from shell\' )"' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath ), 1 );
    test.identical( _.strCount( op.output, 'message from shell' ), 2 );
    test.identical( _.strCount( op.output, 'Process returned error code 0' ), 0 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.build verbosity.3' })
  .then( ( op ) =>
  {
    test.case = '.build verbosity.3';

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'node -e "console.log( \'message from shell\' )"' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath ), 2 );
    test.identical( _.strCount( op.output, 'message from shell' ), 2 );
    test.identical( _.strCount( op.output, 'Process returned error code 0' ), 0 );

    return null;
  });

  /* */

  a.appStart({ execPath : '.build verbosity.5' })
  .then( ( op ) =>
  {
    test.case = 'verbosity:5';

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'node -e "console.log( \'message from shell\' )"' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath ), 2 );
    test.identical( _.strCount( op.output, 'message from shell' ), 2 );
    test.identical( _.strCount( op.output, 'Process returned error code 0' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function shellQuotedCommand( test )
{
  let context = this;
  let a = context.assetFor( test, 'open' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.shell "ls -a"';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.shell "ls -a"' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".shell "ls -a""' ), 1 );
    test.identical( _.strCount( op.output, /\. Opened \. .*\.ex\.will\.yml/ ), 1 );
    test.identical( _.strCount( op.output, /\. Opened \. .*\.im\.will\.yml/ ), 1 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s)' ), 0 );
    test.identical( _.strCount( op.output, '> ls -a' ), 1 );
    test.identical( _.strCount( op.output, '..' ), 1 );
    test.identical( _.strCount( op.output, 'doc' ), 3 );
    test.identical( _.strCount( op.output, 'doc.ex.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'doc.im.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '.ex.will.yml' ), 3 );
    test.identical( _.strCount( op.output, '.im.will.yml' ), 3 );
    test.identical( _.strCount( op.output, 'proto' ), 1 );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with */* .shell "ls -a"';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.with */* .shell "ls -a"' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Command ".with */* .shell "ls -a""' ), 1 );
    test.identical( _.strCount( op.output, /\. Opened \. .*\/\.ex\.will\.yml/ ), 2 );
    test.identical( _.strCount( op.output, /\. Opened \. .*\/\.im\.will\.yml/ ), 2 );
    test.identical( _.strCount( op.output, /\. Opened \. .*\/doc\.ex\.will\.yml/ ), 2 );
    test.identical( _.strCount( op.output, /\. Opened \. .*\/doc\.im\.will\.yml/ ), 2 );
    test.identical( _.strCount( op.output, '. Read 8 willfile(s)' ), 0 );
    test.identical( _.strCount( op.output, '> ls -a' ), 4 );
    test.identical( _.strCount( op.output, '..' ), 4 );
    test.identical( _.strCount( op.output, 'doc' ), 18 );
    test.identical( _.strCount( op.output, 'doc.ex.will.yml' ), 6 );
    test.identical( _.strCount( op.output, 'doc.im.will.yml' ), 6 );
    test.identical( _.strCount( op.output, '.ex.will.yml' ), 12 );
    test.identical( _.strCount( op.output, '.im.will.yml' ), 12 );
    test.identical( _.strCount( op.output, 'proto' ), 2 );

    return null;
  });

  /* - */

  return a.ready;
}

shellQuotedCommand.timeOut = 60000;

//

function functionStringsJoin( test )
{
  let context = this;
  let a = context.assetFor( test, 'functionStringsJoin' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build strings.join'
    return null;
  })
  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build strings.join' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'node' ), 1 );
    test.identical( _.strCount( op.output, 'File2.js' ), 1 );
    test.identical( _.strCount( op.output, 'File3.js' ), 1 );
    test.identical( _.strCount( op.output, 'File1.js' ), 1 );
    test.identical( _.strCount( op.output, 'out1.js' ), 1 );

    var expected =
`console.log( 'File2.js' );

console.log( 'File3.js' );

console.log( 'File1.js' );

`
    var read = a.fileProvider.fileRead( a.abs( 'out1.js' ) );
    test.identical( read, expected );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build multiply'
    return null;
  })
  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build multiply' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'node' ), 2 );
    test.identical( _.strCount( op.output, 'File2.js' ), 1 );
    test.identical( _.strCount( op.output, 'File3.js' ), 1 );
    test.identical( _.strCount( op.output, 'File1.js' ), 2 );
    test.identical( _.strCount( op.output, 'out2.js' ), 2 );

    var expected =
`console.log( 'File3.js' );

console.log( 'File1.js' );

`
    var read = a.fileProvider.fileRead( a.abs( 'out2.js' ) );
    test.identical( read, expected );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build echo1'
    return null;
  })
  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build echo1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'node' ), 6 );
    test.identical( _.strCount( op.output, 'File2.js' ), 4 );
    test.identical( _.strCount( op.output, 'File3.js' ), 4 );
    test.identical( _.strCount( op.output, 'File3.js op2' ), 2 );
    test.identical( _.strCount( op.output, 'File3.js op3' ), 2 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build echo2'
    return null;
  })
  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build echo2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'node' ), 6 );
    test.identical( _.strCount( op.output, 'Echo.js op2 op3 op1' ), 2 );
    test.identical( _.strCount( op.output, 'Echo.js op2 op3 op2' ), 2 );

    return null;
  })

  /* - */

  return a.ready;
}

//

function functionPlatform( test )
{
  let context = this;
  let a = context.assetFor( test, 'functionPlatform' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.build'
    return null;
  })
  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build' })
  .then( ( op ) =>
  {
    var Os = require( 'os' );
    let platform = 'posix';

    if( Os.platform() === 'win32' )
    platform = 'windows'
    if( Os.platform() === 'darwin' )
    platform = 'osx'

    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ reflector::copy reflected 2 file(s)' ), 1 );
    test.identical( _.strCount( op.output, `./out/dir.${platform} <- ./proto in` ), 1 );

    var files = a.find( a.abs( 'out' ) );

    test.identical( files, [ '.', `./dir.${platform}`, `./dir.${platform}/File.js` ] );

    return null;
  })

  /* - */

  return a.ready;
}

//

/*
  Checks resolving selector with criterion.
*/

function functionThisCriterion( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepShellUsingCriterionValue' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.build debug' })

  .then( ( op ) =>
  {
    test.description = 'should print debug:1';

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'debug:1' ) );

    return null;
  })

  /* - */

  a.appStart({ execPath : '.build release' })

  .then( ( op ) =>
  {
    test.description = 'should print debug:0';

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'debug:0' ) );

    return null;
  })

  /* - */

  return a.ready;
}

//

function submodulesDownload( test )
{
  const context = this;
  const a = context.assetFor( test, 'download' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download single git submodule';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with SingleGit .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::SingleGit were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'download single npm submodule';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with SingleNpm .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::SingleNpm were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'download single git hd submodule';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with SingleHd .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::SingleHd were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1' ] );
    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download single git submodule with irregular path';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with SingleGitIrregular .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::SingleGitIrregular were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'download single git hd submodule with irregular path';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with SingleHdIrregular .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::SingleHdIrregular were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1' ] );
    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download multiple git submodules';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with MultipleGit .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::MultipleGit were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting2' ] );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'download multiple npm submodules';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with MultipleNpm .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::MultipleNpm were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting2', 'ModuleForTesting2.will.yml' ];
    test.identical( files, exp );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'download multiple git hd submodules';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with MultipleHd .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::MultipleHd were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting2' ] );
    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download mixex types of submodules';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with Mixed .submodules.download' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1b was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2b was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ 6/6 submodule(s) of module::Mixed were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    var exp =
    [
      'ModuleForTesting1',
      'ModuleForTesting1a',
      'ModuleForTesting1b',
      'ModuleForTesting1b.will.yml',
      'ModuleForTesting2',
      'ModuleForTesting2a',
      'ModuleForTesting2b',
      'ModuleForTesting2b.will.yml',
    ];
    test.identical( files, exp );
    return null;
  });

  /* - */

  return a.ready;
}

//

function submodulesDownloadRecursiveGit( test )
{
  const context = this;
  const a = context.assetFor( test, 'downloadRecursiveGit' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'recursive - 0';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/0 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, null );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'recursive - 1';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting2' ] );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, null );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'recursive - 2';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:2' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1b was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2b was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 6/9 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting2' ] );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, [ 'ModuleForTesting1a', 'ModuleForTesting2a' ] );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, [ 'ModuleForTesting1b', 'ModuleForTesting2b' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function submodulesDownloadRecursiveNpm( test )
{
  const context = this;
  const a = context.assetFor( test, 'downloadRecursiveNpm' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'recursive - 0';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1 was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting2 was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/0 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, null );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'recursive - 1';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting2', 'ModuleForTesting2.will.yml' ];
    test.identical( files, exp );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, null );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'recursive - 2';
    a.reflectMinimal();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:2' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting2a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting1b was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::ModuleForTesting2b was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 6/9 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting2', 'ModuleForTesting2.will.yml' ];
    test.identical( files, exp );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    var exp = [ 'ModuleForTesting1a', 'ModuleForTesting1a.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    test.identical( files, exp );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    var exp = [ 'ModuleForTesting1b', 'ModuleForTesting1b.will.yml', 'ModuleForTesting2b', 'ModuleForTesting2b.will.yml' ];
    test.identical( files, exp );
    return null;
  });

  /* - */

  return a.ready;
}

//

function submodulesDownloadRecursiveHd( test )
{
  const context = this;
  const a = context.assetFor( test, 'downloadRecursiveHd' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'recursive - 0';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/0 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, null );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'recursive - 1';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:1' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting2' ] );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, null );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, null );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'recursive - 2';
    a.reflect();
    return null;
  });
  a.appStart({ execPath : '.with a .submodules.download recursive:2' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2 was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2a was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting1b was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ module::wModuleForTesting2b was downloaded version' ), 1 );
    test.identical( _.strCount( op.output, '+ 6/9 submodule(s) of module::a were downloaded' ), 1 );
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, [ 'ModuleForTesting1', 'ModuleForTesting2' ] );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/.module' ) );
    test.identical( files, [ 'ModuleForTesting1a', 'ModuleForTesting2a' ] );
    var files = a.fileProvider.dirRead( a.abs( 'sub1/sub2/.module' ) );
    test.identical( files, [ 'ModuleForTesting1b', 'ModuleForTesting2b' ] );
    return null;
  });

  /* - */

  return a.ready;
}

//

function submodulesDownloadSingle( test )
{
  let context = this;
  let a = context.assetFor( test, 'single' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.submodules.download' })

  .then( ( op ) =>
  {
    test.case = '.submodules.download';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::single were downloaded in' ) );
    return null;
  })

  /* - */

  a.appStart({ execPath : '.submodules.download' })

  .then( ( op ) =>
  {
    test.case = '.submodules.download'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::single were downloaded in' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )
    return null;
  })

  /* - */

  a.appStart({ execPath : '.submodules.update' })

  .then( ( op ) =>
  {
    test.case = '.submodules.update'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::single were updated in' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )
    return null;
  })

  /* - */

  a.appStart({ execPath : '.clean.submodules' })

  .then( ( op ) =>
  {
    test.case = '.clean.submodules';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Clean deleted 0 file(s)' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )
    return null;
  })

  return a.ready;

}

//

function submodulesDownloadEnabledAndDisabled( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadEnabledAndDisabled' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply withSubmodules:0 .build' });
  a.ready.then( ( op ) =>
  {
    test.case = 'download submodules not recursive';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::enabledAndDisabled were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply withSubmodules:1 .build' });
  a.ready.then( ( op ) =>
  {
    test.case = 'download submodules and its modules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::enabledAndDisabled were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply withSubmodules:2 .build' });
  a.ready.then( ( op ) =>
  {
    test.case = 'download submodules recursive';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::enabledAndDisabled were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    return null;
  });

  /* - */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply withSubmodules:0 withDisabledSubmodules:1 .build' });
  a.ready.then( ( op ) =>
  {
    test.case = 'download submodules not recursive';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::enabledAndDisabled were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply withSubmodules:1 withDisabledSubmodules:1 .build' });
  a.ready.then( ( op ) =>
  {
    test.case = 'download submodules and its modules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::enabledAndDisabled were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.imply withSubmodules:2 withDisabledSubmodules:1 .build' });
  a.ready.then( ( op ) =>
  {
    test.case = 'download submodules recursive';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '+ 1/1 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 2/2 submodule(s) of module::enabledAndDisabled were downloaded in' ), 0 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::enabledAndDisabled were downloaded in' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function submodulesDownloadUpdate( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflect();

  /* */

  a.ready

  /* */

  .then( () =>
  {
    test.case = '.submodules.download - first time';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })

  a.appStart({ execPath : '.submodules.download' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 2/2 submodule(s) of module::submodules were downloaded' ) );

    var files = a.find( a.abs( '.module' ) );

    test.true( files.length > 30 );

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = '.submodules.download - again';
    return null;
  })
  a.appStart({ execPath : '.submodules.download' })
  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/2 submodule(s) of module::submodules were downloaded' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )

    var files = a.find( a.abs( '.module/ModuleForTesting1' ) );
    test.true( files.length > 3 );

    var files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.true( files.length > 3 );

    return null;
  })

  /* */

  .then( () =>
  {
    test.case = '.submodules.update - first time';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })
  a.appStart({ execPath : '.submodules.update' })
  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 2/2 submodule(s) of module::submodules were updated' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )

    var files = a.find( a.abs( '.module/ModuleForTesting1' ) );
    test.true( files.length >= 1 );

    var files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.true( files.length >= 1 );

    return null;
  })

  /* */

  .then( () =>
  {
    test.case = '.submodules.update - again';
    return null;
  })
  a.appStart({ execPath : '.submodules.update' })
  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/2 submodule(s) of module::submodules were updated in' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.true( !a.fileProvider.fileExists( a.abs( 'modules' ) ) )

    var files = a.find( a.abs( '.module/ModuleForTesting1' ) );
    test.true( files.length >= 1 );

    var files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.true( files.length >= 1 );

    return null;
  })

  /* */

  var files;

  a.ready
  .then( () =>
  {
    test.case = '.clean.submodules';
    files = a.findAll( a.abs( '.module' ) );
    return files;
  })

  a.appStart({ execPath : '.clean.submodules' })
  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `${files.length}` ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module' ) ) ); /* phantom problem ? */

    return null;
  })

  /* */

  return a.ready;
}

submodulesDownloadUpdate.timeOut = 300000;

//

function submodulesDownloadUpdateDry( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetached' );
  a.reflect();

  /* */

  a.ready.then( () =>
  {
    test.case = '.submodules.download dry:1';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  });

  a.appStart({ execPath : '.submodules.download dry:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    // test.true( _.strHas( op.output, / \+ .*module::ModuleForTesting1.* will be downloaded version .*/ ) );
    // test.true( _.strHas( op.output, / \+ .*module::ModuleForTesting2.* will be downloaded version .*0a9ac9ecbfbab54af8f99c61a9dd938659b065a1.*/ ) );
    // test.true( _.strHas( op.output, / \+ .*module::ModuleForTesting1a.* will be downloaded version .*$.$.$$$.*/ ) );
    test.true( _.strHas( op.output, '+ 2/5 submodule(s) of module::submodulesDetached will be downloaded' ) );
    var files = a.find( a.abs( '.module' ) );
    test.true( files.length === 0 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.submodules.download dry:1 -- after download';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })

  a.appStart({ execPath : '.submodules.download' })
  a.appStart({ execPath : '.submodules.download dry:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '0/5 submodule(s) of module::submodulesDetached will be downloaded' ) );
    var files = a.find( a.abs( '.module' ) );
    test.gt( files.length, 50 );
    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.update dry:1';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })

  a.appStart({ execPath : '.submodules.update dry:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    // test.true( _.strHas( op.output, / \+ .*module::Tools.* will be updated to version .*/ ) );
    // test.true( _.strHas( op.output, / \+ .*module::PathBasic.* will be updated to version .*622fb3c259013f3f6e2aeec73642645b3ce81dbc.*/ ) );
    // test.true( _.strHas( op.output, / \+ .*module::Color.* will be updated to version .*0.3.115.*/ ) );
    test.true( _.strHas( op.output, '+ 2/5 submodule(s) of module::submodulesDetached will be updated' ) );
    var files = a.find( a.abs( '.module' ) );
    test.true( files.length === 0 );
    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.update dry:1 -- after update';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })

  a.appStart({ execPath : '.submodules.update' })
  a.appStart({ execPath : '.submodules.update dry:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/5 submodule(s) of module::submodulesDetached will be updated' ) );
    var files = a.find( a.abs( '.module' ) );
    test.gt( files.length, 50 );
    return null;
  })

  /* */

  return a.ready;
}

submodulesDownloadUpdateDry.timeOut = 300000;

//

function submodulesDownloadSwitchBranch( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesUpdateSwitchBranch' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup repo';

    let con = _.take( null );
    a.fileProvider.dirMake( a.abs( 'experiment' ) );

    let start = _.process.starter
    ({
      currentPath : a.routinePath,
      outputCollecting : 1,
      ready : con,
    })

    start( 'git -C experiment init --bare' )
    start( 'git clone experiment cloned' )

    .then( () =>
    {
      return a.fileProvider.filesReflect({ reflectMap : { [ a.abs( 'src' ) ] : a.abs( 'cloned' ) } })
    })

    start( 'git -C cloned add -fA .' )
    start( 'git -C cloned commit -m init' )
    start( 'git -C cloned push' )
    start( 'git -C cloned checkout -b dev' )
    start( 'git -C cloned commit --allow-empty -m test' )
    start( 'git -C cloned push origin dev' )

    return con;
  })

  .then( () =>
  {
    test.case = 'download master branch';
    return null;
  })

  a.appStart({ execPath : '.submodules.download' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'switch master to dev';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    // willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '!master', '#dev' );
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '!master', '!dev' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });

    return null;
  })

  a.appStart({ execPath : '.submodules.download' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'switch dev to detached state';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '#dev', '#9ce409887df0754760a1cbdce249b0fa5f08152e' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    return null;
  })

  a.appStart({ execPath : '.submodules.download' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'switch detached state to master';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '#9ce409887df0754760a1cbdce249b0fa5f08152e', '!master' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    return null;
  })

  a.appStart({ execPath : '.submodules.download' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  return a.ready;
}

submodulesDownloadSwitchBranch.timeOut = 300000;

//

function submodulesDownloadWithSubmodulesDefault( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownload' );
  a.appStartNonThrowing2 = _.process.starter
  ({
    currentPath : a.abs( 'module' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    ready : a.ready,
  });
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download using command submodules.download';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  });
  a.appStartNonThrowing2( 'git init' );
  a.appStartNonThrowing2( 'git add .' );
  a.appStartNonThrowing2( 'git commit -m init' );

  a.appStart({ execPath : '.submodules.download' })
  .then( ( op ) =>
  {
    let downloadedModules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( downloadedModules, [ 'submodule' ] );

    test.identical( _.strCount( op.output, /. Opened ./ ), 3 );
    test.identical( _.strCount( op.output, /. Opened .*\/\.will.yml/ ), 1 );
    test.identical( _.strCount( op.output, /. Opened .*\.module\/submodule\/out\/submodule\.out\.will\.yml/ ), 1 );
    test.identical( _.strCount( op.output, /. Opened .*\.module\/submodule\/submodule.will.yml./ ), 1 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) .* downloaded/ ), 1 );

    return null;
  })

  return a.ready;
}

submodulesDownloadWithSubmodulesDefault.rapidity = 1;
submodulesDownloadWithSubmodulesDefault.timeOut = 300000;

//

function submodulesDownloadUpdateWithSubmodulesDefault( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownload' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download using command submodules.download';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git add .' });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git commit -m init' });

  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( ( op ) =>
  {
    let downloadedModules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( downloadedModules, [ 'submodule' ] );

    test.identical( _.strCount( op.output, /. Opened ./ ), 3 );
    test.identical( _.strCount( op.output, /. Opened .*\/\.will.yml/ ), 1 );
    test.identical( _.strCount( op.output, /. Opened .*\.module\/submodule\/out\/submodule\.out\.will\.yml/ ), 1 );
    test.identical( _.strCount( op.output, /. Opened .*\.module\/submodule\/submodule.will.yml./ ), 1 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) .* updated/ ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

submodulesDownloadUpdateWithSubmodulesDefault.rapidity = 1;
submodulesDownloadUpdateWithSubmodulesDefault.timeOut = 300000;

//

function submodulesDownloadRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyDiffDownloadPathsRegular' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with * .submodules.download recursive:2';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with * .submodules.download recursive:2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b', 'wModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 8/9 submodule(s) of module::c were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );

    return null;
  });

  a.appStart({ execPath : '.with * .submodules.download recursive:2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b', 'wModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Read 10 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 0/9 submodule(s) of module::c were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download recursive:2';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with c .submodules.download recursive:2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b', 'wModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 8/9 submodule(s) of module::c were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );

    return null;
  });

  a.appStart({ execPath : '.with c .submodules.download recursive:2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b', 'wModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Read 10 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 0/9 submodule(s) of module::c were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .submodules.download recursive:1';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with * .submodules.download recursive:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 4/5 submodule(s) of module::c were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  a.appStart({ execPath : '.with * .submodules.download recursive:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Read 10 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 0/5 submodule(s) of module::c were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download recursive:1';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with c .submodules.download recursive:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 4/5 submodule(s) of module::c were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  a.appStart({ execPath : '.with c .submodules.download recursive:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Read 10 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 0/5 submodule(s) of module::c were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with * .submodules.download recursive:0';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with * .submodules.download recursive:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 0/0 submodule(s) of module::c were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download recursive:0';
    a.reflect();
    return null;
  });

  a.appStart({ execPath : '.with c .submodules.download recursive:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp )

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp )

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Read 2 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, 'willfile(s) in' ), 1 );

    test.identical( _.strCount( op.output, '+ 0/0 submodule(s) of module::c were downloaded in' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );

    return null;
  });

  /* - */

  return a.ready;
}

submodulesDownloadRecursive.timeOut = 1000000;
// xxx

//

function submodulesDownloadThrowing( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadErrors' );
  let filesBefore;
  a.appStartNonThrowing2 = _.process.starter
  ({
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    ready : a.ready,
  })
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = 'error on download, new directory should not be made';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with bad .submodules.download' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /fatal:.*https:\/\/abc.com\/Wandalen\/wModuleForTesting2a\.git/ ) );
    test.true( _.strHas( op.output, 'Failed to download module' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error on download, existing empty directory should be preserved';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with bad .submodules.download' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /fatal:.*https:\/\/abc.com\/Wandalen\/wModuleForTesting2a\.git/ ) );
    test.true( _.strHas( op.output, 'Failed to download module' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.identical( a.fileProvider.dirRead( a.abs( '.module/ModuleForTesting2a' ) ), [] );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'no error if download path exists and its an empty dir';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with good .submodules.download' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'Failed to download module' ) );
    test.true( _.strHas( op.output, 'module::wModuleForTesting2a was downloaded version master in' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodulesDownloadErrorsGood were downloaded' ) );

    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    // test.gt( files.length, 10 );
    test.ge( files.length, 1 );

    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error if download path exists and it is not a empty dir';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a/file' ), a.abs( '.module/ModuleForTesting2a/file' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with bad .submodules.download' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var exp = `Module module::submodulesDownloadErrorsBad / opener::ModuleForTesting2a is downloaded, but it's not a git repo`;
    test.true( _.strHas( op.output, exp ) );
    test.true( _.strHas( op.output, 'Failed to download module' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.identical( a.fileProvider.dirRead( a.abs( '.module/ModuleForTesting2a' ) ), [ 'file' ] );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error if download path exists and its terminal';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a' ), a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with bad .submodules.download' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var expected = `Module module::submodulesDownloadErrorsBad / opener::ModuleForTesting2a is not downloaded, but file at`;
    test.true( _.strHas( op.output, expected ) );
    test.true( _.strHas( op.output, 'Failed to download module' ) );
    test.true( a.fileProvider.isTerminal( a.abs( '.module/ModuleForTesting2a' ) ) )
    return null;
  })

  //

  // .then( () =>
  // {
  //   test.case = 'no error if download path exists and it has other git repo';
  //   a.fileProvider.filesDelete( a.abs( '.module' ) );
  //   a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
  //   return null;
  // })
  .then( () =>
  {
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })
  a.appStartNonThrowing2({ execPath : 'git clone https://github.com/Wandalen/wModuleForTesting1.git .module/ModuleForTesting2a' })
  .then( () =>
  {
    filesBefore = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with good .submodules.download' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodulesDownloadErrorsGood were downloaded' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    let filesAfter = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( filesAfter, filesBefore );

    return null;
  })

  //

  a.ready
  .then( () =>
  {
    test.case = 'downloaded, change in file to make module not valid, error expected';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with good .submodules.download' })
  .then( () =>
  {
    let inWillFilePath = a.abs( '.module/ModuleForTesting2a/will.yml' );
    let inWillFile = a.fileProvider.fileReadUnknown( inWillFilePath );
    inWillFile.section = { field : 'value' };
    a.fileProvider.fileWrite({ filePath : inWillFilePath, data : inWillFile, encoding : 'yml' });
    return null;
  })
  .then( () =>
  {
    filesBefore = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.with good .submodules.download' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Willfile should not have section(s) : "section"' ) );
    let filesAfter = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( filesAfter, filesBefore )
    return null;
  })

  /* - */

  return a.ready;
}

submodulesDownloadThrowing.timeOut = 300000;

//

function submodulesDownloadInvalidUrl( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadErrors' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'download submodule with not supported protocol';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  });
  a.appStartNonThrowing({ execPath : '.with badProtocol .submodules.download' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".with badProtocol .submodules.download"' ), 1 );
    test.identical( _.strCount( op.output, /\. Opened \. .*badProtocol\.will\.yml/ ), 1 );
    var exp = 'No repo provider for path::git+bad:///github.com/Wandalen/wModuleForTesting2a.git/';
    test.identical( _.strCount( op.output, exp ), 1 );
    var exp = 'Failed to make module at git+bad:///github.com/Wandalen/wModuleForTesting2a.git/';
    test.identical( _.strCount( op.output, exp ), 1 );
    test.identical( _.strCount( op.output, 'Failed to make resource relation::ModuleForTesting2a' ), 1 );
    test.identical( _.strCount( op.output, 'Cant form relation::ModuleForTesting2a' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to import willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open module at' ), 1 );

    test.identical( _.strCount( op.output, '. Read 1 willfile(s) in' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/1 submodule(s) of module::submodulesDownloadErrorsBadProtocol were downloaded in' ), 0 );
    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );
    return null;
  });

  /* - */

  return a.ready;
}

submodulesDownloadInvalidUrl.timeOut = 300000;
submodulesDownloadInvalidUrl.description =
`
Module path is contain unsupported protocol.
Utility should throw error and exit with non-zero code.
`;

//

function submodulesDownloadStepAndCommand( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownload' );
  a.appStartNonThrowing2 = _.process.starter
  ({
    currentPath : a.abs( 'module' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    ready : a.ready,
  });
  a.reflect();

  /* submodules.download step downloads submodules recursively, but should not */

  a.ready.then( () =>
  {
    test.case = 'download using step::submodules.download';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  });
  a.appStartNonThrowing2( 'git init' );
  a.appStartNonThrowing2( 'git add .' );
  a.appStartNonThrowing2( 'git commit -m init' );
  a.appStartNonThrowing({ execPath : '.build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( '.module' ) );
    test.true( !_.longHas( files, './ModuleForTesting1' ) )
    test.true( !_.longHas( files, './ModuleForTesting2a' ) )
    test.true( _.longHas( files, './submodule' ) )
    return null;
  })

  /* submodules.download command downloads only own submodule, as expected */

  .then( () =>
  {
    test.case = 'download using command submodules.download'
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })
  a.appStartNonThrowing2( 'git init' )
  a.appStartNonThrowing2( 'git add .' )
  a.appStartNonThrowing2( 'git commit -m init' )
  a.appStartNonThrowing({ execPath : '.submodules.download' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( '.module' ) );
    test.true( !_.longHas( files, './ModuleForTesting1' ) )
    test.true( !_.longHas( files, './ModuleForTesting2a' ) )
    test.true( _.longHas( files, './submodule' ) )
    return null;
  })

  /*  */

  return a.ready;
}

//

function submodulesDownloadDiffDownloadPathsRegular( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyDiffDownloadPathsRegular' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download';
    a.reflect();
    return null;
  })

  a.appStart( '.with c .clean recursive:2' )
  a.appStart( '.with c .submodules.download' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Opened .' ), 10 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 4 );
    test.identical( _.strCount( op.output, '+ 4/5 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  })

  a.appStart( '.with c .submodules.download' )

  .then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 10 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/5 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download recursive:2';
    a.reflect();
    return null;
  })

  a.appStart( '.with c .clean recursive:2' )
  a.appStart( '.with c .submodules.download recursive:2' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b', 'wModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Opened .' ), 20 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 8 );
    test.identical( _.strCount( op.output, '+ 8/9 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  })

  a.appStart( '.with c .submodules.download recursive:2' )

  .then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2b', 'wModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1a', 'ModuleForTesting2b' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 18 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/9 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

submodulesDownloadDiffDownloadPathsRegular.timeOut = 300000;

//

function submodulesDownloadDiffDownloadPathsIrregular( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyDiffDownloadPathsIrregular' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download';
    a.reflect();
    return null;
  });

  a.appStart( '.with c .clean recursive:2' );
  a.appStart( '.with c .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Opened .' ), 18 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 4 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 4 );
    test.identical( _.strCount( op.output, '+ 4/5 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  });

  a.appStart( '.with c .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 10 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/5 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with c .submodules.download recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with c .clean recursive:2' );
  a.appStart( '.with c .submodules.download recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 4 );
    test.identical( _.strCount( op.output, '. Opened .' ), 18 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 4 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 4 );
    test.identical( _.strCount( op.output, '+ 4/5 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  });

  a.appStart( '.with c .submodules.download recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12', 'ModuleForTesting12ab', 'ModuleForTesting1a', 'ModuleForTesting2' ];
    var files = a.fileProvider.dirRead( a.abs( 'a/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 18 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/5 submodule(s) of module::c were downloaded' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

submodulesDownloadDiffDownloadPathsIrregular.rapidity = -1;
submodulesDownloadDiffDownloadPathsIrregular.timeOut = 400000;

//

function submodulesDownloadHierarchyRemote( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyRemote' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .submodules.download';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.appStart( '.with z .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 8 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/4 submodule(s) of module::z were downloaded' ), 1 );

    return null;
  });

  a.appStart( '.with z .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/4 submodule(s) of module::z were downloaded' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with z .submodules.download recursive:1';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.appStart( '.with z .submodules.download recursive:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 8 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/4 submodule(s) of module::z were downloaded' ), 1 );

    return null;
  });

  a.appStart( '.with z .submodules.download recursive:1' );
  a.ready.then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = null;
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/4 submodule(s) of module::z were downloaded' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with z .submodules.download recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.appStart( '.with z .submodules.download recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 3 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 4 );
    test.identical( _.strCount( op.output, '+ 4/8 submodule(s) of module::z were downloaded' ), 1 );

    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' );
  a.ready.then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting12', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1b' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/group10/.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting12ab' ];
    var files = a.fileProvider.dirRead( a.abs( 'group2/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 19 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/8 submodule(s) of module::z were downloaded' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

submodulesDownloadHierarchyRemote.rapidity = -1;
submodulesDownloadHierarchyRemote.timeOut = 400000;

//

function submodulesDownloadHierarchyDuplicate( test )
{
  let context = this;
  let a = context.assetFor( test, 'hierarchyDuplicate' );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with z .submodules.download';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );

  a.appStart( '.with z .submodules.download' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/2 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );

    return null;
  });

  a.appStart( '.with z .submodules.download' )
  .then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/2 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with z .submodules.download recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' );
  a.appStart( '.with z .submodules.download recursive:2' );

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/2 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );

    return null;
  });

  a.appStart( '.with z .submodules.download recursive:2' )
  .then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/2 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with ** .submodules.download recursive:2';
    a.reflect();
    return null;
  });

  a.appStart( '.with z .clean recursive:2' )
  a.appStart( '.with ** .submodules.download recursive:2' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );


    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 1 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 1 );
    test.identical( _.strCount( op.output, '+ 1/2 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );

    return null;
  })

  a.appStart( '.with z .submodules.download recursive:2' )

  .then( ( op ) =>
  {
    test.case = 'second';
    test.identical( op.exitCode, 0 );


    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    var exp = [ 'ModuleForTesting1' ];
    var files = a.fileProvider.dirRead( a.abs( 'group1/.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/2 submodule(s) of module::z were downloaded' ), 1 );
    test.identical( _.strCount( op.output, 'submodule(s)' ), 1 );

    return null;
  })

  /* - */

  return a.ready;
}

submodulesDownloadHierarchyDuplicate.rapidity = -1;
submodulesDownloadHierarchyDuplicate.timeOut = 300000;

//

function submodulesDownloadNpm( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadNpm' );
  let versions = {}
  let filesBefore = null;

  /* - */

  a.ready

  .then( () =>
  {
    versions[ 'ModuleForTesting1' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting1' );
    versions[ 'ModuleForTesting2a' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting2a!alpha' );
    versions[ 'ModuleForTesting12ab' ] = _.npm.remoteVersionCurrent( 'npm:///wmodulefortesting12ab#0.0.31' );

    a.reflect();

    return null;
  })

  /* */

  a.appStart( '.submodules.download' )

  .then( ( op ) =>
  {
    test.case = 'download npm modules';

    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting12ab', 'ModuleForTesting12ab.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 3 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 3 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::supermodule were downloaded' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was downloaded version ${versions[ 'ModuleForTesting1' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was downloaded version ${versions[ 'ModuleForTesting2a' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was downloaded version ${versions[ 'ModuleForTesting12ab' ]}` ), 1 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 2 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 1 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] )

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) )

    return null;
  })

  /*  */

  a.appStart( '.submodules.download' )

  .then( ( op ) =>
  {
    test.case = 'second run of .submodules.download';

    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting12ab', 'ModuleForTesting12ab.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'was downloaded' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::supermodule were downloaded' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was downloaded version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was downloaded version ${versions[ 'ModuleForTesting2a' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was downloaded version ${versions[ 'ModuleForTesting12ab' ]}` ), 0 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 0 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] )

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) )

    return null;
  })

  /*  */

  .then( () =>
  {
    test.case = 'change origin of first submodule and run .submodules.download';

    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, 'npm:///wmodulefortesting1 ', 'npm:///wmodulefortesting2b' );
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );

    filesBefore = a.find( a.abs( '.module/ModuleForTesting1' ) );

    return null;
  })

  a.appStart( '.submodules.download' )

  .then( ( op ) =>
  {

    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting12ab', 'ModuleForTesting12ab.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::supermodule were downloaded' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was downloaded version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was downloaded version ${versions[ 'ModuleForTesting2a' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was downloaded version ${versions[ 'ModuleForTesting12ab' ]}` ), 0 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 0 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] )

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) )

    var files = a.find( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( files, filesBefore );

    return null;
  })
  .then( () =>
  {
    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, 'npm:///wmoduleforTesting2b', 'npm:///wmodulefortesting1' );
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );

    return null;
  })

  /*  */

  return a.ready;
}

submodulesDownloadNpm.timeOut = 600000;

//

function submodulesDownloadUpdateNpm( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadNpm' );
  let versions = {}
  let filesBefore = null;

  /* - */

  a.ready

  .then( () =>
  {
    versions[ 'ModuleForTesting1' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting1' );
    versions[ 'ModuleForTesting2a' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting2a!alpha' );
    versions[ 'ModuleForTesting12ab' ] = _.npm.remoteVersionCurrent( 'npm:///wmodulefortesting12ab#0.0.31' );

    a.reflect();

    return null;
  })

  /* */

  a.appStart( '.submodules.update' )

  .then( ( op ) =>
  {
    test.case = 'download npm modules';

    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting12ab', 'ModuleForTesting12ab.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 3 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'were updated' ), 1 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::supermodule were updated' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was updated to version ${versions[ 'ModuleForTesting1' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was updated to version ${versions[ 'ModuleForTesting2a' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was updated to version ${versions[ 'ModuleForTesting12ab' ]}` ), 1 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 2 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 1 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] )

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) )

    return null;
  })

  /*  */

  .then( ( op ) =>
  {
    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, '!alpha', '!beta' );
    willFile = _.strReplace( willFile, '!0.0.31', '!0.0.32 ' ); /* Dmytro : need to test writer, it appends zero to last number */
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );

    versions[ 'ModuleForTesting2a' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting2a!beta' );
    versions[ 'ModuleForTesting12ab' ] = '0.0.32'

    return null;
  })

  a.appStart( '.submodules.update' )

  .then( ( op ) =>
  {
    test.case = 'second run of .submodules.update';

    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting12ab', 'ModuleForTesting12ab.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 11 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'were updated' ), 1 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::supermodule were updated' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was updated to version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was updated to version ${versions[ 'ModuleForTesting2a' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was updated to version ${versions[ 'ModuleForTesting12ab' ]}` ), 1 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 1 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] )

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) )

    return null;
  })

  /*  */

  a.appStart( '.submodules.update' )

  .then( ( op ) =>
  {
    test.case = 'third run of .submodules.update';

    test.identical( op.exitCode, 0 );

    var exp = [ 'ModuleForTesting1', 'ModuleForTesting1.will.yml', 'ModuleForTesting12ab', 'ModuleForTesting12ab.will.yml', 'ModuleForTesting2a', 'ModuleForTesting2a.will.yml' ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'were updated' ), 1 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::supermodule were updated' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was updated to version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was updated to version ${versions[ 'ModuleForTesting2a' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was updated to version ${versions[ 'ModuleForTesting12ab' ]}` ), 0 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 0 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] )
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] )

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) )
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) )

    return null;
  })

  /*  */

  .then( () =>
  {
    test.case = 'change origin of first submodule and run .submodules.update';

    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, 'npm:///wmodulefortesting1', 'npm:///wmodulefortesting2b' );
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );

    filesBefore = a.find( a.abs( '.module' ) );

    return null;
  })

  a.appStartNonThrowing( '.submodules.update' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 1 );

    var files = a.find( a.abs( '.module' ) );
    test.identical( files, filesBefore );

    test.identical( _.strCount( op.output, 'opener::ModuleForTesting1 is already downloaded, but has different origin url: wmodulefortesting1 , expected url: wmodulefortesting2b' ), 1 );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::supermodule were updated' ), 0 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was updated to version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was updated to version ${versions[ 'ModuleForTesting2a' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was updated to version ${versions[ 'ModuleForTesting12ab' ]}` ), 0 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 0 );

    return null;
  })

  .then( () =>
  {
    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, 'npm:///wmoduleforTesting2b', 'npm:///wmodulefortesting1' );
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );
    return null;
  })

  return a.ready;
}

submodulesDownloadUpdateNpm.timeOut = 600000;

//

function submodulesDownloadAutoCrlfEnabled( test )
{
  let context = this;
  let runningInsideTestContainer = _.process.insideTestContainer();
  let a = context.assetFor( test, 'submodulesDownloadCrlf' );

  /* - */

  test.description = 'checks that global option core.autocrlf=true does not affect on submodules download'

  prepare()

  if( runningInsideTestContainer )
  a.shell( 'git config --global core.autocrlf true' );

  a.appStart({ execPath : '.submodules.download' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 1/1 submodule(s) of module::supermodule were downloaded in' ) );
    return null;
  })
  a.appStart({ execPath : '.submodules.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 3 );
    test.identical( _.strCount( op.output, '! Outdated .' ), 0 );
    return null;
  })

  /* - */

  return a.ready;

  /* - */

  function prepare( o )
  {
    a.ready.then( () => { a.reflect(); return null } );
    a.appStart({ execPath : '.with module/submodule .export' })
    let shell = _.process.starter({ currentPath : a.abs( 'module' ), ready : a.ready })
    shell( 'git init' )
    shell( 'git config core.autocrlf false' )
    shell( 'git add -fA .' )
    shell( 'git commit -m init' )
    return a.ready;
  }
}

//

function rootModuleRenormalization( test )
{
  let context = this;
  let a = context.assetFor( test, 'renormalization' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.with repo/ .submodules.download' })
  .then( ( op ) =>
  {
    test.description = 'run submodules.download on module that is not a git repo';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::supermodule were downloaded in' ) );
    return null;
  })

  /* - */

  a.appStart({ execPath : '.with repo/ .submodules.update' })
  .then( ( op ) =>
  {
    test.description = 'run submodules.update on module that is not a git repo';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::supermodule were updated in' ) );
    return null;
  })

  /* - */

  prepareClone()
  a.appStart({ execPath : '.with repoClone/ .submodules.list' })
  .then( ( op ) =>
  {
    test.description = 'will file of git module has modified eol( crlf ), out file should be marked as outdated';
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.true( _.strHas( op.output, /\! Outdated \. .*supermodule\.out\.will\.yml/g ) );
    return null;
  })
  a.appStart({ execPath : '.with repoClone/ .submodules.download' })
  .then( ( op ) =>
  {
    test.description = 'files of a git module should be normalized after executing submodules.download';
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::supermodule were downloaded in' ) );
    return null;
  })
  a.appStart({ execPath : '.with repoClone/ .submodules.list' })
  .then( ( op ) =>
  {
    test.description = 'out file of root git module should be up to date';
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.true( !_.strHas( op.output, /\! Outdated \. .*supermodule\.out\.will\.yml/g ) );
    return null;
  })

  /* - */

  prepareClone()
  a.appStart({ execPath : '.with repoClone/ .submodules.list' })
  .then( ( op ) =>
  {
    test.description = 'will file of git module has modified eol( crlf ), out file should be marked as outdated';
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.true( _.strHas( op.output, /\! Outdated \. .*supermodule\.out\.will\.yml/g ) );
    return null;
  })
  a.appStart({ execPath : '.with repoClone/ .submodules.update' })
  .then( ( op ) =>
  {
    test.description = 'files of a git module should be normalized after executing submodules.download';
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::supermodule were updated in' ) );
    return null;
  })
  a.appStart({ execPath : '.with repoClone/ .submodules.list' })
  .then( ( op ) =>
  {
    test.description = 'out file of root git module should be up to date';
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.true( !_.strHas( op.output, /\! Outdated \. .*supermodule\.out\.will\.yml/g ) );
    return null;
  })

  /* - */

  prepareClone()
  a.appStart({ execPath : '.with repoClone/ .submodules.list' })
  .then( ( op ) =>
  {
    test.description = 'will file of git module has modified eol( crlf ), out file should be marked as outdated';
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.true( _.strHas( op.output, /\! Outdated \. .*supermodule\.out\.will\.yml/g ) );

    a.fileProvider.fileWrite( a.abs( 'repoClone/File.js' ), 'console.log( 1 );' );

    return null;
  })
  a.appStart({ execPath : '.with repoClone/ .submodules.download' })
  .then( ( op ) =>
  {
    test.description = 'files of a git module should not be normalized, because module repository has local changes';
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::supermodule were downloaded in' ) );
    return null;
  })
  a.appStart({ execPath : '.with repoClone/ .submodules.list' })
  .then( ( op ) =>
  {
    test.description = 'out file of root git module should stay stale';
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.true( _.strHas( op.output, /\! Outdated \. .*supermodule\.out\.will\.yml/g ) );
    return null;
  })

  /* - */

  prepareClone({ attributes : '* text' })
  a.appStart({ execPath : '.with repoClone/ .submodules.download' })
  .then( ( op ) =>
  {
    test.description = 'gitattrubutes has "* text" attribute, normalization should print warning that result can be affected by gitattrubutes';
    test.true( _.strHas( op.output, /File \.gitattributes from the repository at .* contains lines that can affect the result of EOL normalization/g ) )
    test.true( _.strHas( op.output, '+ 0/0 submodule(s) of module::supermodule were downloaded in' ) );
    return null;
  })

  /* - */

  return a.ready;

  /* - */

  function prepareClone( o )
  {
    a.ready.then( () => { a.reflect(); return null } );
    a.appStart({ execPath : '.with repo/ .export' })
    a.shell( 'git -C repo init' )
    a.shell( 'git -C repo config core.autocrlf false' )

    if( o )
    a.ready.then( () =>
    {
      if( o.attributes )
      a.fileProvider.fileWrite( a.abs( 'repo/.gitattributes' ), o.attributes );
      return null;
    })

    a.shell( 'git -C repo add -fA .' )
    a.shell( 'git -C repo commit -m init' )
    a.shell( 'git clone repo repoClone --config core.autocrlf=true' )
    return a.ready;
  }
}

rootModuleRenormalization.timeOut = 200000;

//

function submodulesUpdateThrowing( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadErrors' );
  let filesBefore;
  a.appStart = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    mode : 'spawn',
    ready : a.ready,
  });
  a.appStartNonThrowing = _.process.starter
  ({
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    ready : a.ready,
  })
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = 'error on update, new directory should not be made';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })
  a.appStart({ execPath : '.with bad .submodules.update' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /fatal:.*https:\/\/abc.com\/Wandalen\/wModuleForTesting2a\.git/ ) );
    test.true( _.strHas( op.output, 'Failed to update module' ) );

    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error on update, existing empty directory should be preserved';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with bad .submodules.update' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /fatal:.*https:\/\/abc.com\/Wandalen\/wModuleForTesting2a\.git/ ) );
    test.true( _.strHas( op.output, 'Failed to update module' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.identical( a.fileProvider.dirRead( a.abs( '.module/ModuleForTesting2a' ) ), [] );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'no error if download path exists and its an empty dir';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.update' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'Failed to download update' ) );
    test.true( _.strHas( op.output, 'module::wModuleForTesting2a was updated to version master in' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodulesDownloadErrorsGood were updated in' ) );

    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.ge( files.length, 1 );

    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error if download path exists and it is not a empty dir';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a/file' ), a.abs( '.module/ModuleForTesting2a/file' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.update' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var exp = `Module module::submodulesDownloadErrorsGood / opener::ModuleForTesting2a is downloaded, but it's not a git rep`;
    test.true( _.strHas( op.output, exp ) );
    test.true( _.strHas( op.output, 'Failed to update module' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    test.identical( a.fileProvider.dirRead( a.abs( '.module/ModuleForTesting2a' ) ), [ 'file' ] );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error if download path exists and its terminal';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a' ), a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.update' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Module module::submodulesDownloadErrorsGood / opener::ModuleForTesting2a is not downloaded, but file at' ) );
    test.true( _.strHas( op.output, 'Failed to update submodules' ) );
    test.true( a.fileProvider.isTerminal( a.abs( '.module/ModuleForTesting2a' ) ) )
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error if download path exists and it has other git repo, repo should be preserved';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : 'git clone https://github.com/Wandalen/wModuleForTesting1.git .module/ModuleForTesting2a' })
  .then( () =>
  {
    filesBefore = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.update' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'opener::ModuleForTesting2a is already downloaded, but has different origin url') );
    test.true( _.strHas( op.output, 'Failed to update submodules' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    let filesAfter = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( filesBefore.length, filesAfter.length );

    return null;
  })

  //

  a.ready
  .then( () =>
  {
    test.case = 'downloaded, change in file to make module not valid, error expected';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.update' })
  .then( () =>
  {
    let inWillFilePath = a.abs( '.module/ModuleForTesting2a/will.yml' );
    let inWillFile = a.fileProvider.fileReadUnknown( inWillFilePath );
    inWillFile.section = { field : 'value' };
    a.fileProvider.fileWrite({ filePath : inWillFilePath, data : inWillFile, encoding : 'yml' });
    return null;
  })
  .then( () =>
  {
    filesBefore = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.update' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Willfile should not have section(s) : "section"' ) );
    let filesAfter = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( filesAfter, filesBefore )
    return null;
  })

  /* - */

  return a.ready;
}

submodulesUpdateThrowing.timeOut = 600000;
submodulesUpdateThrowing.rapidity = -2;

//

function submodulesAgreeThrowing( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadErrors' );
  let filesBefore;
  a.appStart = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    mode : 'spawn',
    ready : a.ready,
  });
  a.appStartNonThrowing = _.process.starter
  ({
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    ready : a.ready,
  })
  a.reflect();

  /* - */

  a.ready

  .then( () =>
  {
    test.case = 'error on agree, new directory should not be made';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    return null;
  })
  a.appStart({ execPath : '.with bad .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Failed to agree module' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error on download, existing empty directory will be deleted ';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with bad .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Failed to agree module' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'existing empty directory will be deleted ';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'Failed to agree module' ) );
    test.true( _.strHas( op.output, 'module::wModuleForTesting2a was agreed with version master' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodulesDownloadErrorsGood were agreed' ) );
    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.gt( files.length, 10 );

    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error on download, dir with terminal at download path, download path will be deleted';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a/file' ), a.abs( '.module/ModuleForTesting2a/file' ) );
    return null;
  })
  a.appStart({ execPath : '.with bad .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Failed to agree module' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );

    return null;
  })

  //

  .then( () =>
  {
    test.case = 'dir with terminal at download path, download path will be deleted';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a/file' ), a.abs( '.module/ModuleForTesting2a/file' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'Failed to agree module' ) );
    test.true( _.strHas( op.output, 'module::wModuleForTesting2a was agreed with version master' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodulesDownloadErrorsGood were agreed' ) );
    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.gt( files.length, 10 );

    return null;
  })

  //

  .then( () =>
  {
    test.case = 'error on download, download path exists and its terminal, file will be removed';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a' ), a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with bad .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Failed to agree module' ) );
    test.true( !a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'download path exists and its terminal, file will be removed';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a' ), a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, 'Failed to agree module' ) );
    test.true( _.strHas( op.output, 'module::wModuleForTesting2a was agreed with version master' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodulesDownloadErrorsGood were agreed in' ) );
    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.gt( files.length, 10 );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'donwloaded repo has different origin, should be deleted and downloaded again';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : 'git clone https://github.com/Wandalen/wModuleForTesting1.git .module/ModuleForTesting2a' })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodulesDownloadErrorsGood were agreed' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.gt( files.length, 10 );

    return null;
  })

  .then( () =>
  {
    test.case = 'donwloaded repo has uncommitted change, error expected';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  a.appStartNonThrowing( 'git -C .module/ModuleForTesting2a reset --hard HEAD~1' )
  .then( () =>
  {
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2a/was.package.json' ), 'was.package.json' );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Module at module::submodulesDownloadErrorsGood / opener::ModuleForTesting2a needs to be updated, but has local changes' ) );
    test.true( _.strHas( op.output, 'Failed to agree module::submodulesDownloadErrorsGood / opener::ModuleForTesting2a' ) );
    return null;
  })

  //

  .then( () =>
  {
    test.case = 'donwloaded repo has unpushed change and wrong origin, error expected';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  a.appStartNonThrowing( 'git -C .module/ModuleForTesting2a reset --hard HEAD~1' )
  a.appStartNonThrowing( 'git -C .module/ModuleForTesting2a commit -m unpushed --allow-empty' )
  a.appStartNonThrowing( 'git -C .module/ModuleForTesting2a remote remove origin' )
  a.appStartNonThrowing( 'git -C .module/ModuleForTesting2a remote add origin https://github.com/Wandalen/wModuleForTesting1.git' )
  a.appStart({ execPath : '.with good .submodules.versions.agree' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'needs to be deleted, but has local changes' ) );
    test.true( _.strHas( op.output, 'Failed to agree module::submodulesDownloadErrorsGood / opener::ModuleForTesting2a' ) );
    return null;
  })

  /* - */

  return a.ready;
}

submodulesAgreeThrowing.rapidity = -1;
submodulesAgreeThrowing.timeOut = 300000;

//

function submodulesVersionsAgreeWrongOrigin( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadErrors' );
  a.appStartNonThrowing2 = _.process.starter
  ({
    currentPath : a.routinePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    ready : a.ready,
  });
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'donwloaded repo has different origin, should be deleted and downloaded again';
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.dirMake( a.abs( '.module/ModuleForTesting2a' ) );
    return null;
  })

  a.appStartNonThrowing2({ execPath : 'git clone https://github.com/Wandalen/wModuleForTesting1.git .module/ModuleForTesting2a' })
  a.appStartNonThrowing({ execPath : '.with good .submodules.versions.agree' })

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 1/1 submodule(s) of module::submodulesDownloadErrorsGood were agreed' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) )
    let files = a.find( a.abs( '.module/ModuleForTesting2a' ) );
    test.gt( files.length, 10 );

    return null;
  })

  /* - */

  return a.ready;
}

submodulesVersionsAgreeWrongOrigin.timeOut = 300000;

//

/*
  Informal module has submodule willbe-experiment!master
  Supermodule has informal module and willbe-experiment#dev in submodules list
  First download of submodules works fine.
  After updating submodules of supermodule, branch dev of willbe-experiment is changed to master.
  This is wrong, because willbe-experiment should stay on branch dev as its defined in willfile of supermodule.
*/

function submodulesDownloadedUpdate( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadedUpdate' );
  a.reflect();

  /* */

  a.ready.then( () =>
  {
    test.case = 'setup';
    return null;
  });

  a.appStart({ execPath : '.each module .export' });
  a.appStart({ execPath : '.submodules.download' });

  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, / \+ 1\/2 submodule\(s\) of .*module::submodules.* were downloaded in/ ) );
    return op;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'check module branch after download';
    return null;
  });

  a.shell({ currentPath : a.abs( '.module/ModuleForTesting1' ), execPath : 'git rev-parse --abbrev-ref HEAD' })
  .then( ( op ) =>
  {
    test.will = 'submodule of supermodule should stay on dev';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'dev1' ) );
    return op;
  });

  a.shell({ currentPath : a.abs( 'module/.module/ModuleForTesting1' ), execPath : 'git rev-parse --abbrev-ref HEAD' })
  .then( ( op ) =>
  {
    test.will = 'submodule of informal submodule should stay on master';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'master' ) );
    return op;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = 'update downloaded module and check branch';
    return op;
  });

  a.appStart({ execPath : '.submodules.update' })

  a.shell({ currentPath : a.abs( '.module/ModuleForTesting1' ), execPath : 'git rev-parse --abbrev-ref HEAD' })
  .then( ( op ) =>
  {
    test.will = 'submodule of supermodule should stay on dev';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'dev1' ) );
    return op;
  });

  a.shell({ currentPath : a.abs( 'module/.module/ModuleForTesting1' ), execPath : 'git rev-parse --abbrev-ref HEAD' })
  .then( ( op ) =>
  {
    test.will = 'submodule of informal submodule should stay on master';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'master' ) );
    return op;
  });

  return a.ready;
}

//

function subModulesUpdate( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesUpdate' );
  a.reflect();

  /* */

  a.ready.then( () =>
  {
    test.case = '.submodules.update';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ module::wModuleForTesting1 was updated to version 8e2aa80ca350f3c45215abafa07a4f2cd320342a in' ) );
    test.true( _.strHas( op.output, '+ module::wModuleForTesting2a was updated to version master in' ) );
    test.true( _.strHas( op.output, '+ module::wModuleForTesting12ab was updated to version c5c27157a6803d97b084002b8853b8fae0f62a08 in' ) );
    test.true( _.strHas( op.output, '+ 3/3 submodule(s) of module::submodules were updated in' ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.submodules.update -- twice';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.submodules.update' });
  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, /module::ModuleForTesting1/ ) );
    test.true( !_.strHas( op.output, /module::ModuleForTesting2a/ ) );
    test.true( !_.strHas( op.output, /module::ModuleForTesting12ab/ ) );
    test.true( _.strHas( op.output, '+ 0/3 submodule(s) of module::submodules were updated in' ) );
    return null;
  })

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( () =>
  {
    test.case = '.submodules.update -- after patch';
    var read = a.fileProvider.fileRead( a.abs( 'will.yml' ) );
    read = _.strReplace( read, '#8e2aa80ca350f3c45215abafa07a4f2cd320342a', '!master' )
    a.fileProvider.fileWrite( a.abs( 'will.yml' ), read );
    return null;
  });

  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, /module::ModuleForTesting2a/ ) );
    test.true( !_.strHas( op.output, /module::ModuleForTesting12ab/ ) );
    test.true( _.strHas( op.output, '+ 1/3 submodule(s) of module::submodules were updated in' ) );
    return null;
  });

  /* */

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( () =>
  {
    test.case = '.submodules.update -- after patch, twice';
    var read = a.fileProvider.fileRead( a.abs( 'will.yml' ) );
    read = _.strReplace( read, '#8e2aa80ca350f3c45215abafa07a4f2cd320342a', '!master' )
    a.fileProvider.fileWrite( a.abs( 'will.yml' ), read );
    return null;
  });

  a.appStart({ execPath : '.submodules.update' });
  a.appStart({ execPath : '.submodules.update' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, /module::ModuleForTesting1/ ) );
    test.true( !_.strHas( op.output, /module::ModuleForTesting2a/ ) );
    test.true( !_.strHas( op.output, /module::ModuleForTesting12ab/ ) );
    test.true( _.strHas( op.output, '+ 0/3 submodule(s) of module::submodules were updated in' ) );
    return null;
  });

  /* */

  return a.ready;
}

subModulesUpdate.timeOut = 300000;

//

function subModulesUpdateSwitchBranch( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesUpdateSwitchBranch' );
  let detachedVersion;

  /* */

  begin()

  .then( () =>
  {
    test.case = 'download master branch';
    return null;
  })

  a.appStart({ execPath : '.submodules.update' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'switch master to dev';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ]= _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '!master', '!dev' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    return null;
  })

  a.appStart({ execPath : '.submodules.update' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/dev' ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'switch dev to detached state';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '!dev', '#' + detachedVersion );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    return null;
  })

  a.appStart({ execPath : '.submodules.update' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, detachedVersion ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'switch detached state to master';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '#' + detachedVersion, '!master' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    return null;
  })

  a.appStart({ execPath : '.submodules.update' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  .then( () =>
  {
    test.case = 'master has local change, cause conflict when switch to dev';
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '!master', '!dev' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    let filePath = a.abs( '.module/willbe-experiment/File.js' );
    a.fileProvider.fileWrite({ filePath, data : 'master' });
    return null;
  })

  .then( () =>
  {
    let con = a.appStart({ execPath : '.submodules.update', ready : null });
    return test.shouldThrowErrorAsync( con );
  })

  _.process.start
  ({
    execPath : 'git status',
    currentPath : a.abs( '.module/willbe-experiment' ),
    ready : a.ready,
    outputCollecting : 1
  })

  .then( ( op ) =>
  {
    test.true( _.strHas( op.output, 'modified:   File.js' ) )

    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  /**/

  a.ready.then( () =>
  {
    test.case = 'master has new commit, changing branch to dev';
    return null;
  })

  begin()

  a.appStart({ execPath : '.submodules.update' })

  _.process.start
  ({
    execPath : 'git commit --allow-empty -m commitofmaster',
    currentPath : a.abs( '.module/willbe-experiment' ),
    ready : a.ready
  })
  .then( () =>
  {
    let willFile = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ), encoding : 'yml' });
    willFile.submodule[ 'willbe-experiment' ] = _.strReplaceAll( willFile.submodule[ 'willbe-experiment' ], '!master', '!dev' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data : willFile, encoding : 'yml' });
    return null;
  })

  a.appStart({ execPath : '.submodules.update' })

  .then( () =>
  {
    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/dev' ) );
    return null;
  })

  /**/

  a.ready.then( () =>
  {
    test.case = 'master and remote master have new commits';
    return null;
  })

  begin()

  a.appStart({ execPath : '.submodules.update' })

  _.process.start
  ({
    execPath : 'git commit --allow-empty -m emptycommit',
    currentPath : a.abs( '.module/willbe-experiment' ),
    ready : a.ready
  })

  // start2( 'git -C cloned checkout master' )
  // start2( 'git -C cloned commit --allow-empty -m test' )
  // start2( 'git -C cloned push' )
  a.shell( 'git -C cloned checkout master' )
  a.shell( 'git -C cloned commit --allow-empty -m test' )
  a.shell( 'git -C cloned push' )

  a.appStart({ execPath : '.submodules.update' })

  _.process.start
  ({
    execPath : 'git status',
    currentPath : a.abs( '.module/willbe-experiment' ),
    outputCollecting : 1,
    outputGraying : 1,
    ready : a.ready,
  })

  .then( ( op ) =>
  {
    test.true( _.strHas( op.output, `Your branch is ahead of 'origin/master' by 2 commits` ) );

    let currentVersion = a.fileProvider.fileRead( a.abs( '.module/willbe-experiment/.git/HEAD' ) );
    test.true( _.strHas( currentVersion, 'ref: refs/heads/master' ) );
    return null;
  })

  return a.ready;

  /* */

  function begin()
  {
    a.ready
    .then( () =>
    {
      test.case = 'setup repo';

      let con = _.take( null );
      a.reflect();

      a.fileProvider.dirMake( a.abs( 'experiment' ) );

      let start = _.process.starter
      ({
        currentPath : a.routinePath,
        outputCollecting : 1,
        ready : con,
      })

      start( 'git -C experiment init --bare' )
      start( 'git clone experiment cloned' )

      .then( () =>
      {
        return a.fileProvider.filesReflect({ reflectMap : { [ a.abs( 'src' ) ] : a.abs( 'cloned' ) } })
      })

      start( 'git -C cloned add -fA .' )
      start( 'git -C cloned commit -m init' )
      start( 'git -C cloned push' )
      start( 'git -C cloned checkout -b dev' )
      start( 'git -C cloned commit --allow-empty -m test' )
      start( 'git -C cloned commit --allow-empty -m test2' )
      start( 'git -C cloned push origin dev' )
      start( 'git -C cloned rev-parse HEAD~1' )

      .then( ( op ) =>
      {
        detachedVersion = _.strStrip( op.output );
        test.true( _.strDefined( detachedVersion ) );
        return null;
      })

      return con;
    })

    return a.ready;
  }

}

subModulesUpdateSwitchBranch.rapidity = -1;
subModulesUpdateSwitchBranch.timeOut = 300000;

//

function submodulesVerify( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandVersionsVerify' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    return null;
  });

  a.appStartNonThrowing( '.with ./module/ .export' );
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git add -fA .' });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git commit -m init' });

  /* */

  a.ready.then( () =>
  {
    test.case = 'verify not downloaded';
    return null;
  });

  a.appStartNonThrowing( '.submodules.versions.verify' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '! Submodule opener::local does not have files' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'first verify after download';
    return null;
  })

  a.appStartNonThrowing( '.submodules.download' )
  a.appStartNonThrowing( '.submodules.versions.verify' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1 / 1 submodule(s) of module::submodules / module::local were verified' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'second verify';
    return null;
  })

  a.appStartNonThrowing( '.submodules.versions.verify' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1 / 1 submodule(s) of module::submodules / module::local were verified' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'new commit on local copy, try to verify';
    return null;
  })

  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git commit --allow-empty -m test' })

  a.appStartNonThrowing( '.submodules.versions.verify' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1 / 1 submodule(s) of module::submodules / module::local were verified' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'change branch';
    return null;
  })

  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git checkout -b testbranch' })

  a.appStartNonThrowing( '.submodules.versions.verify' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'Submodule module::local has version different from that is specified in will-file' ) );
    return null;
  })

  return a.ready;
}

//

function submodulesVerifyOutdatedBranch( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesVerifyOutdatedBranch' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'another branch is up to date';
    a.reflectMinimal();
    return null;
  });
  a.appStart( '.submodules.download' );
  a.appStart( '.submodules.versions.verify' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /1 \/ 1 submodule\(s\) of module::.* were verified/ ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'another branch is not up to date';
    a.reflectMinimal();
    return null;
  });
  a.appStart( '.submodules.download' );
  a.shell( 'git -C .module/ModuleForTesting1 reset --hard HEAD~1' )
  a.appStartNonThrowing( '.submodules.versions.verify' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /! Submodule module::.* is not up to date!/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to verify' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to submodules versions verify at' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

submodulesVerifyOutdatedBranch.description =
`
Checks if command .submodules.versions.verify detects that current branch is outdated.
`


//

function submodulesVersionsAgree( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandVersionsAgree' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    return null;
  });

  a.appStartNonThrowing( '.with ./module/ .export' );
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git add -fA .' });
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git commit -m init' });

  /* */

  a.ready.then( () =>
  {
    test.case = 'agree not downloaded';
    return null;
  })

  a.appStartNonThrowing( '.submodules.versions.agree' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 1/1 submodule(s) of module::submodules were agreed in' ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'agree after download';
    return null;
  })

  a.appStart( '.submodules.versions.agree' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/1 submodule(s) of module::submodules were agreed in' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'local is up to date with remote but has local commit';
    return null;
  })

  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git commit --allow-empty -m test' })
  a.appStartNonThrowing( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ 0/1 submodule(s) of module::submodules were agreed in' ) );
    return null;
  })
  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git status' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Your branch is ahead of \'origin\/master\' by 1 commit/ ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'local is not up to date with remote but has local commit';
    return null;
  })

  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git commit --allow-empty -m test' });
  a.appStartNonThrowing( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'module::local was agreed with version master in' ) );
    test.true( _.strHas( op.output, '+ 1/1 submodule(s) of module::submodules were agreed in' ) );
    return null;
  })
  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git status' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `Your branch is ahead of 'origin/master' by 2 commits` ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'local is not up to date with remote, no local changes';
    return null;
  });

  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git reset --hard origin' })
  a.shell({ currentPath : a.abs( 'module' ), execPath : 'git commit --allow-empty -m test2' });
  a.appStartNonThrowing( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, '+ 1/1 submodule(s) of module::submodules were agreed in' ) );
    return null;
  });
  a.shell({ currentPath : a.abs( '.module/local' ), execPath : 'git status' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Your branch is up.*to.*date/ ) );
    return null;
  });

  /* - */

  return a.ready;
}

//

function submodulesVersionsAgreeNpm( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDownloadNpm' );
  let versions = {}
  let filesBefore = null;

  /* - */

  a.ready.then( () =>
  {
    versions[ 'ModuleForTesting1' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting1' );
    versions[ 'ModuleForTesting2a' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting2a!alpha' );
    versions[ 'ModuleForTesting12ab' ] = _.npm.remoteVersionCurrent( 'npm:///wmodulefortesting12ab#0.0.31' );

    a.reflectMinimal();

    return null;
  });

  /* */

  a.appStart( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.case = 'agree npm modules';

    test.identical( op.exitCode, 0 );

    var exp =
    [
      'ModuleForTesting1',
      'ModuleForTesting1.will.yml',
      'ModuleForTesting12ab',
      'ModuleForTesting12ab.will.yml',
      'ModuleForTesting2a',
      'ModuleForTesting2a.will.yml'
    ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) )
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 3 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, 'were agreed' ), 1 );
    test.identical( _.strCount( op.output, '+ 3/3 submodule(s) of module::supermodule were agreed' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was agreed with version ${versions[ 'ModuleForTesting1' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was agreed with version ${versions[ 'ModuleForTesting2a' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was agreed with version ${versions[ 'ModuleForTesting12ab' ]}` ), 1 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 2 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 1 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] );

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) );

    return null;
  });

  /*  */

  a.ready.then( ( op ) =>
  {
    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, '!alpha', '!beta' );
    willFile = _.strReplace( willFile, '!0.0.31', '!0.0.34' );
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );

    versions[ 'ModuleForTesting2a' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting2a!beta' );
    versions[ 'ModuleForTesting12ab' ] = '0.0.34';

    return null;
  });

  a.appStart( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.case = 'second run of .submodules.versions.agree';

    test.identical( op.exitCode, 0 );

    var exp =
    [
      'ModuleForTesting1',
      'ModuleForTesting1.will.yml',
      'ModuleForTesting12ab',
      'ModuleForTesting12ab.will.yml',
      'ModuleForTesting2a',
      'ModuleForTesting2a.will.yml'
    ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 11 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, '+ 2/3 submodule(s) of module::supermodule were agreed' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was agreed with version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was agreed with version ${versions[ 'ModuleForTesting2a' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was agreed with version ${versions[ 'ModuleForTesting12ab' ]}` ), 1 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 1 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] );

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) );

    return null;
  });

  /*  */

  a.appStart( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.case = 'third run of .submodules.versions.agree';

    test.identical( op.exitCode, 0 );

    var exp =
    [
      'ModuleForTesting1',
      'ModuleForTesting1.will.yml',
      'ModuleForTesting12ab',
      'ModuleForTesting12ab.will.yml',
      'ModuleForTesting2a',
      'ModuleForTesting2a.will.yml'
    ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, '+ 0/3 submodule(s) of module::supermodule were agreed' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was agreed with version ${versions[ 'ModuleForTesting1' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was agreed with version ${versions[ 'ModuleForTesting2a' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was agreed with version ${versions[ 'ModuleForTesting12ab' ]}` ), 0 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 0 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting1' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] );

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) );

    return null;
  });

  /*  */

  a.ready.then( () =>
  {
    test.case = 'change origin of first submodule and run .submodules.versions.agree';

    let willFile = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    willFile = _.strReplace( willFile, 'npm:///wmodulefortesting1\n', 'npm:///wmodulefortesting2b!gamma\n' );
    a.fileProvider.fileWrite( a.abs( '.will.yml' ), willFile );

    versions[ 'ModuleForTesting2b' ] = _.npm.remoteVersion( 'npm:///wmodulefortesting2b!gamma' );

    return null;
  });

  a.appStart( '.submodules.versions.agree' )
  .then( ( op ) =>
  {
    test.case = 'third run of .submodules.versions.agree';

    test.identical( op.exitCode, 0 );

    var exp =
    [
      'ModuleForTesting1',
      'ModuleForTesting1.will.yml',
      'ModuleForTesting12ab',
      'ModuleForTesting12ab.will.yml',
      'ModuleForTesting2a',
      'ModuleForTesting2a.will.yml'
    ];
    var files = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, '! Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 9 );
    test.identical( _.strCount( op.output, '+ Reflected' ), 0 );
    test.identical( _.strCount( op.output, '+ 1/3 submodule(s) of module::supermodule were agreed' ), 1 );

    test.identical( _.strCount( op.output, `module::ModuleForTesting1 was agreed with version ${versions[ 'ModuleForTesting2b' ]}` ), 1 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting2a was agreed with version ${versions[ 'ModuleForTesting2a' ]}` ), 0 );
    test.identical( _.strCount( op.output, `module::ModuleForTesting12ab was agreed with version ${versions[ 'ModuleForTesting12ab' ]}` ), 0 );

    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting1` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting2a` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::supermodule / module::ModuleForTesting12ab` ), 0 );

    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting1' ) );
    test.identical( version, versions[ 'ModuleForTesting2b' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting12ab' ) );
    test.identical( version, versions[ 'ModuleForTesting12ab' ] );
    var version = _.npm.localVersion( a.abs( '.module/ModuleForTesting2a' ) );
    test.identical( version, versions[ 'ModuleForTesting2a' ] );

    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1/ModuleForTesting1.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12ab/ModuleForTesting12ab.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a/ModuleForTesting2a.out.will.yml' ) ) );

    var exp =
    [
      '.',
      './node_modules',
      './node_modules/wmodulefortesting2b',
      './wtools',
      './wtools/testing',
      './wtools/testing/Common.s',
      './wtools/testing/l4',
      './wtools/testing/l4/testing2b',
      './wtools/testing/l4/testing2b/ModuleForTesting2b.s'
    ];
    var files = a.find( a.abs( '.module/ModuleForTesting1/proto' ) );
    test.identical( files, exp );

    return null;
  });

  /*  */

  return a.ready;
}

submodulesVersionsAgreeNpm.rapidity = -1;
submodulesVersionsAgreeNpm.timeOut = 600000;

//

function submodulesUpgradeDryDetached( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetached' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.submodules.upgrade dry:1 negative:1 -- after full update';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.export' });
  a.appStart({ execPath : '.submodules.upgrade dry:1 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    // test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* will be upgraded to version/ ), 1 );
    // test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* won't be upgraded/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    // test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12\.informal\.will\.yml.* will be upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be upgraded/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:1 negative:0 -- after full update';
    return null;
  })

  a.appStart({ execPath : '.submodules.upgrade dry:1 negative:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    // test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* will be upgraded to version/ ), 1 );
    // test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* won't be upgraded/ ), 0 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    // test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12\.informal\.will\.yml.* will be upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be upgraded/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:1 negative:1 -- after informal update';
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.each module .export' })
  a.appStart({ execPath : '.submodules.upgrade dry:1 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    // test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* will be upgraded to version/ ), 1 );
    // test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* won't be upgraded/ ), 0 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 0 );
    // test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12\.informal\.will\.yml.* will be upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be upgraded/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:1 negative:1 -- after formal update';
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.submodules.update' })
  a.appStart({ execPath : '.submodules.upgrade dry:1 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* will be upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 2 );

    // test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* will be upgraded to version/ ), 1 );
    // test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* won't be upgraded/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    // test.identical( _.strCount( op.output, /! .*upgradeDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* won't be upgraded/ ), 1 );
    // test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/\.im\.will\.yml.* will be upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be upgraded to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be upgraded/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12.* will be upgraded to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting12\.informal\.out\.will\.yml.* will be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting12\.informal\.will\.yml.* will be upgraded/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be upgraded to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be upgraded/ ), 0 );

    return null;
  })

  /* - */

  return a.ready;
}

submodulesUpgradeDryDetached.timeOut = 500000;

//

function submodulesUpgradeDetached( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetached' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:1 -- after full update';
    a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/Proto\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/Proto\.informal\.will\.yml.* was upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was upgraded/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:0 -- after full update';

    a.reflect();
    // a.fileProvider.filesDelete({ filePath : routinePath })
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/Proto\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/Proto\.informal\.will\.yml.* was upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was upgraded/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:1 -- after full update, second';
    return null;
  })

  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.im\.will\.yml.* was skipped/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.im\.will\.yml.* was skipped/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.im\.will\.yml.* was skipped/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was skipped/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:0 -- after full update, second';
    return null;
  })

  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths/ ), 0 );
    test.identical( _.strCount( op.output, /was upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /will be upgraded/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was skipped/ ), 0 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:1 -- after informal update';

    a.reflect();
    // a.fileProvider.filesDelete({ filePath : routinePath })
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.each module .export' })
  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/Proto\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/Proto\.informal\.will\.yml.* was upgraded/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was upgraded/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:1 -- after formal update';

    a.reflect();
    // a.fileProvider.filesDelete({ filePath : routinePath })
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.submodules.update' })
  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.* : .* <- .*\.#fb7c095a0fdbd6766b0d840ad914b5887c1500e7.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.* : .* <- .*\.#0.3.115.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was upgraded to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was upgraded/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was upgraded to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.* : .* <- .*\.#2da1d0de20bd23f6f32c11bda090569edd90da55.*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/Proto\.informal\.out\.will\.yml.* was upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/Proto\.informal\.will\.yml.* was upgraded/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was upgraded to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was upgraded/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was upgraded/ ), 0 );

    return null;
  })

  /* - */

  return a.ready;
}

submodulesUpgradeDetached.timeOut = 500000;

//

function submodulesUpgradeDetachedExperiment( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetachedSingle' );

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.upgrade dry:0 negative:1 -- after download';
    a.reflect();
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })
    return null;
  })

  a.appStart({ execPath : '.submodules.download' })
  a.appStart({ execPath : '.submodules.upgrade dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was upgraded to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /! .*upgradeDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not upgraded/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*upgradeDetached\/\.im\.will\.yml.* was upgraded/ ), 1 );

    return null;
  })

  return a.ready;
}

submodulesUpgradeDetachedExperiment.experimental = 1;

//

function submodulesFixateDryDetached( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetached' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.submodules.fixate dry:1 negative:1 -- after full update';
    return null;
  });

  a.appStart({ execPath : '.clean' });
  a.appStart({ execPath : '.export' });
  a.appStart({ execPath : '.submodules.fixate dry:1 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/\.im\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/out\/Proto\.informal\.out\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/module\/Proto\.informal\.will\.yml.* will be skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be fixated/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:1 negative:0 -- after full update';
    return null;
  })

  a.appStart({ execPath : '.submodules.fixate dry:1 negative:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/\.im\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/out\/Proto\.informal\.out\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/module\/Proto\.informal\.will\.yml.* will be skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be fixated/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:1 negative:1 -- after informal update';
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.each module .export' })
  a.appStart({ execPath : '.submodules.fixate dry:1 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/\.im\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/out\/Proto\.informal\.out\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/module\/Proto\.informal\.will\.yml.* will be skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be fixated/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:1 negative:1 -- after formal update';
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.submodules.update' })
  a.appStart({ execPath : '.submodules.fixate dry:1 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* will be fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/\.im\.will\.yml.* will be fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* won't be fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* will be skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/\.im\.will\.yml.* will be skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* will be fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* will be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* will be fixated/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* won't be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/out\/Proto\.informal\.out\.will\.yml.* will be skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDryDetached\/module\/Proto\.informal\.will\.yml.* will be skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* will be fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* will be fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDryDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* will be fixated/ ), 0 );

    return null;
  })

  /* - */

  return a.ready;
}

submodulesFixateDryDetached.timeOut = 500000;

//

function submodulesFixateDetached( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesDetached' );

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:0 negative:1 -- after full update';
    a.reflect();
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  a.appStart({ execPath : '.submodules.fixate dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/\.im\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was fixated/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:0 negative:0 -- after full update';

    a.reflect();
    // a.fileProvider.filesDelete({ filePath : routinePath })
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.export' })
  a.appStart({ execPath : '.submodules.fixate dry:0 negative:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/\.im\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was fixated/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:0 negative:1 -- after full update, second';
    return null;
  })

  a.appStart({ execPath : '.submodules.fixate dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 3 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was skipped/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:0 negative:0 -- after full update, second';
    return null;
  })

  a.appStart({ execPath : '.submodules.fixate dry:0 negative:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths/ ), 0 );
    test.identical( _.strCount( op.output, /was fixated/ ), 0 );
    test.identical( _.strCount( op.output, /will be fixated/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/\.im\.will\.yml.* was fixated/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was fixated/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was fixated/ ), 0 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:0 negative:1 -- after informal update';

    a.reflect();
    // a.fileProvider.filesDelete({ filePath : routinePath })
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.each module .export' })
  a.appStart({ execPath : '.submodules.fixate dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/\.im\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was fixated/ ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.submodules.fixate dry:0 negative:1 -- after formal update';

    a.reflect();
    // a.fileProvider.filesDelete({ filePath : routinePath })
    // a.fileProvider.filesReflect({ reflectMap : { [ originalAssetPath ] : routinePath } })

    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.submodules.update' })
  a.appStart({ execPath : '.submodules.fixate dry:0 negative:1' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1.* was fixated to version/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting1\.git\/out\/wModuleForTesting1\.out\.will.* : .* <- .*\.!master.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/out\/wModuleForTesting1\.out\.will\.yml.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1\/\.im\.will\.yml.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/\.im\.will\.yml.* was fixated/ ), 1 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting2a\.git\/out\/wModuleForTesting2a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/out\/wModuleForTesting2a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting2a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting1a.* was not fixated/ ), 1 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will.*/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/out\/wModuleForTesting1a\.out\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.module\/ModuleForTesting1a\/\.im\.will\.yml.* was skipped/ ), 1 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/\.im\.will\.yml.* was skipped/ ), 2 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting12ab.* was fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wModuleForTesting12ab\.git.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting12ab\.informal\.out\.will\.yml.* was fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting12ab\.informal\.will\.yml.* was fixated/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::Proto.* was not fixated/ ), 0 );
    test.identical( _.strCount( op.output, /.*git\+https:\/\/\/github\.com\/Wandalen\/wProto\.git.*/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/out\/Proto\.informal\.out\.will\.yml.* was skipped/ ), 0 );
    test.identical( _.strCount( op.output, /! .*fixateDetached\/module\/Proto\.informal\.will\.yml.* was skipped/ ), 0 );

    test.identical( _.strCount( op.output, /Remote paths of .*module::submodulesDetached \/ relation::ModuleForTesting2b.* was fixated to version/ ), 0 );
    test.identical( _.strCount( op.output, /.*npm:\/\/\/wprocedure.* : .* <- .*\..*/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/out\/ModuleForTesting2b\.informal\.out\.will\.yml.* was fixated/ ), 0 );
    test.identical( _.strCount( op.output, /\+ .*fixateDetached\/module\/ModuleForTesting2b\.informal\.will\.yml.* was fixated/ ), 0 );

    return null;
  })

  /* - */

  return a.ready;
}

submodulesFixateDetached.timeOut = 500000;

//

function stepSubmodulesDownload( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepSubmodulesDownload' );
  a.reflect();

  /* - */

  a.appStart({ execPath : '.resources.list' })
  .then( ( op ) =>
  {
    test.case = 'list'
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, `git+https:///github.com/Wandalen/wModuleForTesting1.git/out/wModuleForTesting1.out.will!master` ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'build'
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    return null;
  });

  a.appStart({ execPath : '.build' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.gt( a.find( a.abs( '.module/ModuleForTesting1' ) ).length, 8 );
    test.gt( a.find( a.abs( 'out/debug' ) ).length, 8 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'export'
    a.fileProvider.filesDelete( a.abs( '.module' ) );
    a.fileProvider.filesDelete( a.abs( 'out/debug' ) );
    a.fileProvider.filesDelete( a.abs( 'out/Download.out.will.yml' ) );
    return null;
  });

  a.appStart({ execPath : '.export' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.gt( a.find( a.abs( '.module/ModuleForTesting1' ) ).length, 8 );
    test.gt( a.find( a.abs( 'out/debug' ) ).length, 8 );
    test.true( a.fileProvider.isTerminal( a.abs( 'out/Download.out.will.yml' ) ) );
    return null;
  });

  /* - */

  return a.ready;
}

stepSubmodulesDownload.timeOut = 300000;

//

function stepSubmodulesUpdate( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepSubmodulesUpdate' );

  a.remotePath = a.abs( 'module' );
  a.appStart.predefined.currentPath = a.abs( 'clone' );
  a.appStartNonThrowing.predefined.currentPath = a.abs( 'clone' );

  a.shellSync = _.process.starter
  ({
    currentPath : a.abs( '.' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  a.shellSyncClone = _.process.starter
  ({
    currentPath : a.abs( 'clone' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  a.shellSyncSubmodule = _.process.starter
  ({
    currentPath : a.abs( 'clone/.module/ModuleForTesting2' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  a.moduleShellSync = _.process.starter
  ({
    currentPath : a.remotePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  /* */

  init({ case : 'defaults, downloads submodule', predownloadSubmodules : 0 })
  a.appStart( '.build default' )
  .then( ( op ) =>
  {
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'defaults, no changes', predownloadSubmodules : 1 })
  a.appStart( '.build default' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'to:master', predownloadSubmodules : 0 })
  a.appStart( `.build to.!master` )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were downloaded/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'to:master', predownloadSubmodules : 1 })
  a.appStart( `.build to.!gamma` )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    return null;
  });

  /* */

  init({ case : 'dry run, reports that submodule will be updated', predownloadSubmodules : 0 })
  a.appStart( '.build dry.clean' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* will be updated/ ), 1 )
    test.false( a.fileProvider.fileExists( a.abs( 'clone/.module' ) ) );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'dry run, reports that submodule will not be updated', predownloadSubmodules : 1 })
  a.appStart( '.build dry' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* will be updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'recursive:0, should not download any submodule', predownloadSubmodules : 0 })
  a.appStart( '.build recursive.off' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/0 submodule\(s\) of .* were updated/ ), 1 )
    test.false( a.fileProvider.fileExists( a.abs( 'clone/.module' ) ) );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'recursive:1, should download only own submodules', predownloadSubmodules : 0 })
  a.appStart( '.build recursive.one' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'recursive:2, should download all submodules', predownloadSubmodules : 0, prepareRemoteModule : 1 });
  a.appStart( '.build recursive.two' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 2\/2 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2', 'wModuleForTesting1' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'loggingNoChanges:1', predownloadSubmodules : 1 })
  a.appStart( '.build loggingNoChanges.on' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'loggingNoChanges:0', predownloadSubmodules : 1 })
  a.appStart( '.build loggingNoChanges.off' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* were updated/ ), 0 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'withStem:1', predownloadSubmodules : 1 })
  a.appStart( '.build withStem.on' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'withStem:0', predownloadSubmodules : 1 })
  a.appStart( '.build withStem.off' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 )
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function init( o )
  {
    o = o || {};

    a.ready.then( () =>
    {
      test.case = _.entity.exportString( o );

      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();

      /* init main module */

      a.moduleShellSync( 'git init' )
      a.fileProvider.fileWrite({ filePath : a.abs( 'module/.gitignore' ), data : '.module' });
      a.moduleShellSync( 'git add -fA .' )
      a.moduleShellSync( 'git commit -m initial' )
      a.moduleShellSync( 'git tag gamma' )

      /* clone main module to simulate clone from the remote */

      a.shellSync( 'git clone module clone' )

      if( o.rootLocalChange )
      a.fileProvider.fileWrite({ filePath : a.abs( 'clone/file' ), data : 'file' });

      return null;
    });

    if( o.predownloadSubmodules )
    {
      a.appStart( '.submodules.download' );

      if( o.submoduleLocalChange )
      a.ready.then( () =>
      {
        a.fileProvider.fileWrite
        ({
           filePath : a.abs( 'clone/.module/ModuleForTesting2/file' ),
           data : 'file'
        });
        return null;
      });
    }

    if( o.prepareRemoteModule )
    {
      const modulePath = a.abs( '../-repo/ModuleForTesting2/' );
      a.shell({ currentPath : modulePath, execPath : 'git checkout master' });
      a.ready.then( () =>
      {
        const configPath = a.abs( modulePath, 'will.yml' );
        const config = a.fileProvider.fileReadUnknown( configPath );
        config.submodule.wModuleForTesting1.enabled = 1;
        a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
        return null;
      });
      a.shell({ currentPath : modulePath, execPath : 'git add .' });
      a.shell({ currentPath : modulePath, execPath : 'git commit -am enabled' });
    }

    return a.ready;
  }
}

stepSubmodulesUpdate.timeOut = 800000;

//

function stepModulesUpdate( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepModulesUpdate' );

  a.remotePath = a.abs( 'module' );
  a.appStart.predefined.currentPath = a.abs( 'clone' );
  a.appStartNonThrowing.predefined.currentPath = a.abs( 'clone' );

  a.shellSync = _.process.starter
  ({
    currentPath : a.abs( '.' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  a.shellSyncClone = _.process.starter
  ({
    currentPath : a.abs( 'clone' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  a.shellSyncSubmodule = _.process.starter
  ({
    currentPath : a.abs( 'clone/.module/ModuleForTesting2' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  a.moduleShellSync = _.process.starter
  ({
    currentPath : a.remotePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  /* */

  init({ case : 'defaults, downloads submodule', predownloadSubmodules : 0 });
  a.appStart( '.build default' )
  .then( ( op ) =>
  {
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'defaults, no changes', predownloadSubmodules : 1 });
  a.appStart( '.build default' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'to:master', predownloadSubmodules : 0 });
  a.appStart( `.build to.!master` )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were downloaded/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'to:master', predownloadSubmodules : 1 });
  a.appStart( `.build to.!gamma` )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    return null;
  });

  /* */

  init({ case : 'dry run, reports that submodule will be updated', predownloadSubmodules : 0 });
  a.appStart( '.build dry.clean' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* will be updated/ ), 1 );
    test.false( a.fileProvider.fileExists( a.abs( 'clone/.module' ) ) );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'dry run, reports that submodule will not be updated', predownloadSubmodules : 1 });
  a.appStart( '.build dry' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* will be updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'recursive:0, should not download any submodule', predownloadSubmodules : 0 });
  a.appStart( '.build recursive.off' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/0 submodule\(s\) of .* were updated/ ), 1 );
    test.false( a.fileProvider.fileExists( a.abs( 'clone/.module' ) ) );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  });

  /* */

  init({ case : 'recursive:1, should download only own submodules', predownloadSubmodules : 0 });
  a.appStart( '.build recursive.one' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'recursive:2, should download all submodules', predownloadSubmodules : 0, prepareRemoteModule : 1 });
  a.appStart( '.build recursive.two' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 2\/2 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2', 'wModuleForTesting1' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  })

  /* */

  init({ case : 'loggingNoChanges:1', predownloadSubmodules : 1 });
  a.appStart( '.build loggingNoChanges.on' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'loggingNoChanges:0', predownloadSubmodules : 1 });
  a.appStart( '.build loggingNoChanges.off' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 0\/1 submodule\(s\) of .* were updated/ ), 0 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'withStem:1', predownloadSubmodules : 1 });
  a.appStart( '.build withStem.on' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* */

  init({ case : 'withStem:0', predownloadSubmodules : 1 });
  a.appStart( '.build withStem.off' )
  .then( ( op ) =>
  {
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated/ ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function init( o )
  {
    o = o || {};

    a.ready.then( () =>
    {
      test.case = _.entity.exportString( o );

      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();

      /* init main module */

      a.moduleShellSync( 'git init' )
      a.fileProvider.fileWrite({ filePath : a.abs( 'module/.gitignore' ), data : '.module' });
      a.moduleShellSync( 'git add -fA .' )
      a.moduleShellSync( 'git commit -m initial' )
      a.moduleShellSync( 'git tag gamma' )

      /* clone main module to simulate clone from the remote */

      a.shellSync( 'git clone module clone' )

      if( o.rootLocalChange )
      a.fileProvider.fileWrite({ filePath : a.abs( 'clone/file' ), data : 'file' });

      return null;
    });

    if( o.predownloadSubmodules )
    {
      a.appStart( '.submodules.download' );

      if( o.submoduleLocalChange )
      a.ready.then( () =>
      {
        a.fileProvider.fileWrite
        ({
           filePath : a.abs( 'clone/.module/ModuleForTesting2/file' ),
           data : 'file'
        });
        return null;
      });
    }

    if( o.prepareRemoteModule )
    {
      const modulePath = a.abs( '../-repo/ModuleForTesting2/' );
      a.shell({ currentPath : modulePath, execPath : 'git checkout master' });
      a.ready.then( () =>
      {
        const configPath = a.abs( modulePath, 'will.yml' );
        const config = a.fileProvider.fileReadUnknown( configPath );
        config.submodule.wModuleForTesting1.enabled = 1;
        a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
        return null;
      });
      a.shell({ currentPath : modulePath, execPath : 'git add .' });
      a.shell({ currentPath : modulePath, execPath : 'git commit -am enabled' });
    }

    return a.ready;
  }
}

stepModulesUpdate.timeOut = 800000;
stepModulesUpdate.rapidity = -1;

//

function stepWillbeVersionCheck( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepWillbeVersionCheck' );

  begin();

  /* starter for local copy of utility */
  a.appStart = _.process.starter
  ({
    execPath : `node ${ a.path.nativize( a.abs( 'proto/wtools/atop/will/entry/Exec' ) ) }`,
    currentPath : a.abs( '.' ),
    outputCollecting : 1,
    throwingExitCode : 0,
    verbosity : 3,
    ready : a.ready,
  });

  /* - */

  a.appStart( '.build' )
  .then( ( op ) =>
  {
    test.case = 'utiliti is up to data';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Current version: \d+\.\d+\.\d+\. Utility willbe is up to date\./ ), 1 );
    test.identical( _.strCount( op.output, /Built .+ \/ build::debug/ ), 1 );
    return null;
  });

  /* */

  a.ready.then( ( ) =>
  {
    let packageJsonPath = a.abs( 'package.json' );
    let packageJson = a.fileProvider.fileRead({ filePath : packageJsonPath, encoding : 'json' });
    packageJson.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : packageJsonPath, encoding : 'json', data : packageJson });
    return null;
  });

  a.appStart( '.build' )
  .then( ( op ) =>
  {
    test.case = 'utility is out of date';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Utility willbe is out of date!' ), 1 );
    test.identical( _.strCount( op.output, 'Current version: 0.0.0' ), 1 );
    test.identical( _.strCount( op.output, /Latest: \d+\.\d+\.\d+/ ), 1 );
    test.identical( _.strCount( op.output, 'Please run: "npm r -g willbe && npm i -g willbe" to update.' ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( '.' ) ); return null });
    a.shell( 'git clone https://github.com/Wandalen/willbe.git ./' );
    a.shell( 'npm i' );
    a.ready.then( () =>
    {
      const willPath = a.abs( 'will.yml' );
      const assetWillPath = a.abs( context.assetsOriginalPath, 'stepWillbeVersionCheck/will.yml' );
      a.fileProvider.filesDelete( a.abs( 'out' ) );
      a.fileProvider.filesReflect({ reflectMap : { [ assetWillPath ] : willPath } });
      return null;
    });
    return a.ready;
  }
}

//

function stepVersionBump( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'initial check';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );

    return null;
  });

  a.appStart({ args : '.with Version .build bump' })
  .then( ( op ) =>
  {
    test.case = '".build bump", bump with defaults';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.number' })
  .then( ( op ) =>
  {
    test.case = '".build bump.number", bump with number delta';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.string' })
  .then( ( op ) =>
  {
    test.case = '".build bump.string", bump with string delta, full form';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.string.partial' })
  .then( ( op ) =>
  {
    test.case = '".build bump.string.partial", bump with string delta, not full form';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.patch' })
  .then( ( op ) =>
  {
    test.case = '".build bump.patch", bump string patch version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.minor' })
  .then( ( op ) =>
  {
    test.case = '".build bump.minor", bump string minor version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.major' })
  .then( ( op ) =>
  {
    test.case = '".build bump.major", bump string major version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.0.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.with.criterion.patch' })
  .then( ( op ) =>
  {
    test.case = '".build bump.with.criterion.patch", bump with resolved string criterion';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.with.criterion* bump:minor' })
  .then( ( op ) =>
  {
    test.case = '".build bump.with.criterion* bump:minor", bump with resolved string criterion';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.with.criterion* bump:major' })
  .then( ( op ) =>
  {
    test.case = '".build bump.with.criterion* bump:major", bump with resolved string criterion';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.0.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .build bump.check.module' })
  .then( ( op ) =>
  {
    test.case = '".build bump.check.module", check that module has same version as new willfile';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );
    test.identical( _.strCount( op.output, '> echo 0.0.1' ), 1 );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'willfile has not version';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    delete config.about.version;
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });
    return null;
  });

  a.appStartNonThrowing({ args : '.with Version .build bump' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, undefined );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'willfile has version as number';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    config.about.version = 1.1;
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });
    return null;
  });

  a.appStartNonThrowing({ args : '.with Version .build bump' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, 1.1 );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.with Version .build bump.throwing.notInt' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );
    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.with Version .build bump.throwing.negative' })
  .then( ( op ) =>
  {
    test.case = 'bump with negative number';
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );
    return null;
  });

  /* - */

  return a.ready;
}

//

function stepVersionBumpCheckReset( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'initial check';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });
    return null;
  });

  a.appStart({ args : '.imply withDisabledSubmodules:0 .with Version .build bump.with.criterion* bump:major' })
  .then( ( op ) =>
  {
    test.case = 'bump major version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '2.0.0' );

    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* */

  a.appStart({ args : '.with Version .build bump.string' })
  .then( ( op ) =>
  {
    test.case = 'bump minor version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.3.0' );

    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* */

  a.appStart({ args : '.with Version .build bump' })
  .then( ( op ) =>
  {
    test.case = 'bump patch version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.2.4' );

    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* - */

  return a.ready;
}

//

function stepSubmodulesAreUpdated( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepSubmodulesAreUpdated' );
  a.appStart2 = _.process.starter
  ({
    currentPath : a.abs( 'module' ),
    outputCollecting : 1,
    outputGraying : 1,
    ready : a.ready,
  })
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'setup';
    return null;
  })

  a.appStartNonThrowing( '.with ./module/ .export' )
  a.appStart2( 'git init' )
  a.appStart2( 'git add -fA .' )
  a.appStart2( 'git commit -m init' )
  a.appStart2( 'git commit --allow-empty -m test' )

  /* */

  .then( () =>
  {
    test.case = 'first build';
    return null;
  })

  a.appStartNonThrowing( '.build' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodules were downloaded in' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'second build';
    return null;
  })

  a.appStartNonThrowing( '.build' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules were downloaded in' ) );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'new commit on remote, try to build';
    return null;
  })

  a.appStart2( 'git commit --allow-empty -m test' )

  a.appStartNonThrowing( '.build' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules were downloaded in' ) );
    test.true( _.strHas( op.output, '! Submodule module::local is not up to date' ) );
    // test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'module is not downloaded';
    return null;
  })

  a.appStartNonThrowing( '.build debug2' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    // test.true( _.strHas( op.output, '! Submodule module::local does not have files' ) );
    test.true( _.strHas( op.output, '! Submodule opener::local does not have files' ) );
    // test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'download path does not contain git repo';
    return null;
  })

  a.appStartNonThrowing( '.build debug3' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    // test.true( _.strHas( op.output, '! Submodule module::local does not have files' ) );
    test.true( _.strHas( op.output, '! Submodule opener::local does not have files' ) );
    // test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /*  */

  .then( () =>
  {
    test.case = 'module is downloaded from different origin';
    return null;
  })

  a.appStartNonThrowing( '.build debug4' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    // test.true( _.strHas( op.output, '! Submodule module::local has different origin url' ) );
    test.true( _.strHas( op.output, '! Submodule opener::local has different origin url' ) );
    // test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /*  */

  .then( () =>
  {
    test.case = 'module is in detached state';
    return null;
  })

  a.appStartNonThrowing( '.build debug5' )

  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '! Submodule module::local is not up to date' ) );
    // test.true( _.strHas( op.output, '0/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /*  */

  .then( () =>
  {
    test.case = 'module is ahead remote';
    return null;
  })

  a.appStartNonThrowing( '.build debug6' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  /* */

  .then( () =>
  {
    test.case = 'new commit on remote, check is disabled via option';
    return null;
  })

  a.appStartNonThrowing( '.clean .submodules.download' )
  a.appStartNonThrowing( '.submodules.download' )
  a.appStart2( 'git commit --allow-empty -m test' )
  a.appStartNonThrowing( '.build debug7' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '1/1 submodule(s) of module::submodules are up to date' ) );
    return null;
  })

  return a.ready;
}

stepSubmodulesAreUpdated.timeOut = 300000;

//

function stepBuild( test )
{
  let context = this;
  let a = context.assetFor( test );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with basic .build build1';
    return null;
  })

  a.appStart( '.with basic .build build1' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo step1' ), 1 );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with basic .build step1';
    return null;
  })

  a.appStartNonThrowing( '.with basic .build step1' )

  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo step1' ), 0 );
    test.identical( _.strCount( op.output, 'echo' ), 0 );
    test.identical( _.strCount( op.output, 'Please specify exactly one build scenario, none satisfies passed arguments' ), 1 );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with basic .build step2';
    return null;
  })

  a.appStart( '.with basic .build step2' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo step2' ), 1 );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with basic .build step3a';
    return null;
  })

  a.appStart( '.with basic .build step3a' )

  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo step3' ), 1 );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with basic .build step3';
    return null;
  })

  a.appStartNonThrowing( '.with basic .build step3' )

  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo step3' ), 0 );
    test.identical( _.strCount( op.output, 'echo' ), 0 );
    test.identical( _.strCount( op.output, 'Please specify exactly one build scenario, none satisfies passed arguments' ), 1 );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with bad1 .resources.list';
    return null;
  })

  a.appStartNonThrowing( '.with bad1 .resources.list' )

  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'echo' ), 0 );
    test.identical( _.strCount( op.output, 'Instance build::step2 already exists' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to make resource build::step2' ), 1 );
    return op;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = '.with bad2 .resources.list';
    return null;
  })

  a.appStartNonThrowing( '.with bad2 .resources.list' )

  .then( ( op ) =>
  {
    test.nil( op.exitCode, 0 );
    logger.log( 'op.exitCode', op.exitCode );
    test.identical( _.strCount( op.output, 'echo' ), 0 );
    test.identical( _.strCount( op.output, 'Instance build::step3 already exists' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to make resource build::step3' ), 1 );
    return op;
  });

  /* - */

  return a.ready;
}

//

function stepShellWithPathResolving( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepShellResolvePath' );
  a.reflect();
  a.appStart( '.submodules.download' );

  /* - */

  a.appStart({ execPath : '.build module.dir.explicit' })
  .then( ( op ) =>
  {
    test.case = 'run script from another directory';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Building module::stepShellWithPathResolving / build::module.dir.explicit' ), 1 );
    test.identical( _.strCount( op.output, '> node Sample.s' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepShellWithPathResolving / build::module.dir.explicit' ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.build module.dir.resolve.from.path' })
  .then( ( op ) =>
  {
    test.case = 'run script from another directory';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Building module::stepShellWithPathResolving / build::module.dir.resolve.from.path' ), 1 );
    test.identical( _.strCount( op.output, '> node Sample.s' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepShellWithPathResolving / build::module.dir.resolve.from.path' ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.build module.dir.resolve.and.join' })
  .then( ( op ) =>
  {
    test.case = 'run script from another directory';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Building module::stepShellWithPathResolving / build::module.dir.resolve.and.join' ), 1 );
    test.identical( _.strCount( op.output, '> node Sample.s' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepShellWithPathResolving / build::module.dir.resolve.and.join' ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.build module.dir.resolve.with.criterion' })
  .then( ( op ) =>
  {
    test.case = 'run script from another directory';
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'Building module::stepShellWithPathResolving / build::module.dir.resolve.with.criterion' ), 1 );
    test.identical( _.strCount( op.output, '> node Sample.s' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'The sum of 1 and 2 is : 3' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepShellWithPathResolving / build::module.dir.resolve.with.criterion' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function stepShellWithSeveralCommands( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepShellSeveralCommands' );
  a.reflectMinimal();

  /* - */

  a.appStart({ execPath : '.build echo.simple' })
  .then( ( op ) =>
  {
    test.case = 'three different list commands';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo' ), 3 );
    test.identical( _.strCount( op.output, '> echo \'one\'' ), 1 );
    test.identical( _.strCount( op.output, '> echo \'two\'' ), 1 );
    test.identical( _.strCount( op.output, '> echo \'three\'' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::shellSeveralCommands / build::echo.simple in' ), 1 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.build echo.resolved' })
  .then( ( op ) =>
  {
    test.case = 'three different list commands';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo' ), 3 );
    test.identical( _.strCount( op.output, '> echo \'in : .\'' ), 1 );
    test.identical( _.strCount( op.output, '> echo \'out : .\'' ), 1 );
    test.identical( _.strCount( op.output, /> echo \'will : .*\'/ ), 1 );
    test.identical( _.strCount( op.output, 'Built module::shellSeveralCommands / build::echo.resolved in' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function stepSourcesJoin( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepSourcesJoin' );
  a.reflectMinimal();

  /* - */

  a.appStart( '.build' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoin / build::join.default' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.default' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.default in' ), 1 );
    return null;
  });
  a.shell( 'node Sample.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp = 'The sum of sum, multiplication, squares, square roots and dividing of 4 and 4 is';
    test.identical( _.strCount( op.output, exp ), 1 );
    return null;
  });

  /* */

  a.appStart( '.build join.with.in.path' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoin / build::join.with.in.path' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.with.in.path' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.with.in.path in' ), 1 );
    return null;
  });
  a.shell( 'node Sample.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp = 'The sum of sum, multiplication, squares, square roots and dividing of 4 and 4 is';
    test.identical( _.strCount( op.output, exp ), 1 );
    return null;
  });

  /* */

  a.appStart( '.build join.with.base.path' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoin / build::join.with.base.path' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.with.base.path' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.with.base.path in' ), 1 );
    return null;
  });
  a.shell( 'node Sample.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp = 'The sum of sum, multiplication, squares, square roots and dividing of 4 and 4 is';
    test.identical( _.strCount( op.output, exp ), 1 );
    return null;
  });

  /* */

  a.appStart( '.build join.without.modules.list' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoin / build::join.without.modules.list' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.without.modules.list' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.without.modules.list in' ), 1 );
    return null;
  });
  a.shell( 'node Sample.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp = 'The sum of sum, multiplication, squares, square roots and dividing of 4 and 4 is';
    test.identical( _.strCount( op.output, exp ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function stepSourcesJoinRunInBrowser( test )
{
  let context = this;

  if( Config.interpreter === 'njs' )
  if( _.str.begins( process.versions.node, '10' ) )
  return test.true( true );

  /* */

  let a = context.assetFor( test, 'stepSourcesJoin' );
  a.reflectMinimal();

  /* - */

  a.appStart( '.build join.module.for.browser' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoin / build::join.module.for.browser' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.module.for.browser' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoin / build::join.module.for.browser in' ), 1 );
    return null;
  });
  a.shell( 'npm i jsdom@17.0.0' );
  a.shell( 'node Browser.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp = 'The sum of sum, multiplication, squares, square roots and dividing of 4 and 4 is';
    test.identical( _.strCount( op.output, exp ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function stepSourcesJoinRunWithExts( test )
{
  let context = this;

  if( Config.interpreter === 'njs' )
  if( _.str.begins( process.versions.node, '10' ) )
  return test.true( true );

  /* */

  let a = context.assetFor( test, 'stepSourcesJoinWithExts' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'run sample that use only include files';
    return null;
  });

  a.shell( 'node Sample.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'The sum of 4 and 4 is : 8' ), 1 );
    test.identical( _.strCount( op.output, 'The multiplication of 4 and 4 is : 16' ), 1 );
    test.identical( _.strCount( op.output, 'The division of 4 and 4 is : 1' ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'run compiled file for njs, should not compile file with ext `js`';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });
  a.appStart( '.build module.sources.join.njs' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoinWithExts / build::module.sources.join.njs' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoinWithExts / build::module.sources.join.njs' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoinWithExts / build::module.sources.join.njs in' ), 1 );
    return null;
  });
  a.shellNonThrowing( 'node NjsSample.s' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'The sum of 4 and 4 is : 8' ), 0 );
    test.identical( _.strCount( op.output, 'The multiplication of 4 and 4 is : 16' ), 0 );
    test.identical( _.strCount( op.output, 'The division of 4 and 4 is : 1' ), 0 );
    test.identical( _.strCount( op.output, /rror: Cannot find module.*Test\.js/ ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'run compiled file for browser, should not compile file with ext `ss`';
    a.fileProvider.filesDelete( a.abs( 'out' ) );
    return null;
  });
  a.appStart( '.build module.sources.join.browser' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::stepSourcesJoinWithExts / build::module.sources.join.browser' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoinWithExts / build::module.sources.join.browser' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepSourcesJoinWithExts / build::module.sources.join.browser in' ), 1 );
    return null;
  });
  a.shell( 'npm i jsdom@17.0.0' );
  a.shellNonThrowing( 'node Browser.s' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'The sum of 4 and 4 is : 8' ), 0 );
    test.identical( _.strCount( op.output, 'The multiplication of 4 and 4 is : 16' ), 0 );
    test.identical( _.strCount( op.output, 'The division of 4 and 4 is : 1' ), 0 );
    test.ge( _.strCount( op.output, /Failed to resolve path:.*Test\.ss, file doesn\'t exist/ ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function stepNpmGenerate( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepNpmGenerate' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.with Author .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `author`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.author, 'Author <author@dot.com>' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Contributors .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `contributors`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.contributors, [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ] );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Description .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `description`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.description, 'To check the conversion' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Enabled .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `enabled`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.name, undefined );
    test.identical( config.enabled, 0 );

    return null;
  })

  /* */

  a.appStart({ args : '.with Interpreters .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `interpreters`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.interpreters, undefined );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Keywords .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `keywords`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.keywords, [ 'tools', 'export' ] );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with License .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `license`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.license, 'MIT' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with Name .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `name`, name of willfile';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.name, 'NpmFromWillfile' );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with NpmName .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `name`, npm name';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.name, 'npmfromwillfile' );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with NpmScripts .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `scripts`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.scripts, { 'test' : 'wtest .run proto/**', 'docgen' : 'wdocgen .build proto' } );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `main`, should not read path';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.main, 'proto' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathRepository .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check fields `repository` and `bugs`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.repository, 'https://github.com/author/NpmFromWillfile.git' );
    test.identical( config.bugs, 'https://github.com/author/NpmFromWillfile/issues' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.imply withSubmodules:0 .with Submodule .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check fields `dependencies` and `devDependencies`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.dependencies, { eslint : '7.1.0', babel : '^0.3.0' } );
    test.identical( config.devDependencies, { NpmFromWillfile : 'file:.', wTesting : '', willbe : 'alpha' } );
    test.identical( config.name, 'npmfromwillfile' );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with Version .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `version`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.version, '0.0.0' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.imply withSubmodules:0 .build npm.generate' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check unnamed willfiles, full config';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.engines' : { node : '>= 6.0.0', chrome : '>= 60.0.0', firefox : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'scripts' : { test : 'wtest .run proto/** v:5', docgen : 'wdocgen .build proto' },
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    return null;
  });

  /* */

  return a.ready;
}

stepNpmGenerate.rapidity = -1;

//

function stepNpmGenerateOptionsInStep( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepNpmGenerate' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.imply withSubmodules:0 .build npm.package.path.strict' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `packagePath`, `package.json`, direct link to directory';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/debug/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.engines' : { 'node' : '>= 6.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.imply withSubmodules:0 .build npm.package.path.resolve.simple' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `packagePath`, `package.json`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out/' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
      'npm.engines' : { 'node' : '>= 6.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.imply withSubmodules:0 .build npm.package.path.resolve.criterion' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `packagePath`, `package.json`, resolve path with criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/debug/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
      'npm.engines' : { 'node' : '>= 6.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.entry.path.strict' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, direct link to file';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { main : 'proto/File.s' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.entry.path.resolve.simple' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { main : 'proto/File.s' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.entry.path.resolve.criterion' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { main : 'proto/File.s' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.files.path.strict' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `filesPath`, direct link to file';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s' ], main : 'proto' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.files.path.resolve.simple' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s' ], main : 'proto' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.files.path.resolve.criterion' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s' ], main : 'proto' };
    test.identical( config, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .build npm.files.path.resolve.array' });
  a.ready.then( ( op ) =>
  {
    test.case = 'resolve files path from array of paths';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s', 'proto' ], main : 'proto' };
    test.identical( config, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.with Name .build generate.with.module.name' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `name`';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { name : 'user.module.name' };
    test.identical( config, exp );

    return null;
  });

  /* - */

  return a.ready;
}

//

function stepGitCheckHardLinkRestoring( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* */

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( () =>
  {
    test.case = '.with clone/Git.* .build git.pull - succefull pulling';
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart( `.with clone/Git.* .build git.pull` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Executing command "git pull", module::git' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply v:0 .with clone/Git.* .build git.pull - succefull pulling';
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart( `.imply v:0 .with clone/Git.* .build git.pull` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Executing command "git pull", module::git' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    return null;
  });

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart({ execPath : `.with clone/Git.* .build git.pull` })
  .then( ( op ) =>
  {
    test.case = '.with clone/Git.* .build git.pull - succefull pulling with hardlinks';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Executing command "git pull", module::git' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/Git.* .build git.pull` )
  .then( ( op ) =>
  {
    test.description = 'has local changes';
    test.notIdentical( op.exitCode, 0 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/Git.* .build git.pull` )
  .then( ( op ) =>
  {
    test.description = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
copy
${ mergeEnd }
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
copy
${ mergeEnd }
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:0 .with clone/Git.* .build git.pull - succefull pulling';
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart({ execPath : `.imply withSubmodules:0 .with clone/Git.* .build git.pull` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Executing command "git pull", module::git' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( ( op ) =>
    {
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
      return null;
    });
    return a.ready;
  }
}

stepGitCheckHardLinkRestoring.rapidity = -1;
stepGitCheckHardLinkRestoring.timeOut = 600000;

//

function stepGitDifferentCommands( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* */

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* */

  begin();
  a.appStart( '.with clone/Git.* .build git.status' )
  .then( ( op ) =>
  {
    test.case = '.with clone/Git.* .build git.status';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Executing command "git status", module::git' ), 0 );
    test.identical( _.strCount( op.output, 'Changes not staged for commit' ), 1 );
    test.identical( _.strCount( op.output, 'modified' ), 2 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  })

  a.appStart( '.imply v:0 .with clone/Git.* .build git.log' )
  .then( ( op ) =>
  {
    test.case = '.imply v:0 .with clone/Git.* .build git.log';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Executing command "git log", module::git' ), 0 );
    test.identical( _.strCount( op.output, 'commit' ), 1 );
    test.identical( _.strCount( op.output, 'Author:' ), 1 );
    test.identical( _.strCount( op.output, 'Date:' ), 1 );
    test.identical( _.strCount( op.output, 'first' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );

    return null;
  })

  /* */

  a.appStart( '.with clone/Git.* .build git.log.hardlink' )
  .then( ( op ) =>
  {
    test.case = '.with clone/Git.* .build git.log.hardlink';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 1 );
    test.identical( _.strCount( op.output, 'Executing command "git log", module::git' ), 0 );
    test.identical( _.strCount( op.output, 'commit' ), 1 );
    test.identical( _.strCount( op.output, 'Author:' ), 1 );
    test.identical( _.strCount( op.output, 'Date:' ), 1 );
    test.identical( _.strCount( op.output, 'first' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );
    return null;
  })

  /* */

  a.appStart( '.imply withSubmodules:0 .with clone/Git.* .build git.commit' )
  .then( ( op ) =>
  {
    test.case = '.with clone/Git.* .build git.commit';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Executing command "git commit -am second", module::git' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( ( op ) =>
    {
      a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'copy\n' );
      return null;
    });
    return a.ready;
  }
}

//

function stepGitPull( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitConflict' );
  a.reflect();

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( ( op ) =>
  {
    test.case = '.with clone/ .build git.pull - succefull pulling';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart( '.with clone/ .build git.pull' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::original' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::original' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );
    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.imply v:0 .with clone/ .build pull.with.dir - succefull pulling';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart( '.imply v:0 .with clone/ .build pull.with.dir' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::original' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::original' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink, succefull';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart( '.with clone/ .build git.pull' )
  .then( ( op ) =>
  {
    test.case = '.with clone/ .build git.pull - succefull pulling with hardlinks';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::original' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::original' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );
    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = 'hardlink, has local changes';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( '.with clone/ .build pull.with.dir' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = 'hardlink, conflict';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( '.with clone/ .build git.pull' )
  .then( ( op ) =>
  {
    test.description = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    // a.ready.then( () => a.reflect() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    return a.ready;
  }
}

stepGitPull.rapidity = -1;
stepGitPull.timeOut = 300000;

//

function stepGitPush( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* */

  begin();
  a.appStart( '.with original/ .build git.push' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .build git.push - succefull pushing of commit';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, ' * [new branch]      master -> master' ), 1 );
    test.identical( _.strCount( op.output, /Branch .*master.* set up to track remote branch .*master.* from .*origin.*/), 1 );

    return null;
  });

  /* */

  a.appStart( '.imply withSubmodules:0 .with original/ .build git.push' )
  .then( ( op ) =>
  {
    test.case = '.imply withSubmodules:0 .with original/ .build git.push - second run, nothing to push';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::clone' ), 1 );
    test.identical( _.strCount( op.output, '. Read 1 willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );

    return null;
  })

  /* */

  begin();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -a v1.0 -m v1.0' });
  a.appStart( '.imply v:0 .with original/ .build push.with.dir' )
  .then( ( op ) =>
  {
    test.case = '.imply v:0 .with original/ .build push.with.dir - succefull pushing of tag';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 2 );
    test.identical( _.strCount( op.output, ' * [new tag]         v1.0 -> v1.0' ), 1 );

    return null;
  });

  /* */

  a.appStart( '.imply v:7 withSubmodules:0 .with original/ .build push.with.dir' )
  .then( ( op ) =>
  {
    test.case = '.imply v:7 withSubmodules:0 .with original/ .build push.with.dir - second run, nothing to push';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, '. Read 1 willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

//

function stepGitReset( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitReset' );

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .build git.reset.dir - directory proto is not a git dir, no resetting';
    return null;
  });
  a.appStart( '.with clone/ .build git.reset.dir' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::gitReset' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 0 );

    var exp =
`
console.log( 'File.js' );
console.log( "new line" );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
new line
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .build git.reset.default - resetting of current directory';
    return null;
  });
  a.appStart( '.with clone/ .build git.reset.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::gitReset' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .build git.reset.dry - with option dry';
    return null;
  });
  a.appStart( '.with clone/ .build git.reset.dry' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::gitReset' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );
    test.identical( _.strCount( op.output, 'Uncommitted changes, would be reseted :' ), 1 );
    test.identical( _.strCount( op.output, 'M File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Uncommitted changes, would be cleaned :' ), 1 );

    var exp =
`
console.log( 'File.js' );
console.log( "new line" );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
new line
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .build git.reset.removingUntracked - resetting of untracked files, but not ignored';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/proto/File2.js'), 'console.log( \'File2.js\' );' );
    a.fileProvider.fileWrite( a.abs( 'clone/File2.txt'), 'File2.txt' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './File2.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './proto/File2.js'
    ];
    test.identical( got, exp );

    return null;
  });

  a.appStart( '.with clone/ .build git.reset.removingUntracked' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .build git.reset.removingIgnored - resetting of untracked and ignored files';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/proto/File2.js'), 'console.log( \'File2.js\' );' );
    a.fileProvider.fileWrite( a.abs( 'clone/File2.txt'), 'File2.txt' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './File2.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './proto/File2.js'
    ];
    test.identical( got, exp );

    return null;
  });

  a.appStart( '.with clone/ .build git.reset.removingIgnored' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .build git.reset.removingIgnored';
    test.description = 'resetting of untracked and ignored files but not subrepository'
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.dirMake( a.abs( 'clone/sub' ) );
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' )\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );

    return null;
  });

  a.shell({ currentPath : a.abs( 'clone/sub' ), execPath : 'git init' });
  a.ready.then( () =>
  {
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );
    return null;
  });

  a.appStart( '.with clone/ .build git.reset.removingIgnored' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .build git.reset.removingSubrepositories';
    test.description = 'resetting of untracked, ignored files and subrepository'
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.dirMake( a.abs( 'clone/sub' ) );
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' )\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );

    return null;
  });

  a.shell({ currentPath : a.abs( 'clone/sub' ), execPath : 'git init' });
  a.ready.then( () =>
  {
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );
    return null;
  });

  a.appStart( '.with clone/ .build git.reset.removingSubrepositories' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply v:0 .with clone/ .build git.reset.default - verbosity:0';
    return null;
  });

  a.appStart( '.imply v:0 .with clone/ .build git.reset.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::gitReset' ), 0 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 0 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    // a.ready.then( () => a.reflect() );
    let currentPath = a.abs( 'clone' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.ready.then( () =>
    {
      a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
      a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
      return null;
    });
    return a.ready;
  }
}

stepGitReset.rapidity = -1;
stepGitReset.timeOut = 300000;

//

function stepGitStatus( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );
  a.reflect();

  /* - */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.default - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.with original/GitStatus .build git.status.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.default - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.with original/GitStatus .build git.status.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.default - local and remote commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });
  a.appStart( '.with original/GitStatus .build git.status.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.local0 - checks no local changes';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });
  a.appStart( '.with original/GitStatus .build git.status.local0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.remote0 - checks no local changes';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });
  a.appStart( '.with original/GitStatus .build git.status.remote0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.uncommittedIgnored1 - checks ignored uncommited';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });
  a.appStart( '.with original/GitStatus .build git.status.uncommittedIgnored1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.uncommittedIgnored0 - checks without ignored';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });
  a.appStart( '.with original/GitStatus .build git.status.uncommittedIgnored0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitStatus .build git.status.remoteBranches1 - checks with remote branches';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });
  a.appStart( '.with original/GitStatus .build git.status.remoteBranches1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );
    return a.ready;
  }
}

stepGitStatus.rapidity = -1;

//

function stepGitSync( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );
  let config = { path : { hlink : a.abs( '..' ) } };
  let profile = 'test-profile';
  _.censor.configSet({ profileDir : profile, set : config });

  /* - */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .build git.sync.default - committing and pushing, without message';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.with original/GitSync .build git.sync.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\s\./ ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/GitSync .build git.sync.default - only pulling, without message';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push -u origin --all' });
  a.appStart( '.with clone/GitSync .build git.sync.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'second' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .build git.sync.default - only pushing, without message';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am third' });
  a.appStart( '.with original/GitSync .build git.sync.default' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'first' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .build git.sync.message - committing, pulling and pushing with message';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "fourth"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
  a.appStart( '.with original/GitSync .build git.sync.message' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'fourth' ), 1 );
    test.identical( _.strCount( op.output, 'fifth' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'fifth' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply v:0 .with original/GitSync .build git.sync.message - checking of option verbosity';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "sixth"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
  a.appStart( '.imply v:0 .with original/GitSync .build git.sync.message' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "sixth"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
  a.appStart( '.with original/GitSync .build git.sync.dry' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitSync .build git.sync.dry - checking of option dry';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "seventh"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });
  a.appStart( '.with original/GitSync .build git.sync.resolve' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitSync .build git.sync.resolve - checking resolving of message';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am {about::name}' ), 0 );
    test.identical( _.strCount( op.output, '> git commit -am git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    _.censor.profileDel( profile );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );
    return a.ready;
  }
}

stepGitSync.rapidity = -1;

//

function stepGitTag( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin();
  a.appStart( '.with original/GitTag .build git.tag.default' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitTag .build git.tag.default - add tag, only option name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v1.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v1.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/GitTag .build git.tag.description' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitTag .build git.tag.description - add tag with description';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v2.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v2.0            Version 2.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/GitTag .build git.tag.light' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitTag .git.tag name:v3.0 description:"Version 3.0" light:1 - add tag, only option name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v3.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v3.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/GitTag .build git.tag.dry' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitTag .build git.tag.dry - option dry, should not add tag';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v4.0            Version 4.0' ), 0 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.imply v:0 .with original/GitTag .build git.tag.nodry' )
  a.appStart( '.imply v:0 .with original/GitTag .build git.tag.nodry' )
  .then( ( op ) =>
  {
    test.case = '.imply v:0 .with original/GitTag .build git.tag.nodry - verbosity';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 0 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v4.0            Version 4.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/GitTag .build git.tag.with.criterion* tag:alpha' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitTag .build git.tag.with.criterion* tag:alpha - add tag from criterion';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag alpha' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'alpha' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/GitTag .build git.tag.with.criterion.beta' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitTag .build git.tag.with.criterion.beta - add tag from criterion';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::git-tag' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag beta' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'beta' ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

stepGitTag.rapidity = -1;

//

function stepRepoReleaseRemote( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'repoRelease' );
  const user = 'dmvict';
  // const user = 'wtools-bot';
  const repository = `https://github.com/${ user }/New-${ _.intRandom( 1000000 ) }`;
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  begin();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'repository has no tags';
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am init' );
  a.shell( 'git push -u origin master' );

  a.appStart( '.imply v:2 .build release.master' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".imply v:2 .build release.master"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "0.0.1" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repository with tags, release existed tag, release with name and options';
    a.fileProvider.fileWrite( a.abs( './file.txt' ), 'file.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git tag first' );
  a.ready.then( () =>
  {
    a.fileProvider.fileWrite( a.abs( './file1.txt' ), 'file1.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git tag second' );
  a.shell( 'git push -u origin master' );
  a.shell( 'git push --tags' );

  a.appStart( '.imply v:2 .build release.existed' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".imply v:2 .build release.existed"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "first" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repository with tags, release existed tag, release with description';
    a.fileProvider.fileWrite( a.abs( './file2.txt' ), 'file2.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git tag v0.0.2' );
  a.shell( 'git push -u origin master' );
  a.shell( 'git push --tags' );

  a.appStart( '.imply v:2 .build release.description' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".imply v:2 .build release.description"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "v0.0.3" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'release tag twice, force - 1';
    a.fileProvider.fileAppend( a.abs( './file2.txt' ), 'file2.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git push -u origin master' );
  a.shell( 'git push --tags' );

  a.appStart( '.imply v:2 .build release.force' );
  a.appStart( '.imply v:2 .build release.force' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".imply v:2 .build release.force"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully deleted release "v0.0.4" in git+https:///github.com/${ user }` ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "v0.0.4" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () => repositoryDelete() );

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( ( op ) => a.reflectMinimal() );
    a.ready.then( ( op ) => repositoryDelete() );
    a.ready.then( () =>
    {
      return _.git.repositoryInit
      ({
        remotePath : repository,
        localPath : a.routinePath,
        throwing : 1,
        description : 'Test',
        token,
      });
    });

    return a.ready;
  }

  /* */

  function repositoryDelete()
  {
    return _.git.repositoryDelete
    ({
      remotePath : repository,
      token,
      throwing : 0,
    });
  }
}

//

function stepView( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepView' );

  if( process.platform !== 'linux' || !_.process.insideTestContainer() )
  return test.true( true );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'view file on remote server';
    a.reflectMinimal();
    return null;
  });
  a.appStart( '.build view1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".build view1"' ), 1 );
    test.identical( _.strCount( op.output, 'Read 1 willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::stepView / build::view1' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepView / build::view1' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'view file on local storage';
    a.reflectMinimal();
    return null;
  });
  a.appStart( '.build view2' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".build view2"' ), 1 );
    test.identical( _.strCount( op.output, 'Read 1 willfile' ), 1 );
    test.identical( _.strCount( op.output, 'Building module::stepView / build::view2' ), 1 );
    test.identical( _.strCount( op.output, 'Built module::stepView / build::view2' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

// --
// command
// --

function commandHelp( test )
{
  let context = this;
  let a = context.assetFor( test, 'single' );
  a.fileProvider.dirMake( a.abs( '.' ) );

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = 'simple run without args';
    return null;
  });

  a.appStartNonThrowing( '' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( op.output.length >= 1 );
    test.identical( _.strCount( op.output, /.*.help.* - Get help/ ), 1 );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = 'simple run without args'
    return null;
  });

  a.appStartNonThrowing( '.' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( op.output.length >= 1 );
    test.identical( _.strCount( op.output, /.*.help.* - Get help/ ), 1 );
    test.ge( _.strLinesCount( op.output ), 24 );
    return null;
  });

  /* */

  a.appStart({ execPath : '.help' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.ge( _.strLinesCount( op.output ), 24 );
    return op;
  });

  /* */

  a.appStartNonThrowing({ args : [] })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.ge( _.strLinesCount( op.output ), 24 );
    return op;
  });

  return a.ready;
}

//

function commandImplyWithDot( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( '.clone/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.imply withSubmodules:0 withOut:0 .with ".clone/" .call GitStatus' )
  .then( ( op ) =>
  {
    test.case = '.with .clone/ .git.status - only local commits';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  })

  /* - */

  return a.ready;

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.clone' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( '.clone' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

//

function commandImplyWithAsterisk( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( '.module/File.txt' ), 'new line\n' );
    return null;
  })

  a.appStart( '.imply withSubmodules:0 withOut:0 .with ./.module/* .call GitStatus' )
  .then( ( op ) =>
  {
    test.case = '.with module .git.status - only local commits';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 6 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 6 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  })

  a.appStart( '.imply withSubmodules:0 withOut:0 .with ./.module/** .call GitStatus' )
  .then( ( op ) =>
  {
    test.case = '.with module .git.status - only local commits';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 7 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 7 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  })

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.module' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( '.module' )
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

//

function commandImplyWithSubmodulesModulesList( test )
{
  let context = this;
  let a = context.assetFor( test, '4LevelsLocal' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'default withSubmodules';
    a.reflect();
    return null;
  });
  a.appStart( '".with l4 .modules.list"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 7 );
    test.identical( _.strCount( op.output, 'remote : null' ), 4 );
    test.identical( _.strCount( op.output, 'module::l4' ), 4 );
    test.identical( _.strCount( op.output, 'module::l3' ), 1 );
    test.identical( _.strCount( op.output, 'module::l2' ), 1 );
    test.identical( _.strCount( op.output, 'module::l1' ), 1 );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    test.case = 'withSubmodules:0';
    a.reflect();
    return null;
  })
  a.appStart( '".imply withSubmodules:0 ; .with l4 .modules.list"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 1 );
    test.identical( _.strCount( op.output, 'remote : null' ), 1 );
    test.identical( _.strCount( op.output, 'module::l4' ), 1 );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    test.case = 'withSubmodules:1';
    a.reflect();
    return null;
  })
  a.appStart( '".imply withSubmodules:1 ; .with l4 .modules.list"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 3 );
    test.identical( _.strCount( op.output, 'remote : null' ), 2 );
    test.identical( _.strCount( op.output, 'module::l4' ), 2 );
    test.identical( _.strCount( op.output, 'module::l3' ), 1 );

    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = 'withSubmodules:2';
    a.reflect();
    return null;
  })
  a.appStart( '".imply withSubmodules:2 ; .with l4 .modules.list"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 7 );
    test.identical( _.strCount( op.output, 'remote : null' ), 4 );
    test.identical( _.strCount( op.output, 'module::l4' ), 4 );
    test.identical( _.strCount( op.output, 'module::l3' ), 1 );
    test.identical( _.strCount( op.output, 'module::l2' ), 1 );
    test.identical( _.strCount( op.output, 'module::l1' ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = 'withSubmodules:0';
    a.reflect();
    return null;
  })
  a.appStart( '.imply withSubmodules:0 .with l4 .modules.list' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 1 );
    test.identical( _.strCount( op.output, 'remote : null' ), 1 );
    test.identical( _.strCount( op.output, 'module::l4' ), 1 );

    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = 'withSubmodules:1';
    a.reflect();
    return null;
  })
  a.appStart( '.imply withSubmodules:1 .with l4 .modules.list' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 3 );
    test.identical( _.strCount( op.output, 'remote : null' ), 2 );
    test.identical( _.strCount( op.output, 'module::l4' ), 2 );
    test.identical( _.strCount( op.output, 'module::l3' ), 1 );

    return null;
  })

  /* */

  a.ready
  .then( () =>
  {
    test.case = 'withSubmodules:2';
    a.reflect();
    return null;
  })
  a.appStart( '.imply withSubmodules:2 .with l4 .modules.list' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'error' ), 0 );

    test.identical( _.strCount( op.output, 'module::' ), 7 );
    test.identical( _.strCount( op.output, 'remote : null' ), 4 );
    test.identical( _.strCount( op.output, 'module::l4' ), 4 );
    test.identical( _.strCount( op.output, 'module::l3' ), 1 );
    test.identical( _.strCount( op.output, 'module::l2' ), 1 );
    test.identical( _.strCount( op.output, 'module::l1' ), 1 );

    return null;
  })

  /* - */

  return a.ready;
}

commandImplyWithSubmodulesModulesList.rapidity = -1;
commandImplyWithSubmodulesModulesList.description =
`
- imply withSubmodules:0 cause to open no submodules
- imply withSubmodules:1 cause to open only submodules of the main module
- imply withSubmodules:2 cause to open all submodules recursively
- no error are thowen
`

//

function commandImplyPropertyWithDisabled( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandImplyProperties' );
  a.reflect();

  /* - */

  act({ withWith : 0 });
  act({ withWith : 1, implyFirst : 0 });
  // act({ withWith : 1, implyFirst : 1 }) //qqq for Vova: to implement

  /* - */

  return a.ready;

  /* */

  function act( o )
  {
    let withWith = o.withWith ? '.with **/' : '';

    function commandFor( opts )
    {
      let command = [ `.imply ${opts.imply}`, `${opts.command}` ];

      if( o.withWith )
      {
        if( o.implyFirst )
        command.splice( 1, 0, withWith );
        else
        command.unshift( withWith );
      }

      command = command.join( ' ' );

      test.case = command;
      return command;
    }

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:0', command : '.submodules.download withDisabledSubmodules:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledSubmodules:0', command : '.submodules.download withDisabled:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:0', command : '.submodules.download withDisabledSubmodules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledSubmodules:1', command : '.submodules.download withDisabled:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:1', command : '.submodules.download withDisabledSubmodules:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      if( o.withWith )
      expected.push( 'ModuleForTesting1a' );
      test.identical( modules, expected );

      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledSubmodules:0', command : '.submodules.download withDisabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ]
      if( o.withWith )
      expected.push( 'ModuleForTesting1a' );
      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:1', command : '.submodules.download withDisabledSubmodules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      if( o.withWith )
      expected = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2a' ];
      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledSubmodules:1', command : '.submodules.download withDisabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      if( o.withWith )
      expected = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2a' ];
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:0', command : '.submodules.download withDisabledModules:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledModules:0', command : '.submodules.download withDisabled:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:0', command : '.submodules.download withDisabledModules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      if( o.withWith )
      expected.push( 'ModuleForTesting1a' );
      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledModules:1', command : '.submodules.download withDisabled:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      if( o.withWith )
      expected.push( 'ModuleForTesting1a' );
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:1', command : '.submodules.download withDisabledModules:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      test.identical( modules, expected );
      return null;
    });

    /* */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledModules:0', command : '.submodules.download withDisabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabled:1', command : '.submodules.download withDisabledModules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      if( o.withWith )
      expected = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2a' ];

      test.identical( modules, expected );
      return null;
    });

    /* fails */

    clean();
    a.appStart({ args : commandFor({ imply : 'withDisabledModules:1', command : '.submodules.download withDisabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1', 'ModuleForTesting2' ];
      if( o.withWith )
      expected = [ 'ModuleForTesting1', 'ModuleForTesting1a', 'ModuleForTesting2', 'ModuleForTesting2a' ];

      test.identical( modules, expected );
      return null;
    });
  }

  /* */

  function clean()
  {
    return a.ready.then( () =>
    {
      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();
      return null;
    });
  }
}

commandImplyPropertyWithDisabled.timeOut = 1400000;

//

function commandImplyPropertyWithEnabled( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandImplyProperties' );
  a.reflect();

  /* - */

  act({ withWith : 0 })
  act({ withWith : 1, implyFirst : 0 })
  // act({ withWith : 1, implyFirst : 1 }) //qqq: for Vova to implement

  /* - */

  return a.ready;

  /* - */

  function act( o )
  {
    let withWith = o.withWith ? '.with **/' : '';

    function commandFor( opts )
    {
      let command = [ `.imply ${opts.imply}`, `${opts.command}` ];

      if( o.withWith )
      {
        if( o.implyFirst )
        command.splice( 1, 0, withWith );
        else
        command.unshift( withWith );
      }

      command = command.join( ' ' );

      test.case = command;

      return command;
    }

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabled:0', command : '.submodules.download withEnabledSubmodules:0' }) })
    a.ready.then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabledSubmodules:0', command : '.submodules.download withEnabled:0' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabled:0', command : '.submodules.download withEnabledSubmodules:1' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabledSubmodules:1', command : '.submodules.download withEnabled:0' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabled:1', command : '.submodules.download withEnabledSubmodules:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null;
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabledSubmodules:0', command : '.submodules.download withEnabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null;
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabled:1', command : '.submodules.download withEnabledSubmodules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabledSubmodules:1', command : '.submodules.download withEnabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabled:0', command : '.submodules.download withEnabledModules:0' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabledModules:0', command : '.submodules.download withEnabled:0' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabled:0', command : '.submodules.download withEnabledModules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabledModules:1', command : '.submodules.download withEnabled:0' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null;
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabled:1', command : '.submodules.download withEnabledModules:0' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStartNonThrowing({ args : commandFor({ imply : 'withEnabledModules:0', command : '.submodules.download withEnabled:1' }) })
    .then( ( op ) =>
    {
      if( o.withWith )
      {
        test.notIdentical( op.exitCode, 0 );
        test.true( _.strHas( op.output, 'Found no willfile at' ) );
      }

      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = null
      test.identical( modules, expected );

      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabled:1', command : '.submodules.download withEnabledModules:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    })

    /* */

    clean()
    a.appStart({ args : commandFor({ imply : 'withEnabledModules:1', command : '.submodules.download withEnabled:1' }) })
    .then( () =>
    {
      let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
      let expected = [ 'ModuleForTesting1' ];
      test.identical( modules, expected );
      return null;
    })

  }

  /* */

  function clean()
  {
    a.ready.then( () =>
    {
      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();
      return null;
    });
  }
}

commandImplyPropertyWithEnabled.timeOut = 1200000;

//

function commandBuildImply( test )
{
  let context = this;
  let a = context.assetFor( test, 'stepNpmGenerate' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.with Author .build npm.generate' });
  a.ready.then( ( op ) =>
  {
    test.case = 'without options';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out' ) );
    test.identical( files, [] );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );
    return null;
  });

  /* */

  a.appStart({ args : '.with Author .build.imply packagePath:"out/package.json" .build npm.generate' });
  a.ready.then( ( op ) =>
  {
    test.case = 'single option in command';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'out/package.json' ) );
    var exp = { author : 'Author <author@dot.com>' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );
    return null;
  });

  /* */

  a.appStart({ args : '.with Author .build.imply packagePath:"out/package.json" npmName:test .build npm.generate' });
  a.ready.then( ( op ) =>
  {
    test.case = 'several options in command';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'out/package.json' ) );
    var exp = { name : 'test', author : 'Author <author@dot.com>' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );
    return null;
  });

  /* */

  a.appStart({ args : '.build.imply packagePath:"out/package.json" .with Author .build.imply npmName:test .build npm.generate' });
  a.ready.then( ( op ) =>
  {
    test.case = 'several options in different parts of command';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'out/package.json' ) );
    var exp = { name : 'test', author : 'Author <author@dot.com>' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );
    return null;
  });

  /* */

  a.appStart({ args : '.build.imply packagePath:"out/package.json" npmName:test .with Author .build.imply npmName:tst .build npm.generate' });
  a.ready.then( ( op ) =>
  {
    test.case = 'several options in different parts of command, last rewrite previous';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'out/package.json' ) );
    var exp = { name : 'tst', author : 'Author <author@dot.com>' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandBuildImplyWithSeveralSteps( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandBuildImply' );
  a.reflectMinimal();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'different commands, should not extend extra options';
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.name, 'build-imply' );
    test.identical( config.about.version, '0.0.0' );
    return null;
  });

  a.appStart({ args : '.build.imply shell:"echo str" versionDelta:1.0.0 .build' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '> echo str' ), 1 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.name, 'build-imply' );
    test.identical( config.about.version, '1.0.0' );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandVersion( test )
{
  let context = this;
  let a = context.assetFor( test, 'simple' );
  a.fileProvider.dirMake( a.abs( '.' ) );

  /* - */

  a.ready.then( () =>
  {
    test.case = '.version';
    return null;
  });

  a.appStart({ args : '.version' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, 'Read' ) );
    test.true( _.strHas( op.output, /Current version : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Latest version of willbe : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Stable version of willbe : \d+\.\d+\.\d+/ ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply v:9 ; .version';
    return null;
  });

  a.appStart({ args : '.imply v:9 ; .version' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, 'Read' ) );
    test.true( _.strHas( op.output, /Current version : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Latest version of willbe : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Stable version of willbe : \d+\.\d+\.\d+/ ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.imply v:9 .version';
    return null;
  });

  a.appStart({ args : '.imply v:9 .version' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, 'Read' ) );
    test.true( _.strHas( op.output, /Current version : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Latest version of willbe : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Stable version of willbe : \d+\.\d+\.\d+/ ) );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.version v:7';
    return null;
  });

  a.appStart({ args : '.version v:7' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, 'Read' ) );
    test.true( _.strHas( op.output, /Current version : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Latest version of willbe : \d+\.\d+\.\d+/ ) );
    test.true( _.strHas( op.output, /Stable version of willbe : \d+\.\d+\.\d+/ ) );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandVersionCheck( test )
{
  let context = this;
  let a = context.assetFor( test, 'simple' );

  begin();

  /* starter for local copy of utility */
  a.appStart = _.process.starter
  ({
    execPath : `node ${ a.path.nativize( a.abs( 'proto/wtools/atop/will/entry/Exec' ) ) }`,
    currentPath : a.abs( '.' ),
    outputCollecting : 1,
    throwingExitCode : 0,
    verbosity : 3,
    ready : a.ready,
  });

  /* - */

  a.appStart({ args : '.version.check' })
  .then( ( op ) =>
  {
    test.case = '".version.check", current version';
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Current version: \d+\.\d+\.\d+/ ) );
    return null
  });

  a.appStart({ args : '.imply v:9 ; .version.check' })
  .then( ( op ) =>
  {
    test.case = '".imply v:9 ; .version.check", current version';
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Read/ ) );
    test.true( _.strHas( op.output, /Current version: \d+\.\d+\.\d+/ ) );
    return null
  });

  a.appStart({ args : '.imply v:9 .version.check' })
  .then( ( op ) =>
  {
    test.case = '".imply v:9 .version.check", current version';
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Read/ ) );
    test.true( _.strHas( op.output, /Current version: \d+\.\d+\.\d+/ ) );
    return null
  });

  a.appStart({ args : '.version.check v:7' })
  .then( ( op ) =>
  {
    test.case = '".version.check v:7", current version';
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Read/ ) );
    test.true( _.strHas( op.output, /Current version: \d+\.\d+\.\d+/ ) );
    return null
  });

  /* */

  a.ready.then( () =>
  {
    let packageJsonPath = a.abs( 'package.json' );
    let packageJson = a.fileProvider.fileRead({ filePath : packageJsonPath, encoding : 'json' });
    packageJson.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : packageJsonPath, encoding : 'json', data : packageJson });
    return null;
  });

  a.appStart({ args : '.version.check' })
  .then( ( op ) =>
  {
    test.case = '".version.check", outdated version';
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Current version: 0.0.0/ ) );
    return null;
  });

  a.appStart({ args : '.imply v:9 ; .version.check' })
  .then( ( op ) =>
  {
    test.case = '".imply v:9 ; .version.check", outdated version';
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Current version: 0.0.0/ ) );
    return null;
  });

  a.appStart({ args : '.imply v:9 .version.check' })
  .then( ( op ) =>
  {
    test.case = '".imply v:9 .version.check", outdated version';
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Current version: 0.0.0/ ) );
    return null;
  });

  a.appStart({ args : '.version.check v:7' })
  .then( ( op ) =>
  {
    test.case = '".imply v:7 .version.check", outdated version';
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, /Utility willbe is out of date!/ ) );
    test.true( _.strHas( op.output, /Current version: 0.0.0/ ) );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( '.' ) ); return null });
    a.shell( 'git clone https://github.com/Wandalen/willbe.git .' );
    a.shell( 'npm i' );
    return a.ready;
  }
}

//

function commandVersionBump( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'initial check';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );

    return null;
  });

  a.appStart({ args : '.with Version .version.bump' })
  .then( ( op ) =>
  {
    test.case = '".version.bump", bump with defaults';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump 1' })
  .then( ( op ) =>
  {
    test.case = '".version.bump 1", bump with number delta';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump 0.1.1' })
  .then( ( op ) =>
  {
    test.case = '".version.bump 0.1.1", bump with string delta, full form';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump 1.1' })
  .then( ( op ) =>
  {
    test.case = '".version.bump 1.1", bump with string delta, not full form';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump patch' })
  .then( ( op ) =>
  {
    test.case = '".version.bump patch", bump with string delta, increase patch version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump minor' })
  .then( ( op ) =>
  {
    test.case = '".version.bump minor", bump with string delta, increase minor version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump major' })
  .then( ( op ) =>
  {
    test.case = '".version.bump major", bump with string delta, increase major version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.0.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump versionDelta:1' })
  .then( ( op ) =>
  {
    test.case = '".version.bump versionDelta:1", bump with option, number delta';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump versionDelta:0.1.1' })
  .then( ( op ) =>
  {
    test.case = '".version.bump versionDelta:0.1.1", bump with option, string delta, full form';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump versionDelta:1.1' })
  .then( ( op ) =>
  {
    test.case = '".version.bump versionDelta:1.1", bump with option, string delta, not full form';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump versionDelta:patch' })
  .then( ( op ) =>
  {
    test.case = '".version.bump versionDelta:patch", bump with string delta, increase patch version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.1' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump versionDelta:minor' })
  .then( ( op ) =>
  {
    test.case = '".version.bump versionDelta:minor", bump with string delta, increase minor version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.1.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  a.appStart({ args : '.with Version .version.bump versionDelta:major' })
  .then( ( op ) =>
  {
    test.case = '".version.bump versionDelta:major", bump with string delta, increase major version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.0.0' );

    config.about.version = '0.0.0';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* - */

  a.appStartNonThrowing({ args : '.with Author .version.bump' })
  .then( ( op ) =>
  {
    test.case = 'willfile has not version';
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, undefined );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'willfile has version as number';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    config.about.version = 1.1;
    a.fileProvider.fileWrite({ filePath : a.abs( 'Author.will.yml' ), data : config, encoding : 'yaml' });
    return null;
  });

  a.appStartNonThrowing({ args : '.with Author .version.bump' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, 1.1 );
    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.with Version .version.bump -1' })
  .then( ( op ) =>
  {
    test.case = 'bump with negative number';
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );
    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.with Version .version.bump versionDelta:-1' })
  .then( ( op ) =>
  {
    test.case = 'bump with negative number';
    test.notIdentical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandVersionBumpCheckReset( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflect();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'initial check';
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });
    return null;
  });

  a.appStart({ args : '.with Version .version.bump 1.1.1' })
  .then( ( op ) =>
  {
    test.case = 'bump major version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '2.0.0' );

    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* */

  a.appStart({ args : '.with Version .version.bump 0.1.1' })
  .then( ( op ) =>
  {
    test.case = 'bump minor version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.3.0' );

    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* */

  a.appStart({ args : '.with Version .version.bump 1' })
  .then( ( op ) =>
  {
    test.case = 'bump patch version';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.2.4' );

    config.about.version = '1.2.3';
    a.fileProvider.fileWrite({ filePath : a.abs( 'Version.will.yml' ), data : config, encoding : 'yaml' });

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandStepsList( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodules' );
  a.reflectMinimal();

  /* - */

  a.appStart({ execPath : '.steps.list' })
  .finally( ( err, op ) =>
  {
    test.case = '.steps.list';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )

    test.true( _.strHas( op.output, 'step::delete.out.debug' ) );
    test.true( _.strHas( op.output, /step::reflect\.proto\.[^d]/ ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ) );
    test.true( _.strHas( op.output, 'step::reflect.submodules' ) );
    test.true( _.strHas( op.output, 'step::export.proto' ) );

    return null;
  });

  /* */

  a.appStart({ execPath : '.steps.list *' })
  .finally( ( err, op ) =>
  {
    test.case = '.steps.list';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 )
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );

    test.true( _.strHas( op.output, 'step::delete.out.debug' ) );
    test.true( _.strHas( op.output, /step::reflect\.proto\.[^d]/ ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ) );
    test.true( _.strHas( op.output, 'step::reflect.submodules' ) );
    test.true( _.strHas( op.output, 'step::export.proto' ) );

    return null;
  });

  /* */

  a.appStart({ execPath : '.steps.list *proto*' })
  .finally( ( err, op ) =>
  {
    test.case = '.steps.list';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 )
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );

    test.true( !_.strHas( op.output, 'step::delete.out.debug' ) );
    test.true( _.strHas( op.output, /step::reflect\.proto\.[^d]/ ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ) );
    test.true( !_.strHas( op.output, 'step::reflect.submodules' ) );
    test.true( _.strHas( op.output, 'step::export.proto' ) );

    return null;
  });

  /* */

  a.appStart({ execPath : '.steps.list *proto* debug:1' })
  .finally( ( err, op ) =>
  {
    test.case = '.steps.list';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 )
    test.identical( _.strCount( op.output, 'ncaught' ), 0 );

    test.true( !_.strHas( op.output, 'step::delete.out.debug' ) );
    test.true( !_.strHas( op.output, /step::reflect\.proto\.[^d]/ ) );
    test.true( _.strHas( op.output, 'step::reflect.proto.debug' ) );
    test.true( !_.strHas( op.output, 'step::reflect.submodules' ) );
    test.true( _.strHas( op.output, 'step::export.proto' ) );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandModuleNewDotless( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoDotlessExported' );

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });
  a.appStartNonThrowing({ execPath : '.module.new', currentPath : a.routinePath })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './ex.will.yml',
      './im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/ex.will.yml',
      './sub/im.will.yml'
    ]
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new module::commandModuleNewDotless at' ), 1 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 1 );
    test.identical( _.strCount( op.output, 'already exists!' ), 1 );

    return null;
  })

  /* - */
  a.ready
  .then( () =>
  {
    test.case = '.module.new some'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new some' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './ex.will.yml',
      './im.will.yml',
      './some.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/ex.will.yml',
      './sub/im.will.yml'
    ]
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  })
  a.appStartNonThrowing({ execPath : '.with some .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new some/'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new some/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './ex.will.yml',
      './im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './some',
      './some/will.yml',
      './sub',
      './sub/ex.will.yml',
      './sub/im.will.yml'
    ]
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  })

  a.appStartNonThrowing({ execPath : '.with some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new ../dir1/dir2/some/'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new ../dir1/dir2/some/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './ex.will.yml',
      './im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/ex.will.yml',
      './sub/im.will.yml'
    ]
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    var exp = [ '.', './dir2', './dir2/some', './dir2/some/will.yml' ]
    var files = a.find( a.abs( '../dir1' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  })
  a.appStartNonThrowing({ execPath : '.with ../dir1/dir2/some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    a.fileProvider.filesDelete( a.abs( '../dir1' ) );
    return null;
  })

  /* - */

  return a.ready;
}

//

function commandModuleNewDotlessSingle( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoDotlessSingleExported' );

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new module::commandModuleNewDotlessSingle at' ), 1 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 1 );
    test.identical( _.strCount( op.output, 'already exists!' ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new some'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new some' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './some.will.yml',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  })
  a.appStartNonThrowing({ execPath : '.with some .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new some/'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new some/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './some',
      './some/will.yml',
      './sub',
      './sub/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  })
  a.appStartNonThrowing({ execPath : '.with some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new ../dir1/dir2/some/'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  })
  a.appStartNonThrowing({ execPath : '.module.new ../dir1/dir2/some/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './sub',
      './sub/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    var exp = [ '.', './dir2', './dir2/some', './dir2/some/will.yml' ]
    var files = a.find( a.abs( '../dir1' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  })
  a.appStartNonThrowing({ execPath : '.with ../dir1/dir2/some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    a.fileProvider.filesDelete( a.abs( '../dir1' ) );
    return null;
  })

  /* - */

  return a.ready;
}

//

function commandModuleNewNamed( test )
{
  let context = this;
  let a = context.assetFor( test, 'twoExported' )

  /* - */

  a.ready.then( () =>
  {
    test.case = '.module.new super'
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.module.new super' })
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 1 );
    test.identical( _.strCount( op.output, 'already exists!' ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with some .module.new'
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });
  a.appStartNonThrowing({ execPath : '.with some .module.new' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './some.will.yml',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with some .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with some/ .module.new'
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });
  a.appStartNonThrowing({ execPath : '.with some/ .module.new' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './some',
      './some/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.with some .module.new some2'
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.with some .module.new some2' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './some',
      './some/some2.will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some2 at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with some/some2 .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some2'` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.module.new'
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.module.new' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::commandModuleNewNamed at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with . .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'commandModuleNewNamed'` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.module.new super/'
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.module.new super/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './super',
      './super/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::super at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with super/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'super'` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.module.new some';
    a.reflect();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.module.new some' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './some.will.yml',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with some .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = '.module.new some/';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });
  a.appStartNonThrowing({ execPath : '.module.new some/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js',
      './some',
      './some/will.yml'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    return null;
  });

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.module.new ../dir1/dir2/some/';
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( 'sub.out' ) );
    a.fileProvider.filesDelete( a.abs( 'super.out' ) );
    return null;
  });

  a.appStartNonThrowing({ execPath : '.module.new ../dir1/dir2/some/' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var exp =
    [
      '.',
      './sub.ex.will.yml',
      './sub.im.will.yml',
      './super.ex.will.yml',
      './super.im.will.yml',
      './proto',
      './proto/File.debug.js',
      './proto/File.release.js'
    ];
    var files = a.find( a.routinePath );
    test.identical( files, exp );

    var exp =
    [
      '.',
      './dir2',
      './dir2/some',
      './dir2/some/will.yml'
    ];
    var files = a.find( a.abs( '../dir1' ) );
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, 'Cant make a new' ), 0 );
    test.identical( _.strCount( op.output, 'already exists!' ), 0 );
    test.identical( _.strCount( op.output, 'Create module::some at' ), 1 );

    return null;
  });

  a.appStartNonThrowing({ execPath : '.with ../dir1/dir2/some/ .about.list' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled error' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught error' ), 0 );
    test.identical( _.strCount( op.output, `name : 'some'` ), 1 );

    a.fileProvider.filesDelete( a.abs( '../dir1' ) );
    return null;
  });

  /* - */

  return a.ready;
}

commandModuleNewNamed.rapidity = -1;

//

function commandWithMixed( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesMixed' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with module .build'
    return null;
  })

  a.appStartNonThrowing({ execPath : '.with module .build' })
  .then( ( op ) =>
  {
    test.true( op.exitCode !== 0 );
    test.true( _.strHas( op.output, 'No module sattisfy criteria.' ) );
    test.identical( _.strCount( op.output, 'uncaught error' ), 0 );
    test.identical( _.strCount( op.output, '====' ), 0 );
    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.with . .build'
    return null;
  })

  a.appStartNonThrowing({ execPath : '.with . .export' })
  .then( ( op ) =>
  {
    test.true( op.exitCode === 0 );
    test.identical( _.strCount( op.output, /Exported .*module::submodulesMixed \/ build::proto.export.* in/ ), 1 );
    return null;
  })

  /* - */

  return a.ready;
}

commandWithMixed.timeOut = 300000;

//

function commandEachMixed( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesGit' );
  a.reflect();

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.each submodule::*/path::download .shell "git status"'
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build' })
  a.appStart({ execPath : '.each submodule::*/path::download .shell "git status"' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'git status' ) );
    /*
    test.true( _.strHas( op.output, `Your branch is up to date with 'origin/master'.` ) );
    // no such string on older git
    */
    test.identical( _.strCount( op.output, 'git status' ), 1 );
    test.identical( _.strCount( op.output, 'git "status"' ), 4 );
    test.identical( _.strCount( op.output, /nothing to commit, working .* clean/ ), 4 );

    test.true( _.strHas( op.output, /eachMixed\/\.module\/Tools\/out\/wTools\.out\.will\.yml[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/\.module\/Tools[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/\.module\/PathBasic\/out\/wPathBasic\.out\.will\.yml[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/\.module\/PathBasic[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/out\/UriBasic\.informal\.out\.will\.yml[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/out\/UriBasic[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/out\/Proto\.informal\.out\.will\.yml[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/out\/Proto\.informal\.out\.will\.yml[^d]/ ) );
    test.true( _.strHas( op.output, /eachMixed\/out\/Proto[^d]/ ) );

    return null;
  })

  /* - */

  a.ready
  .then( () =>
  {
    test.case = '.each submodule:: .shell ls'
    return null;
  })

  a.appStart({ execPath : '.clean' })
  a.appStart({ execPath : '.build' })
  a.appStart({ execPath : '.each submodule:: .shell ls -al' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'ls -al' ), 1 );
    test.identical( _.strCount( op.output, 'ls "-al"' ), 4 );
    test.identical( _.strCount( op.output, 'Module at' ), 4 );

    test.identical( _.strCount( op.output, '.module/Tools/out/wTools.out.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '.module/PathBasic/out/wPathBasic.out.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'out/UriBasic.informal.out.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'out/Proto.informal.out.will.yml' ), 1 );

    test.identical( _.strCount( op.output, '.module/Tools/out/wTools' ), 2 );
    test.identical( _.strCount( op.output, '.module/PathBasic/out/wPathBasic' ), 2 );
    test.identical( _.strCount( op.output, 'out/UriBasic.informal' ), 2 );
    test.identical( _.strCount( op.output, 'out/Proto.informal' ), 2 );

    return null;
  })

  /* - */

  return a.ready;
}

commandEachMixed.timeOut = 300000;

//

function commandWithList( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmodules' );

  /* - */

  begin();

  /* */

  a.appStart({ args : '.with . .resources.list about::name' })
  .finally( ( err, op ) =>
  {
    test.case = '.with . .resources.list about::name';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'commandWithList/.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-' ), 1 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    return null;
  });

  /* */

  a.appStart({ args : '.with . .resources.list about::description' })
  .finally( ( err, op ) =>
  {
    test.case = '.with . .resources.list about::description';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'commandWithList/.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'Module for testing' ), 1 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    return null;
  });

  /* */

  a.appStart({ args : '.with . .resources.list path::module.dir' })
  .finally( ( err, op ) =>
  {
    test.case = '.with . .resources.list path::module.dir';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'commandWithList/.will.yml' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath ), 2 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflectMinimal();
      a.fileProvider.fileWrite( a.abs( 'proto/b/-Excluded.js' ), 'console.log( \'b/-Ecluded.js\' );' );
      return null;
    });
  }
}

//

function commandEachList( test )
{
  let context = this;
  let a = context.assetFor( test, 'eachList' );

  /* - */

  begin();

  /* */

  a.appStart({ args : '.clean' })

  a.appStart({ args : '.each . .resources.list about::name' })
  .finally( ( err, op ) =>
  {
    test.case = '.each . .resources.list about::name';
    test.true( !err );
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Module at' ), 6 );
    test.identical( _.strCount( op.output, 'module-' ), 6 );

    test.identical( _.strCount( op.output, 'eachList/.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-x' ), 1 );
    test.identical( _.strCount( op.output, 'eachList/ab-named.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-ab-named' ), 1 );
    test.identical( _.strCount( op.output, 'eachList/a.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-a' ), 2 );
    test.identical( _.strCount( op.output, 'eachList/b.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-b' ), 2 );
    test.identical( _.strCount( op.output, 'eachList/bc-named.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-bc-named' ), 1 );
    test.identical( _.strCount( op.output, 'eachList/c.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'module-c' ), 1 );

    return null;
  })

  /* - */

  a.appStart({ args : '.imply v:1 ; .each . .resources.list about::name' })
  .finally( ( err, op ) =>
  {
    test.case = '.imply v:1 ; .each . .resources.list about::name';
    test.true( !err );
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Module at' ), 0 );
    test.identical( _.strCount( op.output, 'module-' ), 6 );
    test.identical( _.strLinesCount( op.output ), 8 );

    test.identical( _.strCount( op.output, 'eachList/.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'module-x' ), 1 );
    test.identical( _.strCount( op.output, 'eachList/a.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'module-a' ), 2 );
    test.identical( _.strCount( op.output, 'eachList/ab-named.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'module-ab-named' ), 1 );
    test.identical( _.strCount( op.output, 'eachList/b.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'module-b' ), 2 );
    test.identical( _.strCount( op.output, 'eachList/bc-named.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'module-bc-named' ), 1 );
    test.identical( _.strCount( op.output, 'eachList/c.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'module-c' ), 1 );

    return null;
  })

  /* - */

  a.appStart({ args : '.imply v:1 ; .each . .resources.list path::module.common' })
  .finally( ( err, op ) =>
  {
    test.case = '.imply v:1 ; .each . .resources.list path::module.common';
    test.true( !err );
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Module at' ), 0 );
    test.identical( _.strCount( op.output, a.routinePath ), 6 );
    test.identical( _.strLinesCount( op.output ), 8 );

    test.identical( _.strCount( op.output, a.routinePath + '/' ), 6 );
    test.identical( _.strCount( op.output, a.routinePath + '/a' ), 2 );
    test.identical( _.strCount( op.output, a.routinePath + '/ab-named' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/b' ), 2 );
    test.identical( _.strCount( op.output, a.routinePath + '/bc-named' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/c' ), 1 );

    return null;
  })

  /* - */

  a.appStart({ args : '.imply v:1 ; .each * .resources.list path::module.common' })
  .finally( ( err, op ) =>
  {
    test.case = '.imply v:1 ; .each * .resources.list path::module.common';
    test.true( !err );
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Module at' ), 0 );
    test.identical( _.strCount( op.output, a.routinePath ), 6 );
    test.identical( _.strLinesCount( op.output ), 8 );

    test.identical( _.strCount( op.output, a.routinePath + '/' ), 6 );
    test.identical( _.strCount( op.output, a.routinePath + '/a' ), 2 );
    test.identical( _.strCount( op.output, a.routinePath + '/ab-named' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/b' ), 2 );
    test.identical( _.strCount( op.output, a.routinePath + '/bc-named' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/c' ), 1 );

    return null;
  })

  /* - */

  a.appStart({ args : '.imply v:1 ; .each */* .resources.list path::module.common' })
  .finally( ( err, op ) =>
  {
    test.case = '.imply v:1 ; .each */* .resources.list path::module.common';
    test.true( !err );
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Module at' ), 0 );
    test.identical( _.strCount( op.output, a.routinePath ), 9 );
    test.identical( _.strLinesCount( op.output ), 11 );

    test.identical( _.strCount( op.output, a.routinePath + '/' ), 9 );
    test.identical( _.strCount( op.output, a.routinePath + '/a' ), 5 );
    test.identical( _.strCount( op.output, a.routinePath + '/ab-named' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/b' ), 2 );
    test.identical( _.strCount( op.output, a.routinePath + '/bc-named' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/c' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/aabc' ), 1 );
    test.identical( _.strCount( op.output, a.routinePath + '/ab' ), 3 );
    test.identical( _.strCount( op.output, a.routinePath + '/abac' ), 1 );

    return null;
  })

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    return a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.fileRename({ srcPath : a.abs( 'aab' ), dstPath : a.abs( '-aab' ) });
      return null;
    });
  }
}

commandEachList.timeOut = 300000;

//

function commandEachBrokenIll( test )
{
  let context = this;
  let a = context.assetFor( test, 'eachBroken' );
  a.reflect();

  /* - */

  a.appStartNonThrowing({ args : '.imply v:1 ; .each */* .resources.list path::module.common' })
  .finally( ( err, op ) =>
  {
    test.case = '.imply v:1 ; .each */* .resources.list path::module.common';
    test.true( !err );
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Failed to resolve' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open willfile' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

commandEachBrokenIll.description =
`
if one or several willfiles are broken .each should pass it and output error
`;

//

/*
utility should not try to open non-willfiles
*/

function commandEachBrokenNon( test )
{
  let context = this;
  let a = context.assetFor( test, 'openNonWillfile' );
  a.reflect();

  /* - */

  a.appStartNonThrowing({ args : '.each */* .paths.list' })
  .finally( ( err, op ) =>
  {
    test.case = '.each */* .paths.list';
    test.true( !err );
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Read 1 willfile' ), 1 );
    // test.identical( _.strCount( op.output, 'Module at' ), 1 );
    test.identical( _.strCount( op.output, 'Paths' ), 1 );
    return null;
  })

  /* - */

  return a.ready;
}

//

/*
utility should handle properly illformed second command
tab should not be accumulated in the output
*/

function commandEachBrokenCommand( test )
{
  let context = this;
  let a = context.assetFor( test, 'exportWithSubmodulesFew' );
  a.reflect();
  a.fileProvider.filesDelete( a.abs( 'out' ) );

  /* - */

  a.appStartNonThrowing( `.each */* .resources path::module.common` );
  a.ready.then( ( op ) =>
  {
    test.case = '.each */* .resources path::module.common';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'nhandled' ), 0 );
    test.identical( _.strCount( op.output, 'ncaught' ), 0 )
    test.identical( _.strCount( op.output, 'Ambiguity ".resources"' ), 1 );
    test.identical( _.strCount( op.output, '      ' ), 0 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandHookCallWithHookInfo( test )
{
  let context = this;
  let a = context.assetFor( test, 'dos' );
  a.reflect();

  /* - */

  a.appStart( '.clean' );
  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.case = 'setup';
    a.fileProvider.fileAppend( a.abs( 'will.yml' ), '\n' );

    test.true( a.fileProvider.fileExists( a.abs( 'out/proto' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/dos.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12' ) ) );

    return null;
  });

  /* */

  a.appStart( '.hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 1 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with . .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.with . .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 1 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with * .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.with . .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 7 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 1 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with ** .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.with . .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 9 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 1 );
    // test.identical( _.strCount( op.output, 'local :' ), 7 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.imply withOut:0 ; .with ** .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.imply withOut:0 ; .with ** .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, '! Outdated' ), 0 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 1 );
    test.identical( _.strCount( op.output, 'local :' ), 7 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.imply withIn:0 ; .with ** .hook.call info.js' )
  .then( ( op ) =>
  {
    test.case = '.imply withIn:0 ; .with ** .hook.call info.js';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 3 );
    test.identical( _.strCount( op.output, '! Outdated' ), 1 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 0 );
    test.identical( _.strCount( op.output, 'local :' ), 4 );
    test.identical( _.strCount( op.output, 'Done hook::info.js in' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

commandHookCallWithHookInfo.rapidity = -1;
commandHookCallWithHookInfo.timeOut = 600000;
commandHookCallWithHookInfo.description =
`
- do execute js script
- filtering option withIn works
- filtering option withOut works
- only one attempt to open outdate outfile
- action info works properly
- message with time printed afterwards
`

//

function commandDoWithHookStatus( test )
{
  let context = this;
  let a = context.assetFor( test, 'dos' );

  /* - */

  a.ready.then( ( op ) =>
  {
    test.case = 'setup';
    a.reflect();
    a.shell({ execPath : 'git init', currentPath : a.abs( 'disabled' ) });

    return null;
  });

  /* */

  a.appStart( '.clean' );
  a.appStart( '.export' )
  .then( ( op ) =>
  {
    test.case = 'setup';

    test.true( a.fileProvider.fileExists( a.abs( 'out/proto' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/dos.out.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting1' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting2a' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.module/ModuleForTesting12' ) ) );

    return null;
  });

  /* */

  a.appStart( '.hooks.list' )
  .then( ( op ) =>
  {
    test.case = 'hooks list';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '/status.js' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with ** .do ./.will/hook/status.js' )
  .then( ( op ) =>
  {
    test.case = 'no changes';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 10 );
    test.identical( _.strCount( op.output, '! Outdated' ), 0 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 1 );
    return null;
  });

  /* */

  a.ready.then( ( op ) =>
  {
    test.case = 'changes';
    a.fileProvider.fileAppend( a.abs( '.module/ModuleForTesting1/Readme.md' ), '\n' );
    a.fileProvider.fileAppend( a.abs( '.module/ModuleForTesting2a/Readme.md' ), '\n' );
    a.fileProvider.fileAppend( a.abs( '.module/ModuleForTesting12/License' ), '\n' );
    return null;
  });

  a.appStart( '.with ** .do ./.will/hook/status.js' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 10 );
    test.identical( _.strCount( op.output, '! Outdated' ), 0 );
    test.identical( _.strCount( op.output, 'Willfile should not have section' ), 1 );
    test.identical( _.strCount( op.output, /module::\w+ at / ), 3 );
    test.identical( _.strCount( op.output, 'module at' ), 2 );

    test.identical( _.strCount( op.output, 'M ' ), 3 );
    return null;
  });

  /* - */

  return a.ready;
}

commandDoWithHookStatus.rapidity = -1;
commandDoWithHookStatus.timeOut = 600000;
commandDoWithHookStatus.description =
`
- it.shell exposed for action
- it.shell has proper current path
- errorors are brief
`;

//

function commandSubmodulesClean( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesClean' );

  /* - */

  begin();
  a.appStart( '.build clean.and.update.recursive.1' )
  .then( ( op ) =>
  {
    test.case = 'build config, clean submodules and run submodules.update with recursive : 1'
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated / ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    return null;
  });

  /* */

  begin();
  a.appStart( '.build clean.and.update.recursive.2' )
  .then( ( op ) =>
  {
    test.case = 'build config, clean submodules and run submodules.update with recursive : 2'
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated / ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    return null;
  });

  /* */

  begin();
  a.appStart( '.clean.submodules .submodules.update recursive:1' )
  .then( ( op ) =>
  {
    test.case = 'commands, clean submodules and run submodules.update with recursive : 1'
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated / ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    return null;
  });

  /* */

  begin();
  a.appStart( '.clean.submodules .submodules.update recursive:2' )
  .then( ( op ) =>
  {
    test.case = 'commands, clean submodules and run submodules.update with recursive : 2'
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\+ 1\/1 submodule\(s\) of .* were updated / ), 1 );
    let modules = a.fileProvider.dirRead( a.abs( '.module' ) );
    test.identical( modules, [ 'ModuleForTesting2' ] );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    const modulePath = a.abs( '../-repo/ModuleForTesting2/' );
    a.ready.then( () => a.reflect() );
    a.shell({ currentPath : modulePath, execPath : 'git checkout master' });
    a.ready.then( () =>
    {
      const configPath = a.abs( modulePath, 'will.yml' );
      const config = a.fileProvider.fileReadUnknown( configPath );
      config.submodule.wModuleForTesting1.enabled = 1;
      a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
      return null;
    });
    a.shell({ currentPath : modulePath, execPath : 'git add .' });
    a.shell({ currentPath : modulePath, execPath : 'git commit -am enabled' });
    return a.ready;
  }
}

//

function commandSubmodulesShell( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesShell' );
  a.reflect();

  /* - */

  a.appStart( '.with ./* .submodules .shell ls' )
  .then( ( op ) =>
  {
    test.case = '.with ./* .submodules .shell ls - without submodules, no executed commands';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.identical( _.strCount( op.output, '> ls' ), 0 );
    test.identical( _.strCount( op.output, 'wModuleForTesting1.out.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'wModuleForTesting2.out.will.yml' ), 0 );

    return null;
  });

  /* */

  a.appStart( '.with ./* .submodules.download' );
  a.appStart( '.with ./* .submodules .shell ls' )
  .then( ( op ) =>
  {
    test.case = '.with ./* .submodules .shell ls - with submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '> ls' ), 2 );
    test.identical( _.strCount( op.output, 'wModuleForTesting1.out.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'wModuleForTesting2.out.will.yml' ), 1 );

    return null;
  });

  /* */

  a.appStart( '.with ./* .submodules.download' );
  a.appStart( '.imply withSubmodules:0 .with ./* .submodules .shell ls' )
  .then( ( op ) =>
  {
    test.case = '.imply withSubmodules:0 .with ./* .submodules .shell ls - disabled submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '> ls' ), 0 );
    test.identical( _.strCount( op.output, 'wModuleForTesting1.out.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'wModuleForTesting2.out.will.yml' ), 0 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandSubmodulesGit( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git status - committing and pushing, without remote submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.with original/ .submodules .git status profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 0 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .submodules .git.sync -am "new lines" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.with original/GitSync .submodules .git add --all' );
  // a.appStart( `.with original/GitSync .imply profile:${ profile } .submodules .git commit -am "new lines" hardLinkMaybe:1` )
  a.appStart( `.with original/GitSync .submodules .git commit -am "new lines" profile:${ profile } hardLinkMaybe:1` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'module::local' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "new lines"' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 1 );
    return null;
  });
  a.appStart( '.with original/GitSync .submodules .git push --all' )
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .submodules .git commit -am "new lines"';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });

  // a.appStart( `.imply withSubmodules:0 profile:${ profile } .with original/GitSync .submodules .git commit -am "new lines2"` )
  a.appStart( `.imply withSubmodules:0 .with original/GitSync .submodules .git commit -am "new lines2" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'module::local' ), 0 );
    test.identical( _.strCount( op.output, '> git commit -am "new lines2"' ), 0 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });
  a.appStart( '.imply .with original/GitSync .submodules .git push --all' )
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines2' ), 0 );
    return null;
  });

  /* */

  begin();
  // a.appStart( `.with original/GitSync .imply profile:${ profile } .submodules .git remote add origin1 https://github.com/user/{about::name}.git` )
  a.appStart( `.with original/GitSync .submodules .git remote add origin1 https://github.com/user/{about::name}.git profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/GitSync .modules .git remote add origin1 https://github.com/user/{about::name}.git';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'module::local' ), 1 );
    test.identical( _.strCount( op.output, '> git remote add origin1 https://github.com/user' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git remote -v' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'origin1\thttps://github.com/user/git-sync.git' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original/.local' ), execPath : 'git remote -v' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /origin1.*github.com.user\/local.git/ ), 2 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.dirMake( a.abs( 'repo2' ) );
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell({ currentPath : a.abs( 'repo2' ), execPath : 'git init --bare' });

    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );

    currentPath = a.abs( 'original/.local' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../../repo2' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

commandSubmodulesGit.rapidity = -1;

//

function commandSubmodulesGitRemoteSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGit' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git status - without remote git submodule';
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.submodules .git status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 1 );
    test.identical( _.strCount( op.output, 'On branch master' ), 0 );
    test.identical( _.strCount( op.output, '> git status' ), 0 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git status - with remote git submodule';
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.build' );
  a.appStart( '.submodules .git status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 0 );
    test.identical( _.strCount( op.output, 'On branch master\nChanges not staged for commit:' ), 0 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting12' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 1 );
    test.identical( _.strCount( op.output, 'On branch master' ), 1 );
    test.identical( _.strCount( op.output, /Your branch is up.*to.*date with 'origin\/master'\./ ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell( 'git init' );
    a.shell( 'git add --all' );
    a.shell( 'git commit -am first' );
    a.shell( 'git remote add origin repo/' );
    return a.ready;
  }
}

//

function commandSubmodulesGitRemoteSubmodulesRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGit' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.submodules .git status' )
  .then( ( op ) =>
  {
    test.case = '.submodules .git status - without remote git submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 1 );
    test.identical( _.strCount( op.output, 'On branch master' ), 0 );
    test.identical( _.strCount( op.output, '> git status' ), 0 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.submodules.download recursive:2' );
  a.appStart( '.submodules .git status' )
  .then( ( op ) =>
  {
    test.case = '.submodules .git status - with remote git submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 0 );
    test.identical( _.strCount( op.output, 'On branch master\nChanges not staged for commit:' ), 0 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting12' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 1 );
    test.identical( _.strCount( op.output, 'On branch master' ), 1 );
    test.identical( _.strCount( op.output, /Your branch is up.*to.*date with 'origin\/master'\./ ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell( 'git init' );
    a.shell( 'git add --all' );
    a.shell( 'git commit -am first' );
    a.shell( 'git remote add origin repo/' );
    return a.ready;
  }
}

//

function commandSubmodulesGitDiff( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGitSync' );

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff - no diffs';
    return null;
  });

  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add .' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -m second' });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff v:0 - no diffs, verbosity - 0';
    return null;
  });

  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add .' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -m second' });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff - with diffs in root module';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 0 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 0 );
    test.identical( _.strCount( op.output, 'f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'f2.txt' ), 0 );
    test.identical( _.strCount( op.output, 'Patch:' ), 0 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+new line' ), 0 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 0 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 0 );
    test.identical( _.strCount( op.output, '+another new line' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff v:0 - with diffs in root module';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 0 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 0 );
    test.identical( _.strCount( op.output, 'f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'f2.txt' ), 0 );
    test.identical( _.strCount( op.output, 'Patch:' ), 0 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+new line' ), 0 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 0 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 0 );
    test.identical( _.strCount( op.output, '+another new line' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff - with diffs in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff v:0 - with diffs in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff - with diffs in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.identical( _.strCount( op.output, 'f1.txt' ), 0 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+new line' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.submodules .git.diff v:0 - with diffs in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.submodules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".submodules .git.diff"' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.identical( _.strCount( op.output, 'f1.txt' ), 0 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '+new line' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflectMinimal();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    a.ready.then( () =>
    {
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( '.original/GitSync.will.yml' ) ] : a.abs( 'clone/GitSync.will.yml' ) } });
      return null;
    });
    return a.ready;
  }
}

commandSubmodulesGitDiff.rapidity = -1;

//

function commandSubmodulesGitStatusWithOnlyRoot( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - local and remote commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );
    return a.ready;
  }
}

//

function commandSubmodulesGitStatus( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGitSync' );

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - changes in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - changes in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - changes in submodule and remote commits in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status - changes in root and remote commits in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status local:0 - checks no local changes, local changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status local:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status local:0 - checks no local changes, local changes in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status local:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 0 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status remote:0 - checks no remote changes, unpulled commit in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status remote:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status remote:0 - checks no remote changes, unpulled commit in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status remote:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status uncommittedIgnored:1 - checks ignored uncommited, ignored in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status uncommittedIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status uncommittedIgnored:1 - checks ignored uncommited, ignored in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status uncommittedIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status uncommittedIgnored:0 - checks without ignored uncommited, ignored in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status uncommittedIgnored:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status uncommittedIgnored:0 - checks without ignored uncommited, ignored in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status uncommittedIgnored:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status remoteBranches:1 - checks with remote branches, changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status remoteBranches:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.status remoteBranches:1 - checks with remote branches, changes in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .submodules .git.status remoteBranches:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    a.ready.then( () =>
    {
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( '.original/GitSync.will.yml' ) ] : a.abs( 'clone/GitSync.will.yml' ) } });
      return null;
    });
    return a.ready;
  }
}

commandSubmodulesGitStatus.rapidity = -1;
commandSubmodulesGitStatus.timeOut = 500000;

//

function commandSubmodulesGitSync( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.sync - committing and pushing, without remote submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.with original/ .submodules .git.sync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\s\./ ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.with original/GitSync .submodules .git.sync -am "new lines" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/GitSync .submodules .git.sync -am "new lines" - committing and pushing with local submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:0 .with original/GitSync .submodules .git.sync -am "new lines2" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  // a.appStart( `.imply withSubmodules:0 profile:${ profile } .with original/GitSync .submodules .git.sync -am "new lines2"` )
  a.appStart( `.imply withSubmodules:0 .with original/GitSync .submodules .git.sync -am "new lines2" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines2' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.dirMake( a.abs( 'repo2' ) );
      return null;
    });

    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell({ currentPath : a.abs( 'repo2' ), execPath : 'git init --bare' });

    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );

    currentPath = a.abs( 'original/.local' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../../repo2' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

commandSubmodulesGitSync.rapidity = -1;

//

function commandSubmodulesRepoPullOpen( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'gitPush' );
  const user = 'wtools-bot';
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  a.reflect();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : `git remote add origin https://github.com/${ user }/New2` });

  /* - */

  a.appStartNonThrowing( '.with original/Git.* .submodules .repo.pull.open "some title" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, not throwing - without submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to submodules git pr open at' ), 0 );
    return null;
  });

  /* */

  a.appStart( '.with original/Git.* .submodules.download' );
  a.appStartNonThrowing( '.with original/Git.* .submodules .repo.pull.open "some title" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* */

  a.appStartNonThrowing( '.with original/Git.* .submodules .repo.pull.open "some title" srcBranch:new token:"token"' )
  .then( ( op ) =>
  {
    test.case = 'direct declaration of token, wrong data, not throwing - executes not submodules';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandModulesUpdate( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesUpdate' );

  a.remotePath = a.abs( 'module' );
  a.appStart.predefined.currentPath = a.abs( 'clone' );
  a.appStartNonThrowing.predefined.currentPath = a.abs( 'clone' );

  a.shellSync = _.process.starter
  ({
    currentPath : a.abs( '.' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.shellSyncClone = _.process.starter
  ({
    currentPath : a.abs( 'clone' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.shellSyncSubmodule = _.process.starter
  ({
    currentPath : a.abs( 'clone/.module/ModuleForTesting1' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.moduleShellSync = _.process.starter
  ({
    currentPath : a.remotePath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.init = ( o ) =>
  {
    o = o || {}

    a.ready.then( () =>
    {
      test.case = _.entity.exportString( o );

      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();
      a.moduleShellSync( 'git init' )
      a.fileProvider.fileWrite({ filePath : a.abs( 'module/.gitignore' ), data : '.module' });
      a.moduleShellSync( 'git add -fA .' )
      a.moduleShellSync( 'git commit -m initial' )
      a.moduleShellSync( 'git tag gamma' )
      a.shellSync( 'git clone module clone' )

      if( o.rootLocalChange )
      a.fileProvider.fileWrite({ filePath : a.abs( 'clone/file' ), data : 'file' });

      return null;
    })

    if( o.downloadSubmodules )
    {
      a.appStart( '.submodules.download' );

      if( o.submoduleLocalChange )
      a.ready.then( () =>
      {
        a.fileProvider.fileWrite
        ({
           filePath : a.abs( 'clone/.module/ModuleForTesting1/file' ),
           data : 'file'
        });
        return null;
      })
    }

    return a.ready;
  }

  /* */

  a.init({ case : 'update downloads submodules', downloadSubmodules : 0 })
  a.appStart( '.modules.update' )
  .then( ( op ) =>
  {
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting1' ] );
    return null;
  })

  /* */

  a.init({ case : 'update downloads submodules', downloadSubmodules : 1 })
  a.appStart( '.modules.update' )
  .then( ( op ) =>
  {
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting1' ] );
    return null;
  })

  /* */

  a.init({ case : 'update downloads submodules and checkouts root and submodules to specified tag', downloadSubmodules : 0 })
  a.appStart( '.modules.update to:!gamma' )
  .then( ( op ) =>
  {
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting1' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    return null;
  })

  /* */

  a.init({ case : 'update checkouts root and submodules to specified tag', downloadSubmodules : 1 })
  a.appStart( '.modules.update to:!gamma' )
  .then( ( op ) =>
  {
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting1' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    return null;
  })

  /* */

  a.init({ case : 'update gives error if root has local changes', downloadSubmodules : 1, rootLocalChange : 1 })
  a.appStartNonThrowing( '.modules.update to:!gamma' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'needs to be updated, but has local changes' ) );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting1' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  })

  /* */

  a.init({ case : 'update gives error if root has local changes', downloadSubmodules : 1, submoduleLocalChange : 1 })
  a.appStartNonThrowing( '.modules.update to:!gamma' )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'needs to be updated, but has local changes' ) );
    let modules = a.fileProvider.dirRead( a.abs( 'clone/.module' ) );
    test.identical( modules, [ 'ModuleForTesting1' ] );
    var got = a.shellSyncClone( 'git status' );
    test.true( _.strHas( got.output, `HEAD detached at gamma` ) );
    var got = a.shellSyncSubmodule( 'git status' );
    test.true( _.strHas( got.output, `On branch master` ) );
    return null;
  })

  /* */

  return a.ready;
}

//

function commandModulesShell( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesShell' );
  a.reflect();

  /* - */

  a.appStart( '.with ./* .modules .shell ls' )
  .then( ( op ) =>
  {
    test.case = '.with ./* .modules .shell ls - without submodules, no executed commands';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 2 );
    test.identical( _.strCount( op.output, '> ls' ), 2 );
    test.identical( _.strCount( op.output, 'Named.will.yml' ), 3 );
    test.identical( _.strCount( op.output, 'wModuleForTesting1.out.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'wModuleForTesting2.out.will.yml' ), 0 );

    return null;
  });

  /* */

  a.appStart( '.with ./* .submodules.download' );
  a.appStart( '.with ./* .modules .shell ls' )
  .then( ( op ) =>
  {
    test.case = '.with ./* .modules .shell ls - with submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 6 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '> ls' ), 4 );
    test.identical( _.strCount( op.output, 'Named.will.yml' ), 3 );
    test.identical( _.strCount( op.output, 'wModuleForTesting1.out.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'wModuleForTesting2.out.will.yml' ), 1 );

    return null;
  });

  /* */

  a.appStart( '.with ./* .submodules.download' );
  a.appStart( '.imply withSubmodules:0 .with ./* .modules .shell ls' )
  .then( ( op ) =>
  {
    test.case = '.imply withSubmodules:0 .with ./* .modules .shell ls - disabled submodules';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, '> ls' ), 2 );
    test.identical( _.strCount( op.output, 'Named.will.yml' ), 3 );
    test.identical( _.strCount( op.output, 'wModuleForTesting1.out.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'wModuleForTesting2.out.will.yml' ), 0 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandModulesGit( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .modules .git status - committing and pushing, without remote submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.with original/ .modules .git status profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, '> git status' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .modules .git.sync -am "new lines" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.with original/GitSync .modules .git add --all' );
  a.appStart( '.with original/GitSync .modules .git commit -am "new lines"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'module::local' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "new lines"' ), 2 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });
  a.appStart( '.with original/GitSync .modules .git push --all' )
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:0 .with original/GitSync .modules .git commit -am "new lines2"';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.appStart( '.imply withSubmodules:0 .with original/GitSync .modules .git commit -am "new lines2"' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'module::local' ), 0 );
    test.identical( _.strCount( op.output, '> git commit -am "new lines2"' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });
  a.appStart( '.imply .with original/GitSync .modules .git push --all' )
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines2' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/GitSync .modules .git remote add origin1 https://github.com/user/{about::name}.git' )
  .then( ( op ) =>
  {
    test.case = '.with original/GitSync .modules .git remote add origin1 https://github.com/user/{about::name}.git';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'module::local' ), 1 );
    test.identical( _.strCount( op.output, '> git remote add origin1 https://github.com/user' ), 2 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git remote -v' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /origin1.*github.com.user\/git-sync\.git/ ), 2 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original/.local' ), execPath : 'git remote -v' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /origin1.*github.com.user\/local\.git/ ), 2 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.dirMake( a.abs( 'repo2' ) );
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell({ currentPath : a.abs( 'repo2' ), execPath : 'git init --bare' });

    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );

    currentPath = a.abs( 'original/.local' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../../repo2' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

commandModulesGit.rapidity = -1;

//

function commandModulesGitOutputFormat( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandModulesGitStatusOutputFormat' );

  /* */

  begin().then( () =>
  {
    test.case = 'output of git status has indentation, there is an empty line before output of each module'
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting1/proto/wtools/testing/l1/Include.s' ), 'testData' );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2/proto/Integration.test.ss' ), 'testData' );
    return null;
  });

  a.appStart( '.modules .git status hardLinkMaybe:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '\nmodule::wModuleForTesting1 at' ), 1 );
    test.identical( _.strCount( op.output, '\nmodule::wModuleForTesting2 at' ), 1 );
    test.identical( _.strCount( op.output, '  Restoring hardlinks in directory(s) :' ), 2 );
    test.identical( _.strCount( op.output, `    ${a.abs( '.module/ModuleForTesting1' )}` ), 1 );
    test.identical( _.strCount( op.output, `    ${a.abs( '.module/ModuleForTesting2' )}` ), 1 );
    test.identical( _.strCount( op.output, '  On branch master' ), 2 );
    test.identical( _.strCount( op.output, ' + Restored 0 hardlinks' ), 2 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      return null;
    });

    a.appStart( '.submodules.download' );

    return a.ready;
  }
}

//

function commandModulesGitRemoteSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGit' );
  a.reflect();

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  })

  a.appStart( '.modules .git status' )
  .then( ( op ) =>
  {
    test.case = '.modules .git status - without remote git submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 2 );
    test.identical( _.strCount( op.output, 'On branch master' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 1 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  })
  a.appStart( '.build' );
  a.appStart( '.modules .git status' )
  .then( ( op ) =>
  {
    test.case = '.modules .git status - with remote git submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 1 );
    test.identical( _.strCount( op.output, /On branch master\n\s*Changes not staged for commit:/ ), 1 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting12' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 2 );
    test.identical( _.strCount( op.output, 'On branch master' ), 2 );
    test.identical( _.strCount( op.output, /Your branch is up.*to.*date with 'origin\/master'\./ ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.shell( 'git init' );
    a.shell( 'git add --all' );
    a.shell( 'git commit -am first' );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell( 'git remote add origin repo/' );
    return a.ready;
  }
}

//

function commandModulesGitRemoteSubmodulesRecursive( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGit' );
  a.reflect();

  /* */

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.modules .git status' )
  .then( ( op ) =>
  {
    test.case = '.modules .git status - without remote git submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 2 );
    test.identical( _.strCount( op.output, 'On branch master' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 1 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( '.submodules.download recursive:2' );
  a.appStart( '.modules .git status' )
  .then( ( op ) =>
  {
    test.case = '.modules .git status - with remote git submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::modulesGit' ), 1 );
    test.identical( _.strCount( op.output, /On branch master\n\s*Changes not staged for commit:/ ), 1 );
    test.identical( _.strCount( op.output, 'modified:   f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'module::wModuleForTesting12' ), 1 );
    test.identical( _.strCount( op.output, '> git status' ), 2 );
    test.identical( _.strCount( op.output, 'On branch master' ), 2 );
    test.identical( _.strCount( op.output, /Your branch is up.*to.*date with 'origin\/master'\./ ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.shell( 'git init' );
    a.shell( 'git add --all' );
    a.shell( 'git commit -am first' );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell( 'git remote add origin repo/' );
    return a.ready;
  }
}

//

function commandModulesGitDiff( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGitSync' );

  /* - */

  begin().then( () =>
  {
    test.case = '.modules .git.diff - no diffs';
    return null;
  });

  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add .' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -m second' });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.modules .git.diff v:0 - no diffs, verbosity - 0';
    return null;
  });

  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git add .' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -m second' });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.modules .git.diff - with diffs in root module';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.modules .git.diff v:0 - with diffs in root module';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.modules .git.diff - with diffs in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.modules .git.diff v:0 - with diffs in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.modules .git.diff - with diffs in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'Status:' ), 2 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 2 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 2 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.modules .git.diff v:0 - with diffs in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.modules .git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".modules .git.diff"' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 2 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 2 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 2 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::GitSync at' ), 0 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflectMinimal();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    a.ready.then( () =>
    {
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( '.original/GitSync.will.yml' ) ] : a.abs( 'clone/GitSync.will.yml' ) } });
      return null;
    });
    return a.ready;
  }
}

commandModulesGitDiff.rapidity = -1;

//

function commandModulesGitDiffOutputFormat( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandModulesGitStatusOutputFormat' );

  /* */

  begin().then( () =>
  {
    test.case = 'output of git diff has indentation, there is an empty line before output of each module'
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting1/proto/wtools/testing/l1/ModuleForTesting1.s' ), 'testData' );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2/proto/wtools/testing/Common.s' ), 'testData' );
    return null;
  });

  a.appStart( '.modules .git.diff' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '\nDiff of module::wModuleForTesting1 at' ), 1 );
    test.identical( _.strCount( op.output, '\nDiff of module::wModuleForTesting2 at' ), 1 );
    test.identical( _.strCount( op.output, '  Status:' ), 2 );
    test.identical( _.strCount( op.output, '  Patch:' ), 2 );
    test.identical( _.strCount( op.output, '    modifiedFiles:' ), 2 );
    test.identical( _.strCount( op.output, '      proto/wtools/testing/l1/ModuleForTesting1.s' ), 1 );
    test.identical( _.strCount( op.output, '      proto/wtools/testing/Common.s' ), 1 );
    test.identical( _.strCount( op.output, '    diff --git a/proto/wtools/testing/l1/ModuleForTesting1.s b/proto/wtools/testing/l1/ModuleForTesting1.s' ), 1 );
    test.identical( _.strCount( op.output, '    diff --git a/proto/wtools/testing/Common.s b/proto/wtools/testing/Common.s' ), 1 );
    test.identical( _.strCount( op.output, '    +testData' ), 2 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      return null;
    });

    a.appStart( '.submodules.download' );

    return a.ready;
  }
}

//

function commandModulesGitStatusWithOnlyRoot( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - local and remote commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status local:0 - checks no local changes';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status local:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status remote:0 - checks no local changes';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status remote:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status uncommittedIgnored:1 - checks ignored uncommited';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status uncommittedIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status uncommittedIgnored:0 - checks without ignored';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status uncommittedIgnored:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status remoteBranches:1 - checks with remote branches';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status remoteBranches:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );
    return a.ready;
  }
}

commandModulesGitStatusWithOnlyRoot.rapidity = -1;

//

function commandModulesGitStatus( test )
{
  let context = this;
  let a = context.assetFor( test, 'modulesGitSync' );

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - changes in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - changes in root module and submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - changes in submodule and remote commits in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status - changes in root and remote commits in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status local:0 - checks no local changes, local changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status local:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status local:0 - checks no local changes, local changes in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status local:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 0 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status remote:0 - checks no remote changes, unpulled commit in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status remote:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status remote:0 - checks no remote changes, unpulled commit in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status remote:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status uncommittedIgnored:1 - checks ignored uncommited, ignored in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status uncommittedIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status uncommittedIgnored:1 - checks ignored uncommited, ignored in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status uncommittedIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status uncommittedIgnored:0 - checks without ignored uncommited, ignored in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status uncommittedIgnored:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status uncommittedIgnored:0 - checks without ignored uncommited, ignored in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status uncommittedIgnored:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status remoteBranches:1 - checks with remote branches, changes in submodule';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status remoteBranches:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 0 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  begin().then( () =>
  {
    test.case = '.with original .modules .git.status remoteBranches:1 - checks with remote branches, changes in root';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .modules .git.status remoteBranches:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'module::super at' ), 1 );
    test.identical( _.strCount( op.output, 'module::GitSync at' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 2 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '?? GitSync.will.yml' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    a.ready.then( () =>
    {
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( '.original/GitSync.will.yml' ) ] : a.abs( 'clone/GitSync.will.yml' ) } });
      return null;
    });
    return a.ready;
  }
}

commandModulesGitStatus.rapidity = -1;
commandModulesGitStatus.timeOut = 500000;

//

function commandModulesGitStatusOutputFormat( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandModulesGitStatusOutputFormat' );

  /* */

  begin().then( () =>
  {
    test.case = 'output of git status has indentation, there is an empty line before output of each module'
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting1/proto/wtools/testing/l1/ModuleForTesting1.s' ), 'testData' );
    a.fileProvider.fileWrite( a.abs( '.module/ModuleForTesting2/proto/wtools/testing/Common.s' ), 'testData' );
    return null;
  });

  a.appStart( '.modules .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.identical( _.strCount( op.output, '\nStatus of module::wModuleForTesting1 at' ), 1 );
    test.identical( _.strCount( op.output, '\nStatus of module::wModuleForTesting2 at' ), 1 );
    test.identical( _.strCount( op.output, '  List of uncommited changes in files:' ), 2 );
    test.identical( _.strCount( op.output, '    M proto/wtools/testing/l1/ModuleForTesting1.s' ), 1 );
    test.identical( _.strCount( op.output, '    M proto/wtools/testing/Common.s' ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.appStart( '.submodules.download' );
    return a.ready;
  }
}

//

function commandModulesGitSync( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.sync - committing and pushing, without remote submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( `.with original/ .modules .git.sync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\s\./ ), 1 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .modules .git.sync -am "new lines" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  })

  a.appStart( `.with original/GitSync .modules .git.sync -am "new lines" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines' ), 1 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:0 .with original/GitSync .modules .git.sync -am "new lines2" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  })

  // a.appStart( `.imply withSubmodules:0 profile:${ profile } .with original/GitSync .modules .git.sync -am "new lines2"` )
  a.appStart( `.imply withSubmodules:0 .with original/GitSync .modules .git.sync -am "new lines2" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines2' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.dirMake( a.abs( 'repo2' ) );
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell({ currentPath : a.abs( 'repo2' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );

    currentPath = a.abs( 'original/.local' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../../repo2' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

//

function commandModulesGitSyncRestoreHardLinksInModuleWithSuccess( test )
{
  let context = this;

  if( !_.censor || _.process.insideTestContainer() )
  return test.true( true );

  let temp = context.suiteTempPath;
  context.suiteTempPath = _.path.join( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe/willbe' ); /* Dmytro : suiteTempPath contains part and extension `tmp` that excludes by providerArchive filter */
  let a = context.assetFor( test, 'modulesGitSync' );

  let config = { path : { hlink : a.abs( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe' ) } };
  let profile = 'test-profile';
  let profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
  let configPath = a.abs( profileDir, 'config.yaml' );
  a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });

  let linkPath = config.path.hlink;

  /* - */

  begin().then( () =>
  {
    hardlink( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) );
    hardlink( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) );
    hardlink( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) );
    hardlink( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    a.fileProvider.fileAppend( a.abs( 'super/f2.txt' ), 'super\n' );
    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am third' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });
  a.ready.then( () =>
  {
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( '.original/GitSync.will.yml' ) ] : a.abs( 'clone/GitSync.will.yml' ) } });
    return null;
  });

  a.appStartNonThrowing( `.with super/ .modules .git.sync v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = 'without conflict';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, `Command ".with super/ .modules .git.sync v:5 profile:${ profile }"` ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::super' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::super' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::GitSync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::GitSync' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::GitSync' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink' ), 2 );
    test.identical( _.strCount( op.output, '+ Restored 2 hardlinks' ), 1 );

    test.false( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f2.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f2.txt
super
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  a.ready.finally( () =>
  {
    a.fileProvider.filesDelete( a.path.dir( context.suiteTempPath ) );
    a.fileProvider.filesDelete( profileDir );
    context.suiteTempPath = temp;
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    return a.ready;
  }

  /* */

  function hardlink( src, dst )
  {
    a.fileProvider.hardLink
    ({
      srcPath : src,
      dstPath : dst,
      sync : 1,
    });
  }
}

//

function commandModulesGitSyncRestoreHardLinksInModuleWithFail( test )
{
  let context = this;

  if( !_.censor )
  return test.true( true );

  let temp = context.suiteTempPath;
  context.suiteTempPath = _.path.join( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe/willbe' ); /* Dmytro : suiteTempPath contains part and extension `tmp` that excludes by providerArchive filter */
  let a = context.assetFor( test, 'modulesGitSync' );

  /* */

  let config = { path : { hlink : a.abs( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe' ) } };
  let profile = 'test-profile';
  let profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
  let configPath = a.abs( profileDir, 'config.yaml' );
  a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });

  let linkPath = config.path.hlink;

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( () =>
  {
    hardlink( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) );
    hardlink( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) );
    hardlink( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) );
    hardlink( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });
  a.ready.then( () =>
  {
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( '.original/GitSync.will.yml' ) ] : a.abs( 'clone/GitSync.will.yml' ) } });
    return null;
  })

  // a.appStartNonThrowing( `.with super/ .imply profile:${ profile } .modules .git.sync v:5` )
  a.appStartNonThrowing( `.with super/ .modules .git.sync v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    // test.identical( _.strCount( op.output, `Command ".with super/ .imply profile:${ profile } .modules .git.sync v:5"` ), 1 );
    test.identical( _.strCount( op.output, `Command ".with super/ .modules .git.sync v:5 profile:${ profile }"` ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::super' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::GitSync' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
    test.identical( _.strCount( op.output, '1 file changed, 1 insertion(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restoring hardlinks in directory(s) :\n' ), 1 );
    test.identical( _.strCount( op.output, '> git pull' ), 2 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 2 );
    test.identical( _.strCount( op.output, '+ Restored 2 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, 'Launched as "git pull"' ), 1 );

    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f2.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f2.txt
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.path.dir( context.suiteTempPath ) );
    a.fileProvider.filesDelete( profileDir );
    context.suiteTempPath = temp;
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    return a.ready;
  }

  /* */

  function hardlink( src, dst )
  {
    a.fileProvider.hardLink
    ({
      srcPath : src,
      dstPath : dst,
      sync : 1,
    });
  }
}

//

function commandModulesGitSyncRestoreHardLinksInModule( test )
{
  let context = this;

  if( !_.censor )
  return test.true( true );

  let temp = context.suiteTempPath;
  context.suiteTempPath = _.path.join( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe/willbe' ); /* Dmytro : suiteTempPath contains part and extension `tmp` that excludes by providerArchive filter */
  let a = context.assetFor( test, 'modulesGitSync' );

  /* */

  let config = { path : { hlink : a.abs( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe' ) } };
  let profile = 'test-profile';
  let profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
  let configPath = a.abs( profileDir, 'config.yaml' );
  a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });

  let linkPath = config.path.hlink;

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* */

  begin().then( () =>
  {
    hardlink( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) );
    hardlink( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) );
    hardlink( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) );
    hardlink( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );
    a.fileProvider.fileAppend( a.abs( 'super/f1.txt' ), 'super\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStartNonThrowing( `.with super/ .modules .git.sync v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, `Command ".with super/ .modules .git.sync v:5 profile:${ profile }"` ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::super' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
    test.identical( _.strCount( op.output, '1 file changed, 1 insertion(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restoring hardlinks in directory(s) :\n' ), 1 );
    test.identical( _.strCount( op.output, '> git pull' ), 1 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 1 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, 'Launched as "git pull"' ), 1 );

    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    var exp =
`
original/f.txt
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f2.txt
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
super
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'super/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f2.txt
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'super/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  })

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.path.dir( context.suiteTempPath ) );
    a.fileProvider.filesDelete( profileDir );
    context.suiteTempPath = temp;
    return null;
  });

  /* - */

  return a.ready;

  /* */
  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.fileRename({ srcPath : a.abs( 'original' ), dstPath : a.abs( '.original' ) });
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'super' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    a.shell( `git clone ./repo ./original` );
    return a.ready;
  }

  /* */

  function hardlink( src, dst )
  {
    a.fileProvider.hardLink
    ({
      srcPath : src,
      dstPath : dst,
      sync : 1,
    });
  }
}

//

function commandModulesGitSyncRestoreHardLinksInSubmodule( test )
{
  let context = this;

  if( !_.censor )
  return test.true( true );

  let temp = context.suiteTempPath;
  context.suiteTempPath = _.path.join( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe/willbe' ); /* Dmytro : suiteTempPath contains part and extension `tmp` that excludes by providerArchive filter */
  let a = context.assetFor( test, 'modulesGitSync' );

  /* */

  let config = { path : { hlink : a.abs( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe' ) } };
  let profile = 'test-profile';
  let profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
  let configPath = a.abs( profileDir, 'config.yaml' );
  a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });

  let linkPath = config.path.hlink;

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( () =>
  {
    hardlink( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) );
    hardlink( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) );
    hardlink( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) );
    hardlink( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    return null;
  })

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push' });

  a.appStartNonThrowing( `.with super/ .modules .git.sync v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, `Command ".with super/ .modules .git.sync v:5 profile:${ profile }"` ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::GitSync' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
    test.identical( _.strCount( op.output, '1 file changed, 1 insertion(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restoring hardlinks in directory(s) :\n' ), 1 );
    test.identical( _.strCount( op.output, '> git pull' ), 1 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 1 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, 'Launched as "git pull"' ), 1 );

    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f1.txt' ), a.abs( linkPath, 'f1_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'super/f2.txt' ), a.abs( linkPath, 'f2_.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    var exp =
`
original/f.txt
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  })

  a.ready.then( () =>
  {
    a.fileProvider.filesDelete( a.path.dir( context.suiteTempPath ) );
    a.fileProvider.filesDelete( profileDir );
    context.suiteTempPath = temp;
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell( `git clone ./repo ./clone` );
    return a.ready;
  }

  /* */

  function hardlink( src, dst )
  {
    a.fileProvider.hardLink
    ({
      srcPath : src,
      dstPath : dst,
      sync : 1,
    });
  }
}

//

function commandModules( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .modules .git.sync - committing and pushing, without remote submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( `.with original/ .modules .git.sync profile:${ profile }` );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\s\./ ), 1 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    test.case = '.with original/GitSync .modules .git.sync -am "new lines" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  })

  a.appStart( `.with original/GitSync .modules .git.sync -am "new lines" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines' ), 1 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:0 .with original/GitSync .modules .git.sync -am "new lines2" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  })

  a.appStart( `.imply withSubmodules:0 .with original/GitSync .modules .git.sync -am "new lines2" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines2' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.dirMake( a.abs( 'repo2' ) );
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell({ currentPath : a.abs( 'repo2' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );

    currentPath = a.abs( 'original/.local' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../../repo2' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

//

function commandSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .submodules .git.sync - committing and pushing, without remote submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.with original/ .submodules .git.sync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\s\./ ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.with original/GitSync .submodules .git.sync -am "new lines" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/GitSync .submodules .git.sync -am "new lines" - committing and pushing with local submodule';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 2 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 1 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.imply withSubmodules:0 .with original/GitSync .submodules .git.sync -am "new lines2" - committing and pushing with local submodule';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.local/f1.txt' ), 'new line\n' );
    return null;
  });
  a.appStart( `.imply withSubmodules:0 .with original/GitSync .submodules .git.sync -am "new lines2" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::git-sync' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::local' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::local' ), 0 );
    test.identical( _.strCount( op.output, 'To ../../repo2' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'new lines2' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      a.fileProvider.dirMake( a.abs( 'repo2' ) );
      return null;
    });

    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    a.shell({ currentPath : a.abs( 'repo2' ), execPath : 'git init --bare' });

    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );

    currentPath = a.abs( 'original/.local' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../../repo2' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    return a.ready;
  }
}

commandSubmodules.rapidity = -1;

//

function commandModulesRepoPullOpen( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'gitPush' );
  const user = 'wtools-bot';
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  a.reflect();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : `git remote add origin https://github.com/${ user }/New2` });

  /* - */

  a.appStartNonThrowing( '.with original/Git.* .modules .repo.pull.open "some title" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : \d+/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* */

  a.appStart( '.with original/Git.* .submodules.download' );
  a.appStartNonThrowing( '.with original/Git.* .modules .repo.pull.open "some title" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : \d+/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* */

  a.appStartNonThrowing( '.with original/Git.* .modules .repo.pull.open "some title" srcBranch:new token:"token"' )
  .then( ( op ) =>
  {
    test.case = 'direct declaration of token, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Failed to open module' ), 0 );

    test.identical( _.strCount( op.output, /Error code : \d+/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandGitCheckHardLinkRestoringThrowing( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );
  a.reflect();

  let config = _.censor.configRead();
  if( !config || !config.about || config.about.user !== 'wtools-bot' )
  return test.true( true );

  /* - */

  a.appStartNonThrowing( '.with original/Git.* .modules.repo.pull.open "some title" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open module' ), 1 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to modules git pr open at' ), 1 );

    return null;
  });

  /* */

  a.appStart( '.with original/Git.* .submodules.download' );
  a.appStartNonThrowing( '.with original/Git.* .modules.repo.pull.open "some title" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 4 );
    test.identical( _.strCount( op.output, 'Failed to open module' ), 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to modules git pr open at' ), 1 );

    return null;
  });

  /* */

  a.appStartNonThrowing( '.imply withSubmodules:0 .with original/Git.* .modules.repo.pull.open "some title" srcBranch:new token:"token"' )
  .then( ( op ) =>
  {
    test.case = 'direct declaration of token, withSubmodules:0, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open module' ), 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to modules git pr open at' ), 1 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandGitCheckHardLinkRestoring( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( ( op ) =>
  {
    test.case = '.git pull - succefull pulling';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  })

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.git pull hardLinkMaybe:1 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );
    return null;
  })

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.git pull v:0 - succefull pulling';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.git pull hardLinkMaybe:1 v:0 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::clone' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );
    return null;
  })

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart({ execPath : `.with clone/ .git pull hardLinkMaybe:1 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.case = '.with clone/ .git pull - succefull pulling with hardlinks';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );
    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink, succefull pulling';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    var exp =
`
original/f.txt
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  })

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink, succefull pulling';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .git pull hardLinkMaybe:1 v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'has local changes';
    test.notIdentical( op.exitCode, 0 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink, conflict';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .git pull hardLinkMaybe:1 v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.with clone/ .git pull withSubmodules:1 - succefull pulling';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  })

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart({ execPath : `.with clone/ .git pull hardLinkMaybe:1 withSubmodules:1 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  })

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.imply withSubmodules:2 .with clone/ .git pull - succefull pulling';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStart( `.imply withSubmodules:2 .with clone/ .git pull hardLinkMaybe:1 withSubmodules:1 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    return a.ready;
  }
}

commandGitCheckHardLinkRestoring.rapidity = -1;
commandGitCheckHardLinkRestoring.timeOut = 300000;

//

function commandGitDifferentCommands( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( ( op ) =>
  {
    test.case = '.git status';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'copy\n' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'clone' ), execPath : '.git status' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    // test.identical( _.strCount( op.output, 'Failed to open' ), 0 ); /* Dmytro : changed default value of withSubmodules in routine */
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, 'Changes not staged for commit' ), 1 );
    test.identical( _.strCount( op.output, 'modified' ), 2 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.git log v:0';
    return null;
  });

  a.appStart({ currentPath : a.abs( 'clone' ), execPath : '.git log v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'commit' ), 1 );
    test.identical( _.strCount( op.output, 'Author:' ), 1 );
    test.identical( _.strCount( op.output, 'Date:' ), 1 );
    test.identical( _.strCount( op.output, 'first' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );
    return null;
  })

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.git status';
    return null;
  });

  a.appStart({ currentPath : a.abs( 'clone' ), execPath : '.git log hardLinkMaybe:1' })
  .then( ( op ) =>
  {
    test.case = '.git log hardLinkMaybe:1';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, 'commit' ), 1 );
    test.identical( _.strCount( op.output, 'Author:' ), 1 );
    test.identical( _.strCount( op.output, 'Date:' ), 1 );
    test.identical( _.strCount( op.output, 'first' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );
    return null;
  })

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.git commit -am second';
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'copy\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f2.txt' ), 'copy\n' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'clone' ), execPath : '.git commit -am second' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    return a.ready;
  }
}

commandGitDifferentCommands.rapidity = -1;

//

function commandGitDiff( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    test.case = '.git.diff - no diffs';
    return null;
  });
  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::clone at' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.git.diff v:0 - no diffs, verbosity - 0';
    return null;
  });
  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".git.diff"' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::clone at' ), 0 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.git.diff - with diffs';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'another new line' );
    return null;
  });
  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.git.diff' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".git.diff"' ), 1 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Diff of module::clone at' ), 1 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.git.diff v:0 - with diffs';
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line' );
    a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'another new line' );
    return null;
  });

  a.appStart({ currentPath : a.abs( 'original' ), execPath : '.git.diff v:0' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Command ".git.diff"' ), 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Diff of module::clone at' ), 0 );
    test.identical( _.strCount( op.output, 'Status:' ), 1 );
    test.identical( _.strCount( op.output, 'modifiedFiles:' ), 1 );
    test.ge( _.strCount( op.output, 'f1.txt' ), 5 );
    test.ge( _.strCount( op.output, 'f2.txt' ), 5 );
    test.identical( _.strCount( op.output, 'Patch:' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '+new line' ), 1 );
    test.identical( _.strCount( op.output, '--- a/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+++ b/f2.txt' ), 1 );
    test.identical( _.strCount( op.output, '+another new line' ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git config core.autocrlf input' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.ready.then( ( op ) =>
    {
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
      return null;
    });
    a.shell({ currentPath, execPath : 'git commit -am second' });
    return a.ready;
  }
}

//

function commandGitPull( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  /* - */

  begin().then( () =>
  {
    test.case = '.git.pull - succefull pulling';
    return null;
  });

  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.git.pull profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.git.pull v:0 - succefull pulling';
    return null;
  });

  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.git.pull v:0 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 0 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    return null;
  });

  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.git.pull profile:${ profile }` })
  .then( ( op ) =>
  {
    test.case = '.with clone/ .git.pull - succefull pulling with hardlinks';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 1 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.description = 'hardlink, succefull pulling';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });
    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    var exp =
`
original/f.txt
copy
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.appStartNonThrowing( `.with clone/ .git.pull v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'has local changes';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
copy
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
copy
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.with clone/ .git.pull withSubmodules:1 - succefull pulling';
    return null;
  });

  a.appStart({ currentPath : a.abs( `clone` ), execPath : `.git.pull withSubmodules:1 profile:${ profile }` })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  begin().then( ( op ) =>
  {
    test.case = '.imply withSubmodules:2 .with clone/ .git.pull - succefull pulling';
    return null;
  });

  a.appStart( `.imply withSubmodules:2 .with clone/ .git.pull withSubmodules:1 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, 'Restored 0 hardlinks' ), 1 );

    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflectMinimal() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( ( op ) =>
    {
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'copy\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f2.txt' ), 'copy\n' );
      return null;
    });
    a.shell({ currentPath, execPath : 'git commit -am second' });
    return a.ready;
  }
}

commandGitPull.rapidity = -1;
commandGitPull.timeOut = 600000;

//

function commandGitPullRestoreHardlinkOnFail( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin();
  a.appStartNonThrowing( `.with clone/ .git.pull v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.description = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, ' > git pull' ), 1 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 1 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, 'Launched as "git pull"' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( ( op ) =>
    {
      a.reflectMinimal();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( ( op ) =>
    {
      a.fileProvider.hardLink
      ({
        srcPath : a.abs( 'clone/f1.txt' ),
        dstPath : a.abs( 'clone/f2.txt' ),
        sync : 1,
      });
      a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
      a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );
      return null;
    })
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
    a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am second' });
    return a.ready;
  }
}

//

function commandGitPush( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin();
  a.appStart( '.with original/ .git.push' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.push - succefull pushing of commit';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, ' * [new branch]      master -> master' ), 1 );
    test.identical( _.strCount( op.output, /Branch .*master.* set up to track remote branch .*master.* from .*origin.*/), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.push dry:1' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.push dry:1 - succefull dry pushing of commit';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    test.identical( _.strCount( op.output, '> git push --dry-run -u origin --all --force' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, ' * [new branch]      master -> master' ), 1 );
    test.identical( _.strCount( op.output, 'Would set upstream of \'master\' to \'master\' of \'origin\'' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.push' )
  a.appStart( '.with original/ .git.push' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.push - second run, nothing to push';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 0 );
    return null;
  });

  /* */

  begin();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -a v1.0 -m v1.0' });
  a.appStart( '.with original/ .git.push force:0' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.push v:0 force:0 - no force push';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    test.identical( _.strCount( op.output, ' > git push -u origin --all' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 2 );
    test.identical( _.strCount( op.output, ' * [new branch]      master -> master' ), 1 );
    test.identical( _.strCount( op.output, ' * [new tag]         v1.0 -> v1.0' ), 1 );
    // test.identical( _.strCount( op.output, 'Branch \'master\' set up to track remote branch \'master\' from \'origin\'.' ), 1 );
    test.identical( _.strCount( op.output, /Branch .*master.* set up to track remote branch .*master.* from .*origin.*/), 1 );
    return null;
  });

  /* */

  begin();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -a v1.0 -m v1.0' });
  a.appStart( '.with original/ .git.push withTags:0' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.push v:0 withTags:0 - push no tags';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    test.identical( _.strCount( op.output, ' > git push -u origin --all --force' ), 1 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 1 );
    test.identical( _.strCount( op.output, ' * [new branch]      master -> master' ), 1 );
    test.identical( _.strCount( op.output, ' * [new tag]         v1.0 -> v1.0' ), 0 );
    // test.identical( _.strCount( op.output, 'Branch \'master\' set up to track remote branch \'master\' from \'origin\'.' ), 1 );
    test.identical( _.strCount( op.output, /Branch .*master.* set up to track remote branch .*master.* from .*origin.*/), 1 );
    return null;
  });

  /* */

  begin();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -a v1.0 -m v1.0' });
  a.appStart( '.with original/ .git.push v:0' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.push v:0 - succefull pushing of tag';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'To ../repo' ), 2 );
    test.identical( _.strCount( op.output, ' * [new tag]         v1.0 -> v1.0' ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

//

function commandGitReset( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitReset' );

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .git.reset dirPath:{path::git.proto} - directory proto is not a git dir, no resetting';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with clone/ .git.reset dirPath:{path::git.proto}' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 0 );

    var exp =
`
console.log( 'File.js' );
console.log( "new line" );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
new line
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .git.reset - resetting of current directory';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with clone/ .git.reset' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`;
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .git.reset dry:1 - with option dry';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/F.txt' ), 'F.txt' );
    return null;
  });

  a.appStart( '.with clone/ .git.reset dry:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );
    test.identical( _.strCount( op.output, 'Uncommitted changes, would be reseted :' ), 1 );
    test.identical( _.strCount( op.output, 'M File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M proto/File.js' ), 1 );
    test.identical( _.strCount( op.output, 'Uncommitted changes, would be cleaned :' ), 1 );
    test.identical( _.strCount( op.output, '?? F.txt' ), 0 );

    var exp =
`
console.log( 'File.js' );
console.log( "new line" );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
new line
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    a.fileProvider.fileDelete( a.abs( 'clone/F.txt' ) );
    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .git.reset removingUntracked:1 - resetting of untracked files, but not ignored';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/proto/File2.js'), 'console.log( \'File2.js\' );' );
    a.fileProvider.fileWrite( a.abs( 'clone/File2.txt'), 'File2.txt' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './File2.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './proto/File2.js'
    ];
    test.identical( got, exp );

    return null;
  });

  a.appStart( '.with clone/ .git.reset removingUntracked:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .git.reset removingUntracked:1 removingIgnored:1 - resetting of untracked and ignored files';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/proto/File2.js'), 'console.log( \'File2.js\' );' );
    a.fileProvider.fileWrite( a.abs( 'clone/File2.txt'), 'File2.txt' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './File2.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './proto/File2.js'
    ];
    test.identical( got, exp );

    return null;
  });

  a.appStart( '.with clone/ .git.reset removingUntracked:1 removingIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .git.reset removingUntracked:1 removingIgnored:1';
    test.description = 'resetting of untracked and ignored files but not subrepository'
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.dirMake( a.abs( 'clone/sub' ) );
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' )\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );

    return null;
  });

  a.shell({ currentPath : a.abs( 'clone/sub' ), execPath : 'git init' });
  a.ready.then( () =>
  {
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );
    return null;
  });

  a.appStart( '.with clone/ .git.reset removingUntracked:1 removingIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone/ .git.reset removingUntracked:1 removingIgnored:1 removingSubrepositories:1';
    test.description = 'resetting of untracked, ignored files and subrepository'
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    a.fileProvider.dirMake( a.abs( 'clone/sub' ) );
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( \'new line\' )\n' );
    a.fileProvider.fileWrite( a.abs( 'clone/.file'), '.file' );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './.file',
      './.gitignore',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
      './sub',
    ];
    test.identical( got, exp );

    return null;
  });

  a.shell({ currentPath : a.abs( 'clone/sub' ), execPath : 'git init' });
  a.ready.then( () =>
  {
    test.true( a.fileProvider.fileExists( a.abs( 'clone/sub/.git' ) ) );
    return null;
  });

  a.appStart( '.with clone/ .git.reset removingUntracked:1 removingIgnored:1 removingSubrepositories:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 1 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    var got = a.find( a.abs( 'clone' ) );
    var exp =
    [
      '.',
      './File.txt',
      './will.yml',
      './proto',
      './proto/File.js',
    ];
    test.identical( got, exp );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with clone .git.reset v:0 - verbosity:0';
    a.fileProvider.fileAppend( a.abs( 'clone/proto/File.js' ), 'console.log( "new line" );\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with clone/ .git.reset v:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Building module::gitReset' ), 0 );
    test.identical( _.strCount( op.output, 'Resetting module::gitReset' ), 0 );

    var exp =
`
console.log( 'File.js' );
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/proto/File.js' ) );
    test.equivalent( read, exp );

    var exp =
`
File.txt
`
    var read = a.fileProvider.fileRead( a.abs( 'clone/File.txt' ) );
    test.equivalent( read, exp );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'clone' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

commandGitReset.rapidity = -1;

//

function commandGitStatus( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin().then( () =>
  {
    test.case = '.with original .git.status - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status - only local commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( '.with original/ .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status - local and remote commits';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .git.status' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status local:0 - checks no local changes';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .git.status local:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status remote:0 - checks no local changes';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .git.status remote:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status uncommittedIgnored:1 - checks ignored uncommited';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .git.status uncommittedIgnored:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status uncommittedIgnored:0 - checks without ignored';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/.warchive' ), 'warchive\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .git.status uncommittedIgnored:0' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = '.with original .git.status remoteBranches:1 - checks with remote branches';
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am first' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push' });

  a.appStart( '.with original/ .git.status remoteBranches:1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 1 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 1 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 1 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () => { a.fileProvider.dirMake( a.abs( 'repo' ) ); return null } );
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );
    return a.ready;
  }
}

commandGitStatus.rapidity = -1;

//

function commandGitStatusWithPR( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() || process.platform === 'win32' )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'gitPush' );
  const user = 'wtools-bot';
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  /* - */

  begin();
  a.appStart( '.with original/ .git.status' )
  .then( ( op ) =>
  {
    test.case = '.with original .git.status - checks repository with only one pull request';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );
    test.identical( _.strCount( op.output, 'module::clone' ), 2 );
    test.identical( _.strCount( op.output, 'Has 1 opened pull request(s)' ), 1 );

    return null;
  });

  /* */

  a.appStart( '.with original/ .git.status prs:0' )
  .then( ( op ) =>
  {
    test.case = '.with original .git.status prs:0 - checks repository with only one pull request';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'List of uncommited changes' ), 0 );
    test.identical( _.strCount( op.output, '?? File.txt' ), 0 );
    test.identical( _.strCount( op.output, 'M f1.txt' ), 0 );
    test.identical( _.strCount( op.output, '!! .warchive' ), 0 );
    test.identical( _.strCount( op.output, 'List of remote branches' ), 0 );
    test.identical( _.strCount( op.output, 'refs/heads/master' ), 0 );
    test.identical( _.strCount( op.output, 'module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Has 1 opened pull request(s)' ), 0 );

    return null;
  });

  /* */

  a.ready.finally( () => repositoryDelete() );

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    const currentPath = a.abs( 'original' );
    a.ready.then( () =>
    {
      a.reflect()
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });
    a.ready.then( ( op ) => repositoryDelete() );
    a.appStart({ execPath : '.with original/GitPrOpen .hook.call GitMake v:3' });
    let execPath = `git config credential.helper '!f(){ echo "username=${ user }" && echo "password=${ token }"; }; f'`;
    a.shell({ currentPath, execPath });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -m first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell({ currentPath, execPath : 'git checkout -b new' });
    a.ready.then( () => { a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' ); return null });
    a.shell({ currentPath, execPath : 'git commit -am second' });
    a.shell({ currentPath, execPath : 'git push -u origin new' });
    a.appStart( '.with original/GitPrOpen .repo.pull.open "New PR" srcBranch:new' );
    return a.ready;
  }

  /* */

  function repositoryDelete()
  {
    return _.git.repositoryDelete
    ({
      remotePath : `https://github.com/${user}/New2`,
      token,
      throwing : 0,
    });
  }
}

//

function commandGitSync( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config = { path : { hlink : a.abs( '..' ) } };
  let profile = 'test-profile';
  _.censor.configSet({ profileDir : profile, set : config });

  /* - */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  });

  a.appStart( `.with original/ .git.sync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original .git.sync - committing and pushing, without message';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /\s\./ ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git push -u origin --all' });

  a.appStart( `.with clone/ .git.sync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with clone/ .git.sync - only pulling, without message';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'second' ), 1 );
    return null;
  });

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am third' });

  a.appStart( `.with original/ .git.sync profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.sync - only pushing, without message';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'third' ), 1 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "fourth"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });

  a.appStart( `.with original/ .git.sync -am fifth profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.sync -am fifth - committing, pulling and pushing with message';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'fourth' ), 1 );
    test.identical( _.strCount( op.output, 'fifth' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git log' })
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'fifth' ), 1 );
    return null;
  })

  /* */

  begin().then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "sixth"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });

  a.appStart( `.with original/ .git.sync -am seventh v:0 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.sync -am seventh v:0 - checking of option verbosity';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 0 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 0 );
    return null;
  })

  /* */

  begin();
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git pull' });
  a.ready.then( () =>
  {
    a.fileProvider.fileAppend( a.abs( 'original/File.txt' ), 'new line\n' );
    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'new line\n' );
    return null;
  })
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git commit -am "seventh"' });
  a.shell({ currentPath : a.abs( 'clone' ), execPath : 'git push -u origin --all' });

  a.appStart( `.with original/ .git.sync "-am {about::name}" profile:${ profile }` )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.sync -am {about::name} - resolving of commit message';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pulling module::clone' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am {about::name}' ), 0 );
    test.identical( _.strCount( op.output, '> git commit -am clone' ), 1 );
    test.identical( _.strCount( op.output, 'Pushing module::clone' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    _.censor.profileDel( profile );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.dirMake( a.abs( 'repo' ) );
      return null;
    });
    a.shell({ currentPath : a.abs( 'repo' ), execPath : 'git init --bare' });
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git remote add origin ../repo' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    a.shell({ currentPath, execPath : 'git push -u origin --all' });
    a.shell( 'git clone repo/ clone' );
    return a.ready;
  }
}

//

function commandGitSyncRestoringHardlinks( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  let config, profile, profileDir;
  if( _.censor )
  {
    config = { path : { hlink : a.abs( '..' ) } };
    profile = 'test-profile';
    profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
    let configPath = a.abs( profileDir, 'config.yaml' );
    a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });
  }

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  a.ready.then( ( op ) => a.reflect() );
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
  a.shell( `git clone original clone` );

  a.ready.then( ( op ) =>
  {
    test.description = 'hardlink';
    a.fileProvider.hardLink
    ({
      srcPath : a.abs( 'clone/f1.txt' ),
      dstPath : a.abs( 'clone/f2.txt' ),
      sync : 1,
    });

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
clone
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    test.equivalent( orignalRead2, exp );

    return null;
  });

  /* */

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });

  a.appStartNonThrowing( '.with clone/ .git.sync v:5' )
  .then( ( op ) =>
  {
    test.case = 'conflict';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, 'Command ".with clone/ .git.sync v:5"' ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
    test.identical( _.strCount( op.output, '2 files changed, 2 insertions(+)' ), 1 );
    test.identical( _.strCount( op.output, '> git pull' ), 1 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 1 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, 'Launched as "git pull"' ), 1 );

    test.true( !a.fileProvider.areHardLinked( a.abs( 'original/f1.txt' ), a.abs( 'original/f2.txt' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( 'clone/f2.txt' ) ) );

    var exp =
`
original/f.txt
original
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    if( _.censor )
    a.fileProvider.filesDelete( profileDir );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandGitSyncRestoreHardLinksWithShared( test )
{
  let context = this;

  if( !_.censor )
  return test.true( true );

  let temp = context.suiteTempPath;
  context.suiteTempPath = _.path.join( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe/willbe' ); /* Dmytro : suiteTempPath contains part and extension `tmp` that excludes by providerArchive filter */
  let a = context.assetFor( test, 'gitPush' );
  a.reflect();

  /* */

  let config = { path : { hlink : a.abs( process.env.HOME || process.env.USERPROFILE, 'tmpWillbe' ) } };
  let profile = 'test-profile';
  let profileDir = a.abs( process.env.HOME || process.env.USERPROFILE, _.censor.storageDir, profile );
  let configPath = a.abs( profileDir, 'config.yaml' );
  a.fileProvider.fileWrite({ filePath : configPath, data : config, encoding : 'yaml' });

  let linkPath = config.path.hlink;

  let mergeStart = ` ${ _.strDup( '<', 7 ) } HEAD`;
  let mergeMid = _.strDup( '=', 7 )
  let mergeEnd = ` ${ _.strDup( '>', 7 ) }`

  /* - */

  begin().then( () =>
  {
    test.case = 'conflict';
    return null;
  });

  a.ready.then( () =>
  {
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    a.fileProvider.fileAppend( a.abs( 'clone/f1.txt' ), 'clone\n' );
    a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'original\n' );

    return null;
  });

  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am second' });

  a.appStartNonThrowing( `.with clone/ .git.sync v:5 profile:${ profile }` )
  .then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'has local changes' ), 0 );
    test.identical( _.strCount( op.output, `Command ".with clone/ .git.sync v:5 profile:${ profile }"` ), 1 );
    test.identical( _.strCount( op.output, 'Committing module::clone' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 1 );
    test.identical( _.strCount( op.output, '> git commit -am "."' ), 1 );
    test.identical( _.strCount( op.output, '1 file changed, 1 insertion(+)' ), 1 );
    test.identical( _.strCount( op.output, '> git pull' ), 1 );
    test.identical( _.strCount( op.output, 'CONFLICT (content): Merge conflict in f1.txt' ), 1 );
    test.identical( _.strCount( op.output, 'Automatic merge failed' ), 1 );
    test.identical( _.strCount( op.output, '+ hardLink : ' ), 1 );
    test.identical( _.strCount( op.output, '+ Restored 1 hardlinks' ), 1 );
    test.identical( _.strCount( op.output, 'Launched as "git pull"' ), 1 );

    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f1.txt' ), a.abs( linkPath, 'f1.lnk' ) ) );
    test.true( a.fileProvider.areHardLinked( a.abs( 'clone/f2.txt' ), a.abs( linkPath, 'f2.lnk' ) ) );

    var exp =
`
original/f.txt
original
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f1.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'original/f2.txt' ) );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
${ mergeStart }
clone
${ mergeMid }
original
${ mergeEnd }
`;
    var orignalRead1 = a.fileProvider.fileRead( a.abs( 'clone/f1.txt' ) );
    orignalRead1 = orignalRead1.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead1, exp );

    var exp =
`
original/f.txt
`;
    var orignalRead2 = a.fileProvider.fileRead( a.abs( 'clone/f2.txt' ) );
    orignalRead2 = orignalRead2.replace( />>>> .+/, '>>>>' );
    test.equivalent( orignalRead2, exp );
    return null;
  });

  /* */

  a.ready.finally( () =>
  {
    a.fileProvider.filesDelete( a.path.dir( context.suiteTempPath ) );
    a.fileProvider.filesDelete( profileDir );
    context.suiteTempPath = temp;
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git add --all' });
    a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit -am first' });
    a.shell( `git clone original clone` );
    a.ready.then( () =>
    {
      a.fileProvider.hardLink
      ({
        srcPath : a.abs( 'clone/f1.txt' ),
        dstPath : a.abs( linkPath, 'f1.lnk' ),
        sync : 1,
      });
      a.fileProvider.hardLink
      ({
        srcPath : a.abs( 'clone/f2.txt' ),
        dstPath : a.abs( linkPath, 'f2.lnk' ),
        sync : 1,
      });
      return null;
    });
    return a.ready;
  }
}

//

function commandGitTag( test )
{
  let context = this;
  let a = context.assetFor( test, 'gitPush' );

  /* - */

  begin();
  a.appStart( '.with original/ .git.tag tag:v1.0' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.tag tag:v1.0 - add tag, only option name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v1.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v1.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.tag tag:v2.0 description:"Version 2.0"' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.tag tag:v2.0 description:"Version 2.0" - add tag with description';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v2.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v2.0            Version 2.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.tag tag:v3.0 description:"Version 3.0" light:1' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.tag tag:v3.0 description:"Version 3.0" light:1 - add tag, only option name';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v3.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v3.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.tag tag:v4.0 description:"Version 4.0" dry:1' )
  .then( ( op ) =>
  {
    test.case = '.with original/ .git.tag tag:v4.0 description:"Version 4.0" dry:1 - option dry, should not add tag';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 0 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v4.0            Version 4.0' ), 0 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.tag tag:v4.0 description:"Version 4.0" v:0' )
  a.ready.then( ( op ) =>
  {
    test.case = '.with original/ .git.tag tag:v4.0 description:"Version 4.0" v:0 - verbosity';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 0 );
    // test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 0 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v4.0            Version 4.0' ), 1 );
    return null;
  });

  /* */

  begin();
  a.appStart( '.with original/ .git.tag tag:v4.0 description:"Version 4.0"' )
  a.appStart( '.with original/ .git.tag tag:v4.0 description:"Version 4.0"' )
  a.ready.then( ( op ) =>
  {
    test.case = 'add same tag twice, should not throw error';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v4.0' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v4.0            Version 4.0' ), 1 );
    return null;
  });

  /* */

  begin();
  var commitHash;
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git rev-parse HEAD' });
  a.ready.then( ( op ) =>
  {
    commitHash = op.output.trim();
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git commit --allow-empty -m "empty commit"' });
  a.ready.then( () =>
  {
    let ready = _.take( null );
    a.appStart
    ({
      execPath : `.with original/ .git.tag tag:v5.0 description:"Version 5.0" toVersion:${ commitHash }`,
      ready
    });
    return ready;
  });
  a.ready.then( ( op ) =>
  {
    test.case = 'add tag to older commit';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, '. Opened .' ), 1 );
    test.identical( _.strCount( op.output, 'Creating tag v5.0' ), 1 );
    return null;
  })
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git tag -l -n' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'v5.0            Version 5.0' ), 1 );
    return null;
  });
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git rev-list -n 1 v5.0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, commitHash ), 1 );
    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git init' });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -am first' });
    return a.ready;
  }
}

//

function commandRepoPullOpen( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'gitPush' );
  const user = 'wtools-bot';
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  a.reflect();
  a.shell({ currentPath : a.abs( 'original' ), execPath : 'git init' });
  a.shell({ currentPath : a.abs( 'original' ), execPath : `git remote add origin https://github.com/${ user }/New2` });

  /* - */

  a.appStartNonThrowing( '.with original/Git.* .repo.pull.open "some title" srcBranch:new' );
  a.ready.then( ( op ) =>
  {
    test.case = 'all defaults exept title and source branch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* */

  a.appStartNonThrowing( '.with original/Git.* .repo.pull.open "some title" srcBranch:new token:$GIT_TOKEN' )
  .then( ( op ) =>
  {
    test.case = 'token from environment variables, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* */

  a.appStartNonThrowing( '.with original/Git.* .repo.pull.open "some title" srcBranch:new token:"token"' )
  .then( ( op ) =>
  {
    test.case = 'direct declaration of token, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* */

  a.appStartNonThrowing( '.with original/Git.* .repo.pull.open "some title" srcBranch:"user:new" dstBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'custom srcBranch and dstBranch, wrong data, throwing';
    test.notIdentical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, /Error code : 4\d\d/ ), 1 );
    test.identical( _.strCount( op.output, 'Failed to open pull request' ), 1 );
    test.identical( _.strCount( op.output, 'Failed to repo pull open' ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandRepoPullOpenRemote( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() || process.platform === 'win32' )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'gitPush' );
  const user = 'wtools-bot';
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  /* - */

  begin();
  a.appStart({ execPath : '.with original/GitPrOpen .hook.call GitMake v:3' })
  .then( ( op ) =>
  {
    test.case = 'make repo';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, `Making repository for module::New2 at` ), 1 );
    test.identical( _.strCount( op.output, `localPath :` ), 1 );
    test.identical( _.strCount( op.output, /remotePath : .*https:.*\/New2/ ), 1 );
    test.identical( _.strCount( op.output, `> git ls-remote https://github.com/${ user }/New2` ), 1 );
    return null;
  });

  /* */

  prepareFirstBranch();
  a.appStart( '.with original/GitPrOpen .repo.pull.open "New PR" srcBranch:new' )
  .then( ( op ) =>
  {
    test.case = 'opened pull request, only title and srcBranch';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Succefully created pull request "New PR" in https://github.com/' ), 1 );
    return null;
  });

  /* */

  prepareSecondBranch();
  a.appStart( '.with original/GitPrOpen .repo.pull.open "new2" srcBranch:new2 dstBranch:master body:description' )
  .then( ( op ) =>
  {
    test.case = 'opened pull request, body and dstBranch';
    test.identical( op.exitCode, 0 );
    test.identical( _.strCount( op.output, 'Succefully created pull request "new2" in https://github.com/' ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () => repositoryDelete() );

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () =>
    {
      a.reflect();
      a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'dos/.will' ) ] : a.abs( '.will' ) } });
      return null;
    });
    a.ready.then( () => repositoryDelete() );
    return a.ready;
  }

  /* */

  function repositoryDelete()
  {
    return _.git.repositoryDelete
    ({
      remotePath : `https://github.com/${ user }/New2`,
      token,
      throwing : 0,
    });
  }

  /* */

  function prepareFirstBranch()
  {
    let currentPath = a.abs( 'original' );
    let execPath =
    `git config credential.helper '!f(){ echo "username=${ user }" && echo "password=${ token }"; }; f'`;
    a.shell({ currentPath, execPath });
    a.shell({ currentPath, execPath : 'git add --all' });
    a.shell({ currentPath, execPath : 'git commit -m first' });
    a.shell({ currentPath, execPath : 'git push -u origin master' });
    a.shell({ currentPath, execPath : 'git checkout -b new' });
    a.ready.then( () => { a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' ); return null });
    a.shell({ currentPath, execPath : 'git commit -am second' });
    a.shell({ currentPath, execPath : 'git push -u origin new' });
    return a.ready;
  }

  /* */

  function prepareSecondBranch()
  {
    let currentPath = a.abs( 'original' );
    a.shell({ currentPath, execPath : 'git checkout master' });
    a.shell({ currentPath, execPath : 'git checkout -b new2' });
    a.ready.then( () => { a.fileProvider.fileAppend( a.abs( 'original/f1.txt' ), 'new line\n' ); return null });
    a.shell({ currentPath, execPath : 'git commit -am second' });
    a.shell({ currentPath, execPath : 'git push -u origin new2' });
    return a.ready;
  }
}

//

function commandRepoReleaseRemote( test )
{
  const token = process.env.PRIVATE_WTOOLS_BOT_TOKEN;
  if( !token || !_.process.insideTestContainer() )
  return test.true( true );

  /* */

  const context = this;
  const a = context.assetFor( test, 'repoRelease' );
  const user = 'wtools-bot';
  const repository = `https://github.com/${ user }/New-${ _.intRandom( 1000000 ) }`;
  const defaultIdentity = { name : '_bot_', login : user, email : 'bot@domain.com', type : 'git', token, default : 1 };
  _.identity.identityNew({ identity : defaultIdentity, force : 1 });

  begin();

  /* - */

  a.ready.then( () =>
  {
    test.case = 'repository has no tags';
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am init' );
  a.shell( 'git push -u origin master' );

  a.appStart( '.repo.release tag:v0.0.1' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".repo.release tag:v0.0.1"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "v0.0.1" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repository with tags, release existed tag, release with name and options';
    a.fileProvider.fileWrite( a.abs( './file.txt' ), 'file.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git tag first' );
  a.ready.then( () =>
  {
    a.fileProvider.fileWrite( a.abs( './file1.txt' ), 'file1.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git tag second' );
  a.shell( 'git push -u origin master' );
  a.shell( 'git push --tags' );

  a.appStart( '.repo.release v0.0.2 tag:first prerelease:0 draft:0' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".repo.release v0.0.2 tag:first prerelease:0 draft:0"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "first" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repository with tags, release existed tag, release with description';
    a.fileProvider.fileWrite( a.abs( './file2.txt' ), 'file2.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git tag v0.0.3' );
  a.shell( 'git push -u origin master' );
  a.shell( 'git push --tags' );

  a.appStart( '.repo.release tag:v0.0.3 descriptionBody:description' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".repo.release tag:v0.0.3 descriptionBody:description"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "v0.0.3" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'release the tag twice, force - 1';
    a.fileProvider.fileAppend( a.abs( './file.txt' ), 'file.txt' );
    return null;
  });
  a.shell( 'git add .' );
  a.shell( 'git commit -am commit' );
  a.shell( 'git push -u origin master' );

  a.appStart( '.repo.release tag:v0.0.4 force:1' );
  a.appStart( '.repo.release tag:v0.0.4 force:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( _.strCount( op.output, 'Command ".repo.release tag:v0.0.4 force:1"' ), 1 );
    test.identical( _.strCount( op.output, `Succefully created release "v0.0.4" in git+https:///github.com/${ user }` ), 1 );
    return null;
  });

  /* */

  a.ready.finally( () => repositoryDelete() );

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( ( op ) => a.reflectMinimal() );
    a.ready.then( ( op ) => repositoryDelete() );
    a.ready.then( () =>
    {
      return _.git.repositoryInit
      ({
        remotePath : repository,
        localPath : a.routinePath,
        throwing : 1,
        description : 'Test',
        token,
      });
    });
    return a.ready;
  }

  /* */

  function repositoryDelete()
  {
    return _.git.repositoryDelete
    ({
      remotePath : repository,
      token,
      throwing : 0,
    });
  }
}

//

function commandNpmFromWillfile( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.with Author .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `author`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.author, 'Author <author@dot.com>' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Contributors .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `contributors`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.contributors, [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ] );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Description .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `description`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.description, 'To check the conversion' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Enabled .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `enabled`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.name, undefined );
    test.identical( config.enabled, 0 );

    return null;
  })

  /* */

  a.appStart({ args : '.with Interpreters .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `interpreters`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.interpreters, undefined );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with Keywords .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `keywords`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.keywords, [ 'tools', 'export' ] );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with License .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `license`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.license, 'MIT' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with Name .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `name`, name of willfile';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.name, 'NpmFromWillfile' );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with NpmName .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `name`, npm name';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.name, 'npmfromwillfile' );
    test.identical( config.enabled, undefined );

    return null;
  })

  /* */

  a.appStart({ args : '.with NpmScripts .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `scripts`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.scripts, { 'test' : 'wtest .run proto/**', 'docgen' : 'wdocgen .build proto' } );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `main`, should not read path';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.main, 'proto' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathRepository .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check fields `repository` and `bugs`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.repository, 'https://github.com/author/NpmFromWillfile.git' );
    test.identical( config.bugs, 'https://github.com/author/NpmFromWillfile/issues' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with Submodule .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check fields `dependencies` and `devDependencies`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.dependencies, { eslint : '7.1.0', babel : '^0.3.0' } );
    test.identical( config.devDependencies, { NpmFromWillfile : 'file:.', wTesting : '', willbe : 'alpha' } );
    test.identical( config.name, 'npmfromwillfile' );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.with Version .npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `version`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.version, '0.0.0' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );

    return null;
  });

  /* */

  a.appStart({ args : '.npm.from.willfile withDisabledSubmodules:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check unnamed willfiles, full config';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.engines' : { node : '>= 6.0.0', chrome : '>= 60.0.0', firefox : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'scripts' : { test : 'wtest .run proto/** v:5', docgen : 'wdocgen .build proto' },
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    return null;
  });

  /* */

  return a.ready;
}

commandNpmFromWillfile.rapidity = -1;

//

function commandNpmFromWillfileOptionsInCommand( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.npm.from.willfile packagePath:"out/debug/package.json" withDisabledSubmodules:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `packagePath`, `package.json`, direct link to directory';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/debug/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.engines' : { 'node' : '>= 6.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.npm.from.willfile packagePath:"{path::out}/package.json" withDisabledSubmodules:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `packagePath`, `package.json`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out/' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
      'npm.engines' : { 'node' : '>= 6.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.npm.from.willfile packagePath:"{path::out.*=1}/package.json" debug:1 withDisabledSubmodules:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `packagePath`, `package.json`, resolve path with criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.abs( 'out/debug' ) );
    test.identical( files, [ '.', './package.json' ] );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/debug/package.json' ), encoding : 'json' });
    var exp =
    {
      'name' : 'npmfromwillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
      'npm.engines' : { 'node' : '>= 6.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' },
      'engine' : 'node >= 6.0.0',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'NpmFromWillfile' : 'file:.', 'wTesting' : '' },
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'keywords' : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'out/' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile entryPath:"proto/File.s" withDisabledSubmodules:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, direct link to file';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { main : 'proto/File.s' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile entryPath:"{path::proto}/File.s"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { main : 'proto/File.s' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile entryPath:"{path::entry.*=1}/File.s" debug:debug' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { main : 'proto/File.s' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile filesPath:"proto/**"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `filesPath`, direct link to file';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s' ], main : 'proto' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile filesPath:"{path::proto}/**"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s' ], main : 'proto' };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'package.json' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile filesPath:"{path::entry.*=1}/**" debug:debug' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `entryPath`, resolve path without criterions';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s' ], main : 'proto' };
    test.identical( config, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain .npm.from.willfile filesPath:"[ {path::proto}/**, proto ]"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'resolve list of files paths';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { files : [ 'proto/File.s', 'proto' ], main : 'proto' };
    test.identical( config, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.with Name .npm.from.willfile npmName:"user.module.name"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'check option `name`';
    test.identical( op.exitCode, 0 );
    let files = a.find( a.routinePath );
    test.true( _.longHas( files, './package.json' ) );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp = { name : 'user.module.name' };
    test.identical( config, exp );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileFromNpm( test )
{
  let context = this;
  let a = context.assetFor( test, 'willfileFromNpm' );
  a.reflect();

  /* - */

  a.appStart({ args : '.willfile.from.npm packagePath:Author.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `author`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, 'author' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Contributors.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `contributors`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.contributors, [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ] );
    test.identical( config.about.name, 'contributors' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Description.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `description`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.description, 'To check the conversion' );
    test.identical( config.about.name, 'description' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Enabled.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `enabled`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.name, 'enabled' );
    test.identical( config.about.enabled, 0 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Interpreters.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `interpreters`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.interpreters, [ 'njs >= 10.0.0' ] );
    test.identical( config.about.name, 'interpreters' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Keywords.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `keywords`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.keywords, [ 'tools', 'export' ] );
    test.identical( config.about.name, 'keywords' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:License.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `license`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.license, 'MIT' );
    test.identical( config.about.name, 'license' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Name.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `name`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.name, 'willfilefromnpm' );
    test.identical( config.about[ 'npm.name' ], 'willfilefromnpm' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:NpmScripts.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `scripts`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about[ 'npm.scripts' ], { 'test' : 'wtest .run proto/**', 'docgen' : 'wdocgen .build proto' } );
    test.identical( config.about.name, 'npmscripts' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:PathMain.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `main`, should not read path';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.path.entry, 'path/to' );
    test.identical( config.about.name, 'pathmain' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:PathRepository.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check fields `repository` and `bugs`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.path.repository, 'git+https:///github.com/author/NpmFromWillfile.git' );
    test.identical( config.path.bugtracker, 'https:///github.com/author/NpmFromWillfile/issues' );
    test.identical( config.about.name, 'pathrepository' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Submodule.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check fields `dependencies` and `devDependencies`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    var exp =
    {
      'eslint' :
      {
        'path' : 'npm:///eslint!7.1.0',
        'enabled' : 1
      },
      'babel' :
      {
        'path' : 'npm:///babel!^0.3.0',
        'enabled' : 1
      },
      'npmfromwillfile' :
      {
        'path' : 'hd://.',
        'enabled' : 1,
        'criterion' : { 'development' : 1 }
      },
      'wTesting' :
      {
        'path' : 'npm:///wTesting',
        'enabled' : 1,
        'criterion' : { 'development' : 1 }
      },
      'willbe' :
      {
        'path' : 'npm:///willbe!alpha',
        'enabled' : 1,
        'criterion' : { 'development' : 1 }
      }
    };
    test.identical( config.submodule, exp );
    test.identical( config.about.name, 'submodule' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.from.npm packagePath:Version.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check field `version`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.version, '0.0.0' );
    test.identical( config.about.name, 'version' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.from.npm' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check default `package.json` file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    var exp =
    {
      'about' :
      {
        'npm.name' : 'willfilefromnpm',
        'name' : 'willfilefromnpm',
        'version' : '0.0.0',
        'enabled' : 1,
        'description' : 'To check the conversion',
        'keywords' : [ 'tools', 'export' ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ]
      },
      'path' :
      {
        'origins' :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///willfilefromnpm'
        ],
        'repository' : 'git+https:///github.com/author/NpmFromWillfile.git',
        'bugtracker' : 'https:///github.com/author/NpmFromWillfile/issues'
      },
      'submodule' :
      {
        'eslint' :
        {
          'path' : 'npm:///eslint!7.1.0',
          'enabled' : 1
        },
        'willfilefromnpm' :
        {
          'path' : 'hd://.',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        },
        'wTesting' :
        {
          'path' : 'npm:///wTesting',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* - */

  return a.ready;
}

//

function commandWillfileFromNpmDoubleConversion( test )
{
  let context = this;
  let a = context.assetFor( test, 'willfileFromNpm' );
  a.reflect();

  /* - */

  a.appStart({ args : '.willfile.from.npm' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check default `package.json` file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    let exp =
    {
      'about' :
      {
        'npm.name' : 'willfilefromnpm',
        'name' : 'willfilefromnpm',
        'version' : '0.0.0',
        'enabled' : 1,
        'description' : 'To check the conversion',
        'keywords' : [ 'tools', 'export' ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ]
      },
      'path' :
      {
        'origins' :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///willfilefromnpm'
        ],
        'repository' : 'git+https:///github.com/author/NpmFromWillfile.git',
        'bugtracker' : 'https:///github.com/author/NpmFromWillfile/issues'
      },
      'submodule' :
      {
        'eslint' :
        {
          'path' : 'npm:///eslint!7.1.0',
          'enabled' : 1
        },
        'willfilefromnpm' :
        {
          'path' : 'hd://.',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        },
        'wTesting' :
        {
          'path' : 'npm:///wTesting',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.appStart({ args : '.npm.from.willfile' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check conversion from generated willfile';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    var exp =
    {
      name : 'willfilefromnpm',
      description : 'To check the conversion',
      version : '0.0.0',
      enabled : 1,
      license : 'MIT',
      author : 'Author <author@dot.com>',
      contributors : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      dependencies : { 'eslint' : '7.1.0' },
      devDependencies : { 'willfilefromnpm' : 'file:.', 'wTesting' : '' },
      repository : 'https://github.com/author/NpmFromWillfile.git',
      bugs : 'https://github.com/author/NpmFromWillfile/issues',
      keywords : [ 'tools', 'export' ],
    };
    test.identical( config, exp );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.with Named .willfile.from.npm packagePath:Version.json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check of using command `.with`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'will.yml' ) );
    test.identical( config.about.version, '0.0.0' );
    test.identical( config.about.name, 'version' );
    test.identical( config.about.enabled, 1 );

    a.fileProvider.filesDelete( a.abs( 'will.yml' ) )

    return null;
  })

  /* */

  a.appStart({ args : '.with Named .willfile.from.npm packagePath:Version.json willfilePath:New.will.yml' })
  a.ready.then( ( op ) =>
  {
    test.case = 'check of option `willfilePath`';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileReadUnknown( a.abs( 'New.will.yml' ) );
    test.identical( config.about.version, '0.0.0' );
    test.identical( config.about.name, 'version' );
    test.identical( config.about.enabled, 1 );

    return null;
  })

  /* - */

  return a.ready;
}

//

function commandWillfileGet( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.get' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, without options and subject';
    test.identical( op.exitCode, 0 );
    test.ge( _.strLinesCount( op.output ), 80 );
    test.true( _.strHas( op.output, 'about ::' ) );
    test.true( _.strHas( op.output, 'build ::' ) );
    test.true( _.strHas( op.output, 'path ::' ) );
    test.true( _.strHas( op.output, 'reflector ::' ) );
    test.true( _.strHas( op.output, 'step ::' ) );
    test.true( _.strHas( op.output, 'submodule ::' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get about/author' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, only subject';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get about/author:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, only enabled option';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get Author about/author about/name v:4' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - only name and subjects';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );
    test.true( _.strHas( op.output, 'about/name :: {-undefined-}' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get Author.will.yml about/author:1 about/name:1 v:5' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile with - full form and enabled options';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );
    test.true( _.strHas( op.output, 'about/name :: {-undefined-}' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get ForExtension.will submodule/eslint about/author:1 about/name:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile, subject and enabled options';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author1@dot.com>' ) );
    test.true( _.strHas( op.output, 'about/name :: Extension willfile' ) );
    test.true( _.strHas( op.output, 'submodule/eslint ::\n ' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get ForExtension submodule/eslint about/author:0 about/name:0' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile, subject and disabled options';
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, 'about/author :: Author1 some.nickname@dot.com' ) );
    test.false( _.strHas( op.output, 'about/name :: Extension willfile' ) );
    test.true( _.strHas( op.output, 'submodule/eslint ::\n ' ) );
    test.true( _.strHas( op.output, 'path : npm:///eslint#7.1.0' ) );

    return null;
  });

  a.appStart({ args : '.willfile.get ./ path/in' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile for two unnamed willfiles';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'path/in :: .' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.with Author .willfile.get about/author about/name' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context module, subjects';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );
    test.true( _.strHas( op.output, 'about/name :: {-undefined-}' ) );

    return null;
  });

  a.appStart({ args : '.with Author.will.yml .willfile.get about/author:1 about/name:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context module, enabled options';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );
    test.true( _.strHas( op.output, 'about/name :: {-undefined-}' ) );

    return null;
  });

  a.appStart({ args : '.with ./ .willfile.get submodule/eslint about/author:1 about/name:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context module, enabled options';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );
    test.true( _.strHas( op.output, 'about/name :: NpmFromWillfile' ) );

    return null;
  });

  a.appStart({ args : '.with . .willfile.get submodule/eslint about/author:0 about/name:0' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context module, disabled options';
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, 'about/author :: Author <author@dot.com>' ) );
    test.false( _.strHas( op.output, 'about/name :: NpmFromWillfile' ) );
    test.true( _.strHas( op.output, 'submodule/eslint ::\n ' ) );

    return null;
  });

  a.appStart({ args : '.with ./ .willfile.get path/in' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - two unnamed willfiles from context';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, 'path/in :: .' ) );

    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.willfile.get Unknown* about' });
  a.ready.then( ( op ) =>
  {
    test.case = 'call not existed file';
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  a.appStartNonThrowing({ args : '.willfile.get .* notSection/option:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'unknown section';
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileSet( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.set about/author:"Author author@some.dot.com"' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, only options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, undefined );

    return null;
  })

  a.appStart({ args : '.willfile.set PathMain.will.yml about/author:Author author@some.dot.com about/name:author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - full name and options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    test.identical( config.about.name, 'author' );

    return null;
  })

  a.appStart({ args : '.willfile.set Author about/author:Author author@some.dot.com about/name:author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - only name, options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    test.identical( config.about.name, 'author' );

    return null;
  })

  a.appStart({ args : '.willfile.set Name.will about/author:Author author@some.dot.com about/name:author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile, options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Name.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    test.identical( config.about.name, 'author' );

    return null;
  })

  a.appStart({ args : '.willfile.set . path/in:in' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - two unnamed willfiles';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, undefined );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, 'in' );

    return null;
  })

  a.appStart({ args : '.willfile.set Author path/in/criterion:{debug:1} structureParse:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'with parsed structure';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in.criterion, { debug : 1 } );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  });

  /* */

  a.appStart({ args : '.with PathMain.will.yml .willfile.set about/author:"Author author@some.dot.com" about/name:author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    test.identical( config.about.name, 'author' );

    return null;
  })

  a.appStart({ args : '.with Author .willfile.set about/author:Author author@some.dot.com about/name:author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    test.identical( config.about.name, 'author' );

    return null;
  })

  a.appStart({ args : '.with Name .willfile.set about/author:Author author@some.dot.com about/name:author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Name.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@some.dot.com' );
    test.identical( config.about.name, 'author' );

    return null;
  })

  a.appStart({ args : '.with ./ .willfile.set path/in:in' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, two unnamed willfiles';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, undefined );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, 'in' );

    return null;
  })

  a.appStart({ args : '.with Author .willfile.set path/in/criterion:{debug:1} structureParse:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'with parsed structure';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in.criterion, { debug : 1 } );

    return null;
  })

  /* */

  a.appStartNonThrowing({ args : '.willfile.set' })
  a.ready.then( ( op ) =>
  {
    test.case = 'without any options and subject';
    test.notIdentical( op.exitCode, 0 );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.set Unknown* about/name:name' })
  a.ready.then( ( op ) =>
  {
    test.case = 'call not existed file';
    test.notIdentical( op.exitCode, 0 );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.set .* notSection/option:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'unknown section';
    test.notIdentical( op.exitCode, 0 );

    return null;
  })

  /* */

  return a.ready;
}

//

function commandWillfileDel( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.del' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, without options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config, {} );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config, {} );

    return null;
  })

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  })

  /* */

  a.appStart({ args : '.willfile.del about/author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, only subject';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, undefined );
    test.ge( _.props.keys( config.about ).length, 4 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, undefined );

    return null;
  })

  a.appStart({ args : '.willfile.del about/name:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - without name, only enabled option';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.name, undefined );
    test.ge( _.props.keys( config.about ).length, 4 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, undefined );

    return null;
  })

  a.appStart({ args : '.willfile.del Author about/author about/name v:4' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - only name, subjects with not existed property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, undefined );
    test.identical( _.props.keys( config.about ).length, 0 );

    return null;
  });

  a.appStart({ args : '.willfile.del Name.will.yml about/author:1 about/name:1 verbosity:5' });
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile with - full form and enabled options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Name.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.name, undefined );
    test.identical( _.props.keys( config.about ).length, 0 );

    return null;
  });

  a.appStart({ args : '.willfile.del ForExtension.will submodule/eslint about/author:1 about/name:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile, subject and enabled options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, undefined );
    test.identical( config.about.name, undefined );
    test.ge( _.props.keys( config.about ).length, 4 );
    test.true( !_.longHas( _.props.keys( config.submodule ), 'eslint' ) );
    test.identical( _.props.keys( config.submodule ).length, 2 );

    return null;
  });

  a.appStart({ args : '.willfile.del ForExtension submodule/NpmFromWillfile about/description:0 about/version:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile, subject and disabled options';
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.description, 'To check the extension' );
    test.identical( config.about.version, '1.1.1' );
    test.ge( _.props.keys( config.about ).length, 4 );
    test.true( !_.longHas( _.props.keys( config.submodule ), 'NpmFromWillfile' ) );
    test.ge( _.props.keys( config.submodule ).length, 1 );

    return null;
  });

  a.appStart({ args : '.willfile.del . path/in' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile - two unnamed willfiles';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, undefined );
    test.ge( _.props.keys( config.path ).length, 3 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.ge( _.props.keys( config.path ).length, 3 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  });

  /* */

  a.appStart({ args : '.with Author .willfile.del about/author about/name' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, subjects with not existed property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, undefined );
    test.identical( _.props.keys( config.about ).length, 0 );

    return null;
  })

  a.appStart({ args : '.willfile.del Name.will.yml about/author:1 about/name:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, enabled options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Name.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.name, undefined );
    test.identical( _.props.keys( config.about ).length, 0 );
    test.false( _.strHas( op.output, 'Option "about/author" does not exist.' ) );

    return null;
  })

  a.appStart({ args : '.willfile.del ForExtension.will submodule/eslint about/author:1 about/name:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, enabled options';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, undefined );
    test.identical( config.about.name, undefined );
    test.ge( _.props.keys( config.about ).length, 4 );
    test.true( !_.longHas( _.props.keys( config.submodule ), 'eslint' ) );
    test.identical( _.props.keys( config.submodule ).length, 2 );

    return null;
  });

  a.appStart({ args : '.willfile.del ForExtension submodule/NpmFromWillfile about/description:0 about/version:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, subject and disabled options';
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.description, 'To check the extension' );
    test.identical( config.about.version, '1.1.1' );
    test.ge( _.props.keys( config.about ).length, 4 );
    test.true( !_.longHas( _.props.keys( config.submodule ), 'NpmFromWillfile' ) );
    test.ge( _.props.keys( config.submodule ).length, 1 );

    return null;
  })

  a.appStart({ args : '.willfile.del . path/in' })
  a.ready.then( ( op ) =>
  {
    test.case = 'source willfile from context, two unnamed willfiles';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, undefined );
    test.ge( _.props.keys( config.path ).length, 3 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.ge( _.props.keys( config.path ).length, 3 );

    return null;
  });

  /* */

  a.appStartNonThrowing({ args : '.willfile.del Unknown about' })
  a.ready.then( ( op ) =>
  {
    test.case = 'call not existed file';
    test.notIdentical( op.exitCode, 0 );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.del . notSection/option:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'unknown section';
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileExtend( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.extend Author about/author:"Author1 some.nickname@dot.com"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - only first part of willfile name, replace existing property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author1 some.nickname@dot.com' );
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  });

  a.appStart({ args : '.willfile.extend Author.will.yml about/author:"Author author@dot.com"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - full willfile name, replace existing property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@dot.com' );
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  });

  a.appStart({ args : '.willfile.extend . about/author:"Author author@dot.com"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - two unnamed willfiles, replace existing property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author author@dot.com' );
    test.identical( _.props.keys( config.about ).length, 11 );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, undefined );

    return null;
  });

  a.appStart({ args : '.willfile.extend . path/in:./' });
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - two unnamed willfiles, replace property that exists in both files';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, undefined );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, './' );

    return null;
  });

  a.appStart({ args : '.willfile.extend PathMain path/proto:proto/wtools' })
  a.ready.then( ( op ) =>
  {
    test.case = 'replace resource data';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.proto, 'proto/wtools' );
    test.identical( config.path.proto.path, undefined );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.extend PathMain about/name:WillfileExtend submodule/ModuleForTesting1:"git+http:///github.com/..."' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add few new sections and resources';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, { name : 'WillfileExtend' } );
    test.identical( config.submodule, { ModuleForTesting1 : 'git+http:///github.com/...' } );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.extend PathMain path/entry/criterion:"debug:[0,1]" about/name:WillfileExtend' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new field to resource, array, not parsing';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, { name : 'WillfileExtend' } );
    test.identical( config.path.entry.criterion, 'debug:[0,1]' );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend PathMain path/entry/criterion:"debug:[0,1]" about/name:WillfileExtend structureParse:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new field to resource, array, not parsing';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, { name : 'WillfileExtend' } );
    test.identical( config.path.entry.criterion.debug, [ 0, 1 ] );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  })

  /* - */

  a.appStartNonThrowing({ args : '.willfile.extend NotExisted about/name:throwing' })
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile not exists';
    test.notIdentical( op.exitCode, 0 );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.extend "**" about/name:throwing' })
  a.ready.then( ( op ) =>
  {
    test.case = 'too many dstFiles';
    test.notIdentical( op.exitCode, 0 );

    return null;
  })

  /* */

  return a.ready;
}

//

function commandWillfileSupplement( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.supplement Author about/author:"Author1 some.nickname@dot.com"' })
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - only first part of willfile name, replace existing property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  })

  a.appStart({ args : '.willfile.supplement Author.will.yml about/author:"Author author@dot.com"' })
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - full willfile name, replace existing property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  })

  a.appStart({ args : '.willfile.supplement . about/author:"Author author@dot.com"' })
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - two unnamed willfiles, replace existing property';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( _.props.keys( config.about ).length, 11 );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, undefined );

    return null;
  })

  a.appStart({ args : '.willfile.supplement . path/in:./' });
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile - two unnamed willfiles, replace property that exists in both files';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, undefined );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.in, '.' );

    return null;
  });

  a.appStart({ args : '.willfile.supplement PathMain path/proto/path:proto/wtools' })
  a.ready.then( ( op ) =>
  {
    test.case = 'replace single field of resource';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.proto.path, 'proto' );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  })

  a.appStart({ args : '.willfile.supplement PathMain path/proto:proto/wtools' })
  a.ready.then( ( op ) =>
  {
    test.case = 'replace resource data';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.path.proto, { path : 'proto' } );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement PathMain about/name:WillfileExtend submodule/ModuleForTesting1:"git+http:///github.com/..."' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add few new sections and resources';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, { name : 'WillfileExtend' } );
    test.identical( config.submodule, { ModuleForTesting1 : 'git+http:///github.com/...' } );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement PathMain path/entry/criterion:"debug:[0,1]" about/name:WillfileExtend' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new field to resource, array, not parsing';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, { name : 'WillfileExtend' } );
    test.identical( config.path.entry.criterion, { debug : [ 'debug', 'release' ] } );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.supplement PathMain path/entry/criterion:"debug:[0,1]" about/name:WillfileExtend structureParse:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'add new field to resource, array, not parsing';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( 'PathMain.will.yml' ), encoding : 'yaml' });
    test.identical( config.about, { name : 'WillfileExtend' } );
    test.identical( config.path.entry.criterion.debug, [ 'debug', 'release' ] );
    test.identical( _.props.keys( config.path ).length, 2 );

    return null;
  });

  /* - */

  a.appStartNonThrowing({ args : '.willfile.supplement NotExisted about/name:throwing' });
  a.ready.then( ( op ) =>
  {
    test.case = 'dstFile not exists';
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  a.appStartNonThrowing({ args : '.willfile.supplement "**" about/name:throwing' });
  a.ready.then( ( op ) =>
  {
    test.case = 'too many dstFiles';
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileExtendWillfileDstIsWillfile( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.extend.willfile ./ Author.will Contributors Description* Interpreters' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new willfile, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, 'NpmFromWillfile' );
    test.identical( config.about.enabled, 1 );
    test.identical( config.about.contributors.length, 2 );
    test.true( _.longHas( config.about.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config.about.interpreters.length, 3 );
    test.true( _.longHas( config.about.interpreters, 'njs >= 10.0.0' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile NewFile Author.will Contributors Description* Interpreters' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new named willfile, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, undefined );
    test.identical( config.about.enabled, undefined );
    test.identical( config.about.contributors.length, 2 );
    test.true( _.longHas( config.about.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config.about.interpreters.length, 3 );
    test.true( _.longHas( config.about.interpreters, 'njs >= 10.0.0' ) );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.extend.willfile Author Contributors Description* Interpreters' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new data to existing config, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, undefined );
    test.identical( config.about.enabled, undefined );
    test.identical( config.about.contributors.length, 2 );
    test.true( _.longHas( config.about.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config.about.interpreters.length, 3 );
    test.true( _.longHas( config.about.interpreters, 'njs >= 10.0.0' ) );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflect();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  })

  a.appStart({ args : '.willfile.extend.willfile NewFile files/p*' })
  a.ready.then( ( op ) =>
  {
    test.case = 'creating new config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.will.yml' ), encoding : 'yaml' });
    let exp =
    {
      'about' :
      {
        'npm.name' : 'willfilefromnpm',
        'name' : 'willfilefromnpm',
        'version' : '0.0.0',
        'enabled' : 1,
        'description' : 'To check the conversion',
        'keywords' : [ 'tools', 'export' ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      },
      'path' :
      {
        'origins' :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///willfilefromnpm'
        ],
        'repository' : 'git+https:///github.com/author/NpmFromWillfile.git',
        'bugtracker' : 'https:///github.com/author/NpmFromWillfile/issues'
      },
      'submodule' :
      {
        'eslint' :
        {
          'path' : 'npm:///eslint!7.1.0',
          'enabled' : 1
        },
        'willfilefromnpm' :
        {
          'path' : 'hd://.',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        },
        'wTesting' :
        {
          'path' : 'npm:///wTesting',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflect();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  })

  a.appStart({ args : '.willfile.extend.willfile Author files/p*' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new data to existing config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    let exp =
    {
      'about' :
      {
        'npm.name' : 'willfilefromnpm',
        'name' : 'willfilefromnpm',
        'version' : '0.0.0',
        'enabled' : 1,
        'description' : 'To check the conversion',
        'keywords' : [ 'tools', 'export' ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ]
      },
      'path' :
      {
        'origins' :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///willfilefromnpm'
        ],
        'repository' : 'git+https:///github.com/author/NpmFromWillfile.git',
        'bugtracker' : 'https:///github.com/author/NpmFromWillfile/issues'
      },
      'submodule' :
      {
        'eslint' :
        {
          'path' : 'npm:///eslint!7.1.0',
          'enabled' : 1
        },
        'willfilefromnpm' :
        {
          'path' : 'hd://.',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        },
        'wTesting' :
        {
          'path' : 'npm:///wTesting',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        }
      }
    };
    test.identical( config, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile . ForExtension' })
  a.ready.then( ( op ) =>
  {
    test.case = 'extend two unnamed willfiles by new data';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'about' :
      {
        'name' : 'Extension willfile',
        'description' : 'To check the extension',
        'version' : '1.1.1',
        'enabled' : 0,
        'interpreters' :
        [
          'njs = 6.0.0',
          'chrome >= 60.0.0',
          'firefox >= 67.0.0',
          'chromium >= 67.0.0',
        ],
        'keywords' :
        [
          'tools',
          'export',
          'wtools',
          'common',
        ],
        'license' : 'GPL',
        'author' : 'Author <author1@dot.com>',
        'contributors' :
        [
          'Contributor1 <contributor1@dot.com>',
          'Contributor2 <contributor2@xxx.com>',
          'Contributor3 <contributor3@dot.com>',
        ],
        'npm.name' : 'willfileextend',
        'npm.scripts' :
        {
          'test' : 'wtest .run proto/** v:5',
          'docgen' : 'wdocgen .build proto/wtools',
          'eslint' : 'eslint proto'
        },
      },

      'path' :
      {
        'repository' : 'git+https:///github.com/author/WillfileExtend.git',
        'origins' :
        [
          'git+https:///github.com/author/WillfileExtend.git',
          'npm:///willfileextend',
        ],
        'bugtracker' : 'https:///github.com/author/WillfileExtend/issues',
      },

      'step' :
      {
        'export.debug' :
        {
          'inherit' : 'module.export',
          'export' : '{path::out}/**',
          'criterion' : { debug : 1 },
        }
      },

      'build' :
      {
        'proto.export' :
        {
          'criterion' :
          {
            'export' : 1,
            'debug' : 1,
          },
          'steps' : [ 'step::export.*=1' ],
        }
      }
    };
    test.identical( config, exp );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      submodule :
      {
        eslint :
        {
          path : 'npm:///eslint#7.1.0',
          enabled : 1,
          criterion : { debug : 1 },
        },
        NpmFromWillfile :
        {
          path : 'npm:///npmfromwillfile',
          enabled : 1,
          criterion : { development : 0 }
        },
        wTesting :
        {
          path : 'npm:///wTesting',
          enabled : 0,
          criterion : { development : 1 }
        },
        newsubmodule :
        {
          path : 'hd://.',
          enabled : 1,
          criterion : { development : 1 }
        }
      },
      path :
      {
        'in' : '..',
        'out' : 'out',
        'out.debug' :
        {
          'path' : 'out/debug',
          'criterion' : { debug : 1 }
        },
        'out.release' :
        {
          'path' : 'out/release',
          'criterion' : { debug : 0 }
        },
        'new' : 'new'
      },
      reflector :
      {
        'proto.debug' :
        {
          'inherit' : 'predefined.*',
          'criterion' : { debug : 1 },
          'filePath' : { 'path::proto' : '{path::out.*=1}/source' }
        },
        'proto.release' :
        {
          'inherit' : 'predefined.*',
          'criterion' : { debug : 'release' },
          'filePath' : { 'path::proto' : '{path::out.*=1}/source' }
        },
        'proto.clean' :
        {
          'inherit' : 'predefined.*',
          'criterion' : { debug : 'delete' },
          'filePath' : '{path::out}'
        }
      },
      step :
      {
        'clean.debug' :
        {
          'inherit' : 'files.delete',
          'filePath' : 'path::out.*=1',
          'criterion' : { debug : 1 }
        },
        'clean.release' :
        {
          'inherit' : 'files.delete',
          'filePath' : 'path::out.*=1',
          'criterion' : { debug : 'release' }
        },
        'git.sync' : { 'inherit' : 'git.sync' }
      },
      build :
      {
        'debug' :
        {
          'criterion' : { default : 1, debug : 1 },
          'steps' : [ 'step::clean.*=1', 'proto.*=1' ]
        },
        'release' :
        {
          'criterion' : { debug : 0 },
          'steps' : [ 'step::clean.*=1', 'proto.*=1' ]
        },
        'git.sync' :
        {
          'steps' : [ 'git.sync' ]
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.extend.willfile Version *will.yml' })
  a.ready.then( ( op ) =>
  {
    test.case = 'try to rewrite data by self';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '1.1.1' );

    return null;
  })

  /* - */

  a.appStartNonThrowing({ args : '.willfile.extend.willfile Description* Author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'dst willfile selector has glob, should throw error';
    test.notIdentical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Description.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.about ).length, 1 );
    test.identical( config.about.author, undefined );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.extend.willfile Description Description' })
  a.ready.then( ( op ) =>
  {
    test.case = 'extend by self, should throw error';
    test.notIdentical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Description.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.extend.willfile Description NotKnown' })
  a.ready.then( ( op ) =>
  {
    test.case = 'extend by not existed file, should throw error';
    test.notIdentical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Description.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  })

  /* - */

  return a.ready;
}

//

function commandWillfileExtendWillfileDstIsJson( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.extend.willfile package.json Author* Contributors.will Description* Interpreters.will.yml format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new willfile, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.author, 'Author <author@dot.com>' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );
    test.identical( config.contributors.length, 2 );
    test.true( _.longHas( config.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( _.props.keys( config[ 'npm.engines' ] ).length, 3 );
    test.identical( config[ 'npm.engines' ].node, '>= 10.0.0' );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile NewFile Author.will Contributors Description* Interpreters format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new named json file, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.json' ), encoding : 'json' });
    test.identical( config.author, 'Author <author@dot.com>' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );
    test.identical( config.contributors.length, 2 );
    test.true( _.longHas( config.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( _.props.keys( config[ 'npm.engines' ] ).length, 3 );
    test.identical( config[ 'npm.engines' ].node, '>= 10.0.0' );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile Author.json Contributors Description* Interpreters format:"json"' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new data to existing config, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.json' ), encoding : 'json' });
    test.identical( config.author, undefined );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );
    test.identical( config.contributors.length, 2 );
    test.true( _.longHas( config.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( _.props.keys( config[ 'npm.engines' ] ).length, 3 );
    test.identical( config[ 'npm.engines' ].node, '>= 10.0.0' );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( '.ex.will.yml' ) );
    a.fileProvider.filesDelete( a.abs( '.im.will.yml' ) );
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  });

  a.appStart({ args : '.willfile.extend.willfile ./ files/p* format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'creating new config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    let exp =
    {
      'name' : 'willfilefromnpm',
      'version' : '0.0.0',
      'enabled' : 1,
      'description' : 'To check the conversion',
      'keywords' : [ 'tools', 'export' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'willfilefromnpm' : 'file:.', 'wTesting' : '' }
    };
    test.identical( config, exp );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  });

  a.appStart({ args : '.willfile.extend.willfile NewFile files/p* format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'creating new config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.json' ), encoding : 'json' });
    let exp =
    {
      'name' : 'willfilefromnpm',
      'version' : '0.0.0',
      'enabled' : 1,
      'description' : 'To check the conversion',
      'keywords' : [ 'tools', 'export' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'willfilefromnpm' : 'file:.', 'wTesting' : '' }
    };
    test.identical( config, exp );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileExtendWillfileWithOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.extend.willfile ForExtension Author* author:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field author';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author1@dot.com>' );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile ForExtension Keywords.will.yml keywords:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field keywords';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.keywords, [ 'wtools', 'common' ] );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile ForExtension Contributors.will.yml contributors:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field contributors';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    var exp = [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@xxx.com>', 'Contributor3 <contributor3@dot.com>' ];
    test.identical( config.about.contributors, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile ForExtension Interpreters.will.yml interpreters:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field interpreters';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    var exp = [ 'nodejs = 6.0.0', 'firefox >= 67.0.0', 'chromium >= 67.0.0' ];
    test.identical( config.about.interpreters, exp );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  });

  a.appStart({ args : '.willfile.extend.willfile ./.ex ForExtension about:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled section about';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'name' : 'NpmFromWillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'interpreters' : [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ],
      'keywords' : [ 'tools', 'export' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.name' : 'npmfromwillfile',
      'npm.scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
    };
    test.identical( config.about, exp );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  });

  a.appStart({ args : '.willfile.extend.willfile ./.ex ForExtension build:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled section build';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'proto.export' :
      {
        'criterion' : { 'export' : 1, 'debug' : 1 },
        'steps' : [ 'step::export.*=1' ]
      }
    };
    test.identical( config.build, exp );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  });

  a.appStart({ args : '.willfile.extend.willfile ./.ex ForExtension step:0 contributors:0 name:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled section step and fields contributors and name';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'name' : 'NpmFromWillfile',
      'description' : 'To check the extension',
      'version' : '1.1.1',
      'enabled' : 0,
      'interpreters' : [ 'njs = 6.0.0', 'chrome >= 60.0.0', 'firefox >= 67.0.0', 'chromium >= 67.0.0' ],
      'keywords' : [ 'tools', 'export', 'wtools', 'common' ],
      'license' : 'GPL',
      'author' : 'Author <author1@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.name' : 'willfileextend',
      'npm.scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto/wtools', 'eslint' : 'eslint proto' }
    };
    test.identical( config.about, exp );
    var exp =
    {
      'export.debug' :
      {
        'inherit' : 'module.export',
        'export' : '{path::out}/**',
        'criterion' : { 'debug' : 1 }
      }
    };
    test.identical( config.step, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile ./.im ForExtension submodulesDisabling:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'option submodulesDisabling';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'eslint' :
      {
        'path' : 'npm:///eslint#7.1.0',
        'enabled' : 0,
        'criterion' : { 'debug' : 1 }
      },
      'NpmFromWillfile' :
      {
        'path' : 'npm:///npmfromwillfile',
        'enabled' : 0,
        'criterion' : { 'development' : 0 }
      },
      'wTesting' :
      {
        'path' : 'npm:///wTesting',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'newsubmodule' :
      {
        'path' : 'hd://.',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      }
    };
    test.identical( config.submodule, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile Author ForExtension verbosity:5' })
  a.ready.then( ( op ) =>
  {
    test.case = 'option verbosity > 2';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ writing' ) );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.extend.willfile Author ForExtension v:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'option verbosity === 0';
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, '+ writing' ) );

    return null;
  });

  /* - */

  return a.ready;
}

commandWillfileExtendWillfileWithOptions.rapidity = -1;

//

function commandWillfileSupplementWillfileDstIsWillfile( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.supplement.willfile ./ Author*.yml Contributors Description* Interpreters' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new willfile, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, 'NpmFromWillfile' );
    test.identical( config.about.enabled, 1 );
    test.identical( config.about.contributors.length, 2 );
    test.true( _.longHas( config.about.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config.about.interpreters.length, 3 );
    test.true( _.longHas( config.about.interpreters, 'njs >= 6.0.0' ) );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile NewFile Author*.yml Contributors Description* Interpreters' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new named willfile, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, undefined );
    test.identical( config.about.enabled, undefined );
    test.identical( config.about.contributors.length, 2 );
    test.true( _.longHas( config.about.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config.about.interpreters.length, 3 );
    test.true( _.longHas( config.about.interpreters, 'njs >= 10.0.0' ) );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile Author Contributors Description* Interpreters' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new data to existing config, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author@dot.com>' );
    test.identical( config.about.name, undefined );
    test.identical( config.about.enabled, undefined );
    test.identical( config.about.contributors.length, 2 );
    test.true( _.longHas( config.about.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config.about.interpreters.length, 3 );
    test.true( _.longHas( config.about.interpreters, 'njs >= 10.0.0' ) );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile NewFile files/p*' })
  a.ready.then( ( op ) =>
  {
    test.case = 'creating new config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.will.yml' ), encoding : 'yaml' });
    let exp =
    {
      'about' :
      {
        'npm.name' : 'willfilefromnpm',
        'name' : 'willfilefromnpm',
        'version' : '0.0.0',
        'enabled' : 1,
        'description' : 'To check the conversion',
        'keywords' : [ 'tools', 'export' ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      },
      'path' :
      {
        'origins' :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///willfilefromnpm'
        ],
        'repository' : 'git+https:///github.com/author/NpmFromWillfile.git',
        'bugtracker' : 'https:///github.com/author/NpmFromWillfile/issues'
      },
      'submodule' :
      {
        'eslint' :
        {
          'path' : 'npm:///eslint!7.1.0',
          'enabled' : 1
        },
        'willfilefromnpm' :
        {
          'path' : 'hd://.',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        },
        'wTesting' :
        {
          'path' : 'npm:///wTesting',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile Author files/p*' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new data to existing config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.will.yml' ), encoding : 'yaml' });
    let exp =
    {
      'about' :
      {
        'npm.name' : 'willfilefromnpm',
        'name' : 'willfilefromnpm',
        'version' : '0.0.0',
        'enabled' : 1,
        'description' : 'To check the conversion',
        'keywords' : [ 'tools', 'export' ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ]
      },
      'path' :
      {
        'origins' :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///willfilefromnpm'
        ],
        'repository' : 'git+https:///github.com/author/NpmFromWillfile.git',
        'bugtracker' : 'https:///github.com/author/NpmFromWillfile/issues'
      },
      'submodule' :
      {
        'eslint' :
        {
          'path' : 'npm:///eslint!7.1.0',
          'enabled' : 1
        },
        'willfilefromnpm' :
        {
          'path' : 'hd://.',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        },
        'wTesting' :
        {
          'path' : 'npm:///wTesting',
          'enabled' : 1,
          'criterion' : { 'development' : 1 }
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile . ForExtension' })
  a.ready.then( ( op ) =>
  {
    test.case = 'extend two unnamed willfiles by new data';
    test.identical( op.exitCode, 0 );
    var config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      about :
      {
        'name' : 'NpmFromWillfile',
        'description' : 'To check the conversion',
        'version' : '0.0.0',
        'enabled' : 1,
        'interpreters' :
        [
          'njs >= 6.0.0',
          'chrome >= 60.0.0',
          'firefox >= 60.0.0',
          'chromium >= 67.0.0',
        ],
        'keywords' :
        [
          'tools',
          'export',
          'wtools',
          'common',
        ],
        'license' : 'MIT',
        'author' : 'Author <author@dot.com>',
        'contributors' :
        [
          'Contributor1 <contributor1@dot.com>',
          'Contributor2 <contributor2@dot.com>',
          'Contributor3 <contributor3@dot.com>',
        ],
        'npm.name' : 'npmfromwillfile',
        'npm.scripts' :
        {
          test : 'wtest .run proto/** v:5',
          docgen : 'wdocgen .build proto',
          eslint : 'eslint proto'
        },
      },

      path :
      {
        repository : 'git+https:///github.com/author/NpmFromWillfile.git',
        origins :
        [
          'git+https:///github.com/author/NpmFromWillfile.git',
          'npm:///npmfromwillfile'
        ],
        bugtracker : 'https:///github.com/author/NpmFromWillfile/issues',
      },
      step :
      {
        'export.debug' :
        {
          inherit : 'module.export',
          export : '{path::out}/**',
          criterion : { debug : 1 },
        }
      },

      build :
      {
        'proto.export' :
        {
          criterion :
          {
            export : 1,
            debug : 1,
          },
          steps : [ 'step::export.*=1' ],
        }
      }
    };
    test.identical( config, exp );

    var config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      submodule :
      {
        eslint :
        {
          path : 'npm:///eslint!7.1.0',
          enabled : 0,
          criterion : { debug : 1 },
        },
        NpmFromWillfile :
        {
          path : 'hd://.',
          enabled : 0,
          criterion : { 'development' : 1 }
        },
        wTesting :
        {
          path : 'npm:///wTesting',
          enabled : 0,
          criterion : { development : 1 }
        },
        newsubmodule :
        {
          path : 'hd://.',
          enabled : 1,
          criterion : { development : 1 }
        }
      },
      path :
      {
        'in' : '.',
        'out' : 'out',
        'out.debug' :
        {
          'path' : 'out/debug',
          'criterion' : { debug : 1 }
        },
        'out.release' :
        {
          'path' : 'out/release',
          'criterion' : { debug : 0 }
        },
        'new' : 'new'
      },
      reflector :
      {
        'proto.debug' :
        {
          'inherit' : 'predefined.*',
          'criterion' : { debug : 1 },
          'filePath' : { 'path::proto' : '{path::out.*=1}/source' }
        },
        'proto.release' :
        {
          'inherit' : 'predefined.*',
          'criterion' : { debug : 0 },
          'filePath' : { 'path::proto' : '{path::out.*=1}/source' }
        },
        'proto.clean' :
        {
          'inherit' : 'predefined.*',
          'criterion' : { debug : 'delete' },
          'filePath' : '{path::out}'
        }
      },
      step :
      {
        'clean.debug' :
        {
          'inherit' : 'files.delete',
          'filePath' : 'path::out.*=1',
          'criterion' : { debug : 1 }
        },
        'clean.release' :
        {
          'inherit' : 'files.delete',
          'filePath' : 'path::out.*=1',
          'criterion' : { debug : 0 }
        },
        'git.sync' : { 'inherit' : 'git.sync' }
      },
      build :
      {
        'debug' :
        {
          'criterion' : { default : 1, debug : 1 },
          'steps' : [ 'step::clean.*=1', 'proto.*=1' ]
        },
        'release' :
        {
          'criterion' : { debug : 0 },
          'steps' : [ 'step::clean.*=1', 'proto.*=1' ]
        },
        'git.sync' :
        {
          'steps' : [ 'git.sync' ]
        }
      }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile Version *will.yml' })
  a.ready.then( ( op ) =>
  {
    test.case = 'try to rewrite data by self';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Version.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.version, '0.0.0' );

    return null;
  })

  /* - */

  a.appStartNonThrowing({ args : '.willfile.supplement.willfile Description* Author' })
  a.ready.then( ( op ) =>
  {
    test.case = 'dst willfile selector has glob, should throw error';
    test.notIdentical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Description.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.about ).length, 1 );
    test.identical( config.about.author, undefined );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.supplement.willfile Description Description' })
  a.ready.then( ( op ) =>
  {
    test.case = 'extend by self, should throw error';
    test.notIdentical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Description.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  })

  a.appStartNonThrowing({ args : '.willfile.supplement.willfile Description NotKnown' })
  a.ready.then( ( op ) =>
  {
    test.case = 'extend by not existed file, should throw error';
    test.notIdentical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Description.will.yml' ), encoding : 'yaml' });
    test.identical( _.props.keys( config.about ).length, 1 );

    return null;
  })

  /* - */

  return a.ready;
}

//

function commandWillfileSupplementWillfileDstIsJson( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.supplement.willfile package Author* Contributors*.yml Description* Interpreters.will.yml format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new willfile, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( config.author, 'Author <author@dot.com>' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );
    test.identical( config.contributors.length, 2 );
    test.true( _.longHas( config.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config[ 'npm.engines' ], { 'node' : '>= 10.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' } );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.supplement.willfile NewFile Author*.yml Contributors Description* Interpreters format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'create new named json file, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.json' ), encoding : 'json' });
    test.identical( config.author, 'Author <author@dot.com>' );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );
    test.identical( config.contributors.length, 2 );
    test.true( _.longHas( config.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config[ 'npm.engines' ], { 'node' : '>= 10.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' } );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile Author.json Contributors Description* Interpreters format:"json"' })
  a.ready.then( ( op ) =>
  {
    test.case = 'add new data to existing config, unical data in each file';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Author.json' ), encoding : 'json' });
    test.identical( config.author, undefined );
    test.identical( config.name, undefined );
    test.identical( config.enabled, undefined );
    test.identical( config.contributors.length, 2 );
    test.true( _.longHas( config.contributors, 'Contributor1 <contributor1@dot.com>' ) );
    test.identical( config[ 'npm.engines' ], { 'node' : '>= 10.0.0', 'chrome' : '>= 60.0.0', 'firefox' : '>= 60.0.0' } );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesDelete( a.abs( '.ex.will.yml' ) );
    a.fileProvider.filesDelete( a.abs( '.im.will.yml' ) );
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile ./ files/p* format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'creating new config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    let exp =
    {
      'name' : 'willfilefromnpm',
      'version' : '0.0.0',
      'enabled' : 1,
      'description' : 'To check the conversion',
      'keywords' : [ 'tools', 'export' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'willfilefromnpm' : 'file:.', 'wTesting' : '' }
    };
    test.identical( config, exp );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect({ reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm' ) ] : a.abs( 'files' ) } });
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile NewFile files/p* format:json' })
  a.ready.then( ( op ) =>
  {
    test.case = 'creating new config from package.json file in another directory';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NewFile.json' ), encoding : 'json' });
    let exp =
    {
      'name' : 'willfilefromnpm',
      'version' : '0.0.0',
      'enabled' : 1,
      'description' : 'To check the conversion',
      'keywords' : [ 'tools', 'export' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'repository' : 'https://github.com/author/NpmFromWillfile.git',
      'bugs' : 'https://github.com/author/NpmFromWillfile/issues',
      'dependencies' : { 'eslint' : '7.1.0' },
      'devDependencies' : { 'willfilefromnpm' : 'file:.', 'wTesting' : '' }
    };
    test.identical( config, exp );

    return null;
  })

  /* - */

  return a.ready;
}

//

function commandWillfileSupplementWillfileWithOptions( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.reflectMinimal();

  /* - */

  a.appStart({ args : '.willfile.supplement.willfile ForExtension Author* author:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field author';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.author, 'Author <author1@dot.com>' );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile ForExtension Keywords.will.yml keywords:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field keywords';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.keywords, [ 'wtools', 'common' ] );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile ForExtension Contributors.will.yml contributors:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field contributors';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    var exp = [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@xxx.com>', 'Contributor3 <contributor3@dot.com>' ];
    test.identical( config.about.contributors, exp );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile ForExtension Interpreters.will.yml interpreters:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled field interpreters';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'ForExtension.will.yml' ), encoding : 'yaml' });
    var exp = [ 'nodejs = 6.0.0', 'firefox >= 67.0.0', 'chromium >= 67.0.0' ];
    test.identical( config.about.interpreters, exp );

    return null;
  })

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile ./.ex ForExtension about:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled section about';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'name' : 'NpmFromWillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'interpreters' : [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ],
      'keywords' : [ 'tools', 'export' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.name' : 'npmfromwillfile',
      'npm.scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto' },
    };
    test.identical( config.about, exp );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile ./.ex ForExtension build:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled section build';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'proto.export' :
      {
        'criterion' : { 'export' : 1, 'debug' : 1 },
        'steps' : [ 'step::export.*=1' ]
      }
    };
    test.identical( config.build, exp );

    return null;
  })

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    return null;
  })

  a.appStart({ args : '.willfile.supplement.willfile ./.ex ForExtension step:0 contributors:0 name:0' })
  a.ready.then( ( op ) =>
  {
    test.case = 'disabled section step and fields contributors and name';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'name' : 'NpmFromWillfile',
      'description' : 'To check the conversion',
      'version' : '0.0.0',
      'enabled' : 1,
      'interpreters' : [ 'njs = 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0', 'chromium >= 67.0.0' ],
      'keywords' : [ 'tools', 'export', 'wtools', 'common' ],
      'license' : 'MIT',
      'author' : 'Author <author@dot.com>',
      'contributors' : [ 'Contributor1 <contributor1@dot.com>', 'Contributor2 <contributor2@dot.com>' ],
      'npm.name' : 'npmfromwillfile',
      'npm.scripts' : { 'test' : 'wtest .run proto/** v:5', 'docgen' : 'wdocgen .build proto', 'eslint' : 'eslint proto' }
    };
    test.identical( config.about, exp );
    var exp =
    {
      'export.debug' :
      {
        'inherit' : 'module.export',
        'export' : '{path::out}/**',
        'criterion' : { 'debug' : 1 }
      }
    };
    test.identical( config.step, exp );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile ./.im ForExtension submodulesDisabling:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'option submodulesDisabling';
    test.identical( op.exitCode, 0 );
    let config = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });
    var exp =
    {
      'eslint' :
      {
        'path' : 'npm:///eslint!7.1.0',
        'enabled' : 0,
        'criterion' : { 'debug' : 1 }
      },
      'NpmFromWillfile' :
      {
        'path' : 'hd://.',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'wTesting' :
      {
        'path' : 'npm:///wTesting',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'newsubmodule' :
      {
        'path' : 'hd://.',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      }
    };
    test.identical( config.submodule, exp );

    return null;
  });

  /* */

  a.appStart({ args : '.willfile.supplement.willfile Author ForExtension verbosity:5' })
  a.ready.then( ( op ) =>
  {
    test.case = 'option verbosity > 2';
    test.identical( op.exitCode, 0 );
    test.true( _.strHas( op.output, '+ writing' ) );

    return null;
  })

  /* */

  a.appStart({ args : '.willfile.supplement.willfile Author ForExtension v:1' })
  a.ready.then( ( op ) =>
  {
    test.case = 'option verbosity < 2';
    test.identical( op.exitCode, 0 );
    test.true( !_.strHas( op.output, '+ writing' ) );

    return null;
  })

  /* - */

  return a.ready;
}

commandWillfileSupplementWillfileWithOptions.rapidity = -1;

//

function commandWillfileMergeIntoSingle( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single' });
  a.ready.then( ( op ) =>
  {
    test.case = 'without options';
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let partEx = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.ex.will.yml' ), encoding : 'yaml' });
    let partIm = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.im.will.yml' ), encoding : 'yaml' });
    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '-.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });

    test.identical( partEx, oldEx );
    test.identical( partIm, oldIm );

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    test.identical( config.about.interpreters, [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ] );
    test.identical( partEx.about.interpreters, [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ] );
    delete config.about.interpreters;
    delete partEx.about.interpreters;
    test.contains( config, partEx );
    test.identical( config.submodule.eslint.criterion.development, 1 );
    test.identical( partIm.submodule.eslint.criterion.debug, 1 );
    delete config.submodule.eslint.criterion.development;
    delete partIm.submodule.eslint.criterion.debug;
    test.contains( config, partIm );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'NamedWillfile.im.will.yml' ), a.abs( '.im.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'NamedWillfile.ex.will.yml' ), a.abs( '.ex.will.yml' ) );

    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-NamedWillfile.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-NamedWillfile.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single primaryPath:NamedWillfile' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - name';
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-NamedWillfile.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-NamedWillfile.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.will.yml' ) ) );

    let partEx = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.ex.will.yml' ), encoding : 'yaml' });
    let partIm = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.im.will.yml' ), encoding : 'yaml' });
    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '-NamedWillfile.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '-NamedWillfile.im.will.yml' ), encoding : 'yaml' });

    test.identical( partEx, oldEx );
    test.identical( partIm, oldIm );

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NamedWillfile.will.yml' ), encoding : 'yaml' });
    test.identical( config.about.interpreters, [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ] );
    test.identical( partEx.about.interpreters, [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ] );
    delete config.about.interpreters;
    delete partEx.about.interpreters;
    test.contains( config, partEx );
    test.identical( config.submodule.eslint.criterion.development, 1 );
    test.identical( partIm.submodule.eslint.criterion.debug, 1 );
    delete config.submodule.eslint.criterion.development;
    delete partIm.submodule.eslint.criterion.debug;

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect
    ({
      reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm/package.json' ) ] : a.abs( 'was.package.json' ) }
    });
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single secondaryPath:"was.package.json"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'secondaryPath - path to json file';
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let partEx = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.ex.will.yml' ), encoding : 'yaml' });
    let partIm = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.im.will.yml' ), encoding : 'yaml' });
    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '-.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });

    test.identical( partEx, oldEx );
    test.identical( partIm, oldIm );

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    let submodulesSection =
    {
      'eslint' :
      {
        'path' : 'npm:///eslint!7.1.0',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'NpmFromWillfile' :
      {
        'path' : 'hd://.',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'wTesting' :
      {
        'path' : 'npm:///wTesting',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
    };
    test.identical( config.submodule, submodulesSection );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect
    ({
      reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm/package.json' ) ] : a.abs( 'was.package.json' ) }
    });
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'NamedWillfile.im.will.yml' ), a.abs( '.im.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'NamedWillfile.ex.will.yml' ), a.abs( '.ex.will.yml' ) );

    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-NamedWillfile.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-NamedWillfile.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single primaryPath:NamedWillfile secondaryPath:"was.package.json"' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - name, secondaryPath - path to json file';
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-NamedWillfile.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-NamedWillfile.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.will.yml' ) ) );

    let partEx = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.ex.will.yml' ), encoding : 'yaml' });
    let partIm = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.im.will.yml' ), encoding : 'yaml' });
    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '-NamedWillfile.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '-NamedWillfile.im.will.yml' ), encoding : 'yaml' });

    test.identical( partEx, oldEx );
    test.identical( partIm, oldIm );

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NamedWillfile.will.yml' ), encoding : 'yaml' });
    let submodulesSection =
    {
      'eslint' :
      {
        'path' : 'npm:///eslint!7.1.0',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'NpmFromWillfile' :
      {
        'path' : 'hd://.',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'wTesting' :
      {
        'path' : 'npm:///wTesting',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
    };
    test.identical( config.submodule, submodulesSection );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.filesReflect
    ({
      reflectMap : { [ a.abs( context.assetsOriginalPath, 'willfileFromNpm/package.json' ) ] : a.abs( 'was.package.json' ) }
    });
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'NamedWillfile.im.will.yml' ), a.abs( '.im.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'NamedWillfile.ex.will.yml' ), a.abs( '.ex.will.yml' ) );

    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-NamedWillfile.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-NamedWillfile.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single primaryPath:NamedWillfile secondaryPath:"was.package.json" submodulesDisabling:0' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - name, secondaryPath - path to json file, submodulesDisabling - 0';
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'NamedWillfile.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-NamedWillfile.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-NamedWillfile.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'NamedWillfile.will.yml' ) ) );

    let partEx = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.ex.will.yml' ), encoding : 'yaml' });
    let partIm = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.im.will.yml' ), encoding : 'yaml' });
    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '-NamedWillfile.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '-NamedWillfile.im.will.yml' ), encoding : 'yaml' });

    test.identical( partEx, oldEx );
    test.identical( partIm, oldIm );

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NamedWillfile.will.yml' ), encoding : 'yaml' });
    let submodulesSection =
    {
      'eslint' :
      {
        'path' : 'npm:///eslint!7.1.0',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'NpmFromWillfile' :
      {
        'path' : 'hd://.',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
      'wTesting' :
      {
        'path' : 'npm:///wTesting',
        'enabled' : 0,
        'criterion' : { 'development' : 1 }
      },
    };
    test.identical( config.submodule, submodulesSection );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileMergeIntoSingleRunWith( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    return null;
  });

  a.appStart({ args : '.with . .willfile.merge.into.single' });
  a.ready.then( ( op ) =>
  {
    test.case = 'without options';
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let partEx = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.ex.will.yml' ), encoding : 'yaml' });
    let partIm = a.fileProvider.fileRead({ filePath : a.abs( 'Copy.im.will.yml' ), encoding : 'yaml' });
    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '-.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });

    test.identical( partEx, oldEx );
    test.identical( partIm, oldIm );

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    test.identical( config.about.interpreters, [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ] );
    test.identical( partEx.about.interpreters, [ 'njs >= 6.0.0', 'chrome >= 60.0.0', 'firefox >= 60.0.0' ] );
    delete config.about.interpreters;
    delete partEx.about.interpreters;
    test.contains( config, partEx );
    test.identical( config.submodule.eslint.criterion.development, 1 );
    test.identical( partIm.submodule.eslint.criterion.debug, 1 );
    delete config.submodule.eslint.criterion.development;
    delete partIm.submodule.eslint.criterion.debug;
    test.contains( config, partIm );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileMergeIntoSingleWithSeveralRuns( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.with . .willfile.merge.into.single' });
  a.appStart({ args : '.with . .willfile.merge.into.single' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    var exp = 'Directory has no willfiles to merge. Please, define valid {-primaryPath-} and {-secondaryPath-}';
    test.identical( _.strCount( op.output, exp ), 1 );
    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileMergeIntoSinglePrimaryPathIsDirectory( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single primaryPath:out/ secondaryPath:./' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - directory, willfile does not exists, secondaryPath - path to unnamed willfiles';
    test.identical( op.exitCode, 0 );

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );

    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/will.yml' ), encoding : 'yaml' });
    test.contains( config, oldEx );
    oldIm.submodule.eslint.criterion.development = 1;
    delete oldIm.submodule.eslint.criterion.debug;
    test.contains( config, oldIm );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'out/Named.will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single primaryPath:out/Named secondaryPath:.' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - directory with named willfile, willfile does not exists, secondaryPath - path to unnamed willfiles';
    test.identical( op.exitCode, 0 );

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/Named.will.yml' ) ) );

    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/Named.will.yml' ), encoding : 'yaml' });
    test.contains( config, oldEx );
    oldIm.submodule.eslint.criterion.development = 1;
    delete oldIm.submodule.eslint.criterion.debug;
    test.contains( config, oldIm );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.dirMake( a.abs( 'out' ) );
    a.fileProvider.fileCopy( a.abs( 'out/will.yml' ), a.abs( 'Author.will.yml' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );
    return null;
  });

  a.appStartNonThrowing({ args : '.willfile.merge.into.single primaryPath:out/ secondaryPath:./' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - directory, unnamed willfile exists, force - 0, should throw error';
    test.notIdentical( op.exitCode, 0 );
    var exp = /Destination file .* already exists\. Please, rename or delete file before merge/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    a.fileProvider.dirMake( a.abs( 'out' ) );
    a.fileProvider.fileCopy( a.abs( 'out/will.yml' ), a.abs( 'Author.will.yml' ) );
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );
    return null;
  });

  a.appStartNonThrowing({ args : '.willfile.merge.into.single primaryPath:out/ secondaryPath:./ force:1' });
  a.ready.then( ( op ) =>
  {
    test.case = 'primaryPath - directory, unnamed willfile exists, force - 1, should overwrite willfile';
    test.identical( op.exitCode, 0 );

    let oldEx = a.fileProvider.fileRead({ filePath : a.abs( '.ex.will.yml' ), encoding : 'yaml' });
    let oldIm = a.fileProvider.fileRead({ filePath : a.abs( '.im.will.yml' ), encoding : 'yaml' });

    let config = a.fileProvider.fileRead({ filePath : a.abs( 'out/will.yml' ), encoding : 'yaml' });
    test.contains( config, oldEx );
    oldIm.submodule.eslint.criterion.development = 1;
    delete oldIm.submodule.eslint.criterion.debug;
    test.contains( config, oldIm );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileMergeIntoSingleWithDuplicatedSubmodules( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    submodulesDuplicate();

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single secondaryPath:Submodule.will.yml' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let willConfig = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    let imWillConfig = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });
    let submoduleConfig = a.fileProvider.fileRead({ filePath : a.abs( 'Submodule.will.yml' ), encoding : 'yaml' });

    let willConfigKeys = _.props.keys( willConfig.submodule );
    var exp = [ 'eslint', 'NpmFromWillfile', 'wTesting', 'babel', 'willbe' ];
    test.identical( willConfigKeys, exp );
    let imWillConfigKeys = _.props.keys( imWillConfig.submodule );
    var exp = [ 'eslint', 'NpmFromWillfile', 'wTesting' ];
    test.identical( imWillConfigKeys, exp );
    let submoduleConfigkeys = _.props.keys( submoduleConfig.submodule );
    var exp =
    [
      'eslint',
      'babel',
      'NpmFromWillfile',
      'wTesting',
      'willbe',
      'ESLINT',
      'BABEL',
      'NPMFROMWILLFILE',
      'WTESTING',
      'WILLBE'
    ];
    test.identical( submoduleConfigkeys, exp );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    submodulesDuplicate();

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single secondaryPath:Submodule.will.yml filterSameSubmodules:0' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let willConfig = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    let imWillConfig = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });
    let submoduleConfig = a.fileProvider.fileRead({ filePath : a.abs( 'Submodule.will.yml' ), encoding : 'yaml' });

    let willConfigKeys = _.props.keys( willConfig.submodule );
    var exp =
    [
      'eslint',
      'NpmFromWillfile',
      'wTesting',
      'babel',
      'willbe',
      'ESLINT',
      'BABEL',
      'NPMFROMWILLFILE',
      'WTESTING',
      'WILLBE'
    ];
    test.identical( willConfigKeys, exp );
    let imWillConfigKeys = _.props.keys( imWillConfig.submodule );
    var exp = [ 'eslint', 'NpmFromWillfile', 'wTesting' ];
    test.identical( imWillConfigKeys, exp );
    let submoduleConfigkeys = _.props.keys( submoduleConfig.submodule );
    var exp =
    [
      'eslint',
      'babel',
      'NpmFromWillfile',
      'wTesting',
      'willbe',
      'ESLINT',
      'BABEL',
      'NPMFROMWILLFILE',
      'WTESTING',
      'WILLBE'
    ];
    test.identical( submoduleConfigkeys, exp );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function submodulesDuplicate()
  {
    test.case = 'filterSameSubmodules - 1';
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'Submodule.will.yml' ), encoding : 'yaml' });
    let keys = _.props.keys( config.submodule );
    for( let i = 0 ; i < keys.length ; i++ )
    config.submodule[ keys[ i ].toUpperCase() ] = config.submodule[ keys[ i ] ];
    a.fileProvider.fileWrite({ filePath : a.abs( 'Submodule.will.yml' ), data : config, encoding : 'yaml' });
  }
}

//

function commandWillfileMergeIntoSingleWithDiffSubmoduleRecord( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesRemoteRepos' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let willConfig = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    let imWillConfig = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });

    var exp =
    {
      wModuleForTesting1 :
      {
        path : 'git+https:///github.com/Wandalen/wModuleForTesting1.git/out/wModuleForTesting1.out.will!gamma',
        enabled : 0,
      },
      wModuleForTesting2 :
      {
        path : 'git+https:///github.com/Wandalen/wModuleForTesting2.git/out/wModuleForTesting2.out.will!gamma',
        enabled : 0,
      },
    };
    test.identical( willConfig.submodule, exp );
    var exp =
    {
      ModuleForTesting1 : 'git+https:///github.com/Wandalen/wModuleForTesting1.git/out/wModuleForTesting1.out.will!gamma',
      ModuleForTesting2 : 'git+https:///github.com/Wandalen/wModuleForTesting2.git/out/wModuleForTesting2.out.will!gamma',
    };
    test.identical( imWillConfig.submodule, exp );

    return null;
  });

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    var config = a.fileProvider.fileReadUnknown( a.abs( '.im.will.yml' ) );
    config.submodule[ 'ModuleForTesting1' ] = { path : 'git+https:///github.com/Wandalen/wModuleForTesting1.git', enabled : 1 };
    a.fileProvider.fileWrite({ filePath : a.abs( '.im.will.yml' ), data : config, encoding : 'yaml' });
    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let willConfig = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    let imWillConfig = a.fileProvider.fileRead({ filePath : a.abs( '-.im.will.yml' ), encoding : 'yaml' });

    var exp =
    {
      wModuleForTesting1 :
      {
        path : 'git+https:///github.com/Wandalen/wModuleForTesting1.git',
        enabled : 0,
      },
      wModuleForTesting2 :
      {
        path : 'git+https:///github.com/Wandalen/wModuleForTesting2.git/out/wModuleForTesting2.out.will!gamma',
        enabled : 0,
      },
    };
    test.identical( willConfig.submodule, exp );
    var exp =
    {
      ModuleForTesting1 : { path : 'git+https:///github.com/Wandalen/wModuleForTesting1.git', enabled : 1 },
      ModuleForTesting2 : 'git+https:///github.com/Wandalen/wModuleForTesting2.git/out/wModuleForTesting2.out.will!gamma',
    };
    test.identical( imWillConfig.submodule, exp );

    return null;
  });

  /* - */

  return a.ready;
}

//

function commandWillfileMergeIntoSingleFilterNpmFields( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );

  /* - */

  a.ready.then( () =>
  {
    a.reflectMinimal();
    npmScriptsDuplicate();

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'out/will.yml' ) ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.ex.will.yml' ), a.abs( '.ex.will.yml' ) );
    a.fileProvider.fileCopy( a.abs( 'Copy.im.will.yml' ), a.abs( '.im.will.yml' ) );
    return null;
  });

  a.appStart({ args : '.willfile.merge.into.single secondaryPath:NpmScripts.will.yml' });
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '-.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );

    let willConfig = a.fileProvider.fileRead({ filePath : a.abs( 'will.yml' ), encoding : 'yaml' });
    let exWillConfig = a.fileProvider.fileRead({ filePath : a.abs( '-.ex.will.yml' ), encoding : 'yaml' });
    let npmScriptsConfig = a.fileProvider.fileRead({ filePath : a.abs( 'NpmScripts.will.yml' ), encoding : 'yaml' });

    let willConfigKeys = _.props.keys( willConfig.about[ 'npm.scripts' ] );
    var exp = [ 'test.test', 'TEST', 'docgen.docgen', 'DOCGEN' ];
    test.identical( willConfigKeys, exp );
    let exWillConfigKeys = _.props.keys( exWillConfig.about[ 'npm.scripts' ] );
    var exp = [ 'test', 'docgen' ];
    test.identical( exWillConfigKeys, exp );
    let npmScriptsConfigKeys = _.props.keys( npmScriptsConfig.about[ 'npm.scripts' ] );
    var exp =
    [
      'test',
      'docgen',
      'test-test',
      'test.test',
      'TEST',
      'docgen-docgen',
      'docgen.docgen',
      'DOCGEN'
    ];
    test.identical( npmScriptsConfigKeys, exp );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function npmScriptsDuplicate()
  {
    let config = a.fileProvider.fileRead({ filePath : a.abs( 'NpmScripts.will.yml' ), encoding : 'yaml' });
    let keys = _.props.keys( config.about[ 'npm.scripts' ] );
    for( let i = 0 ; i < keys.length ; i++ )
    {
      config.about[ 'npm.scripts' ][ `${ keys[ i ] }-${ keys[ i ] }` ] = config.about[ 'npm.scripts' ][ keys[ i ] ];
      config.about[ 'npm.scripts' ][ `${ keys[ i ] }.${ keys[ i ] }` ] = config.about[ 'npm.scripts' ][ keys[ i ] ];
      config.about[ 'npm.scripts' ][ keys[ i ].toUpperCase() ] = config.about[ 'npm.scripts' ][ keys[ i ] ];
    }
    a.fileProvider.fileWrite({ filePath : a.abs( 'NpmScripts.will.yml' ), data : config, encoding : 'yaml' });
  }
}

//

function commandNpmPublish( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  let config, tagOriginal, tag, moduleName;
  a.fileProvider.dirMake( a.abs( '.' ) );

  let botUser = 'wtools-bot';
  let botRepo = 'WillbeNpmPublishTest';
  let botPass = process.env.PRIVATE_WTOOLS_BOT_NPM_PASS;
  let botEmail = process.env.PRIVATE_WTOOLS_BOT_EMAIL;
  if( !_.process.insideTestContainer() || !botPass || !botEmail )
  return test.true( true );

  a.start = _.process.starter
  ({
    execPath : 'node ' + context.appJsPath,
    currentPath : a.routinePath,
    outputCollecting : 1,
    mode : 'spawn',
    outputGraying : 1,
    throwingExitCode : 1,
  });

  /* - */

  repoPrepare();
  tagsAndModuleNameGet();

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is not changed, should exit publishing';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    return null;
  });

  a.ready.then( ( op ) => a.start( `.imply withSubmodules:0 .npm.publish tag:${ tagOriginal }` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:${ tagOriginal }"` ), 1 );
    test.identical( _.strCount( op.output, '. Read 3 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is not changed, should exit publishing, v - 7';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    return null;
  });

  a.ready.then( ( op ) => a.start( `.imply withSubmodules:0 .npm.publish tag:${ tagOriginal } v:7` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:${ tagOriginal } v:7"` ), 1 );
    test.identical( _.strCount( op.output, '. Read 3 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is not changed, different tag, dry - 1, should exit publishing';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    return null;
  });

  a.ready.then( ( op ) => a.start( `.imply withSubmodules:0 .npm.publish tag:${ tag } dry:1` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:${ tag } dry:1"` ), 1 );
    test.ge( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, '. Read 3 willfile(s)' ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is not changed, different tag, should publish';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    return null;
  });

  a.ready.then( ( op ) => a.start( `.imply withSubmodules:0 .npm.publish tag:${ tag }` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.notIdentical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:${ tag }"` ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 0 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `+ writing` ), 1 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `> git add --all` ), 1 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 2 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag ${ tag }` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is not changed, publish with force - 1';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    return null;
  });

  a.ready.then( () => a.start( `.imply withSubmodules:0 .npm.publish force:1 tag:${ tagOriginal }` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.notIdentical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish force:1 tag:${ tagOriginal }"` ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 0 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `+ writing` ), 1 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `> git add --all` ), 1 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 2 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag ${ tagOriginal }` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is changed, dry - 1, publish should exit with committing';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    a.fileProvider.fileAppend( a.abs( 'doc/VersionLog.txt' ), `${ config.version }\n` );
    return null;
  });

  a.ready.then( () => a.start( `.imply withSubmodules:0 .npm.publish tag:${ tagOriginal } dry:1` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.identical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:${ tagOriginal } dry:1"` ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 0 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `> git commit -am "."` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `+ writing` ), 0 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `> git add --all` ), 1 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 0 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 0 );
    test.identical( _.strCount( op.output, `Creating tag ${ tagOriginal }` ), 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is changed, publish with default commit message';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    a.fileProvider.fileAppend( a.abs( 'doc/VersionLog.txt' ), `${ config.version }\n` );
    return null;
  });

  a.ready.then( () => a.start( `.imply withSubmodules:0 .npm.publish tag:${ tagOriginal }` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( `package.json` ), encoding : `json` });
    test.notIdentical( configAfter.version, config.version );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:${ tagOriginal }"` ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 0 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "."` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `+ writing` ), 1 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `> git add --all` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 3 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag ${ tagOriginal }` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is changed, publish with commit message';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    a.fileProvider.fileAppend( a.abs( 'doc/VersionLog.txt' ), `${ config.version }\n` );
    return null;
  });

  a.ready.then( () => a.start( `.imply withSubmodules:0 .npm.publish -am 'Update module' tag:${ tagOriginal }` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.notIdentical( configAfter.version, config.version );

    var exp = `Command ".imply withSubmodules:0 .npm.publish -am "Update module" tag:${ tagOriginal }"`;
    test.identical( _.strCount( op.output, exp ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 0 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "Update module"` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `+ writing` ), 1 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `> git add --all` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 3 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag ${ tagOriginal }` ), 1 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'repo is changed, publish with commit message, v - 7';
    config = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    a.fileProvider.fileAppend( a.abs( 'doc/VersionLog.txt' ), `${ config.version }\n` );
    return null;
  });

  a.ready.then( () => a.start( `.imply withSubmodules:0 .npm.publish -am 'Update module' tag:${ tagOriginal } v:7` ) );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configAfter = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    test.notIdentical( configAfter.version, config.version );

    var exp = `Command ".imply withSubmodules:0 .npm.publish -am "Update module" tag:${ tagOriginal } v:7"`;
    test.identical( _.strCount( op.output, exp ), 1 );
    test.ge( _.strCount( op.output, `. Opened .` ), 6 );
    test.identical( _.strCount( op.output, `. Read 3 willfile(s)` ), 1 );
    test.identical( _.strCount( op.output, `x Nothing to publish in module::${ moduleName }` ), 0 );
    test.identical( _.strCount( op.output, `Committing module::${ moduleName }` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "Update module"` ), 1 );
    test.identical( _.strCount( op.output, `+ Publishing module::${ moduleName } at` ), 1 );
    test.identical( _.strCount( op.output, `+ writing` ), 3 );
    test.identical( _.strCount( op.output, `Exporting module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `Exported module::${ moduleName }` ), 1 );
    test.identical( _.strCount( op.output, `"name" : "${ configAfter.name }"` ), 1 );
    test.identical( _.strCount( op.output, `"keywords" : [ "wTools" ]` ), 1 );
    test.identical( _.strCount( op.output, `"license" : "MIT"` ), 1 );
    test.identical( _.strCount( op.output, `> git add --all` ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configAfter.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::${ moduleName }` ), 3 );
    test.identical( _.strCount( op.output, `Creating tag v${ configAfter.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag ${ tagOriginal }` ), 1 );
    test.identical( _.strCount( op.output, `> npm publish --tag ${ tagOriginal }` ), 1 );
    test.identical( _.strCount( op.output, `+ ${ configAfter.name }@${ configAfter.version }` ), 1 );

    return null;
  });

  /* */

  npmLogout();

  /* - */

  return a.ready;

  /* */

  function repoPrepare()
  {
    a.shell( `git clone https://github.com/${ botUser }/${ botRepo }.git .` );
    a.shell( 'npm i -g npm-cli-login' );
    a.shell
    ({
      execPath : `npm-cli-login -u ${ botUser } -p ${ botPass } -e ${ botEmail } --quotes`,
      outputPiping : 0,
      inputMirroring : 0
    });
    return a.ready;
  }

  /* */

  function tagsAndModuleNameGet()
  {
    a.ready.then( () =>
    {
      const pkgConfig = a.fileProvider.fileReadUnknown( a.abs( 'package.json' ) );
      tagOriginal = pkgConfig.devDependencies.wTesting;
      tag = tagOriginal === 'alpha' ? 'gamma' : 'alpha';
      const willConfig = a.fileProvider.fileReadUnknown( a.abs( '.ex.will.yml' ) );
      moduleName = willConfig.about.name;
      return null;
    });
    return a.ready;
  }

  /* */

  function npmLogout()
  {
    a.shell( 'npm logout' );
  }
}

commandNpmPublish.timeOut = 500000;

//

function commandNpmPublishFullModuleFromUtility( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.fileProvider.dirMake( a.abs( '.' ) );

  let botUser = 'wtools-bot';
  let botRepo = 'PublishCommandTest1';
  let botPass = process.env.PRIVATE_WTOOLS_BOT_NPM_PASS;
  let botEmail = process.env.PRIVATE_WTOOLS_BOT_EMAIL;
  if( !_.process.insideTestContainer() || !botPass || !botEmail )
  return test.true( true );

  /* - */

  npmLogin();

  /* */

  repoPrepare();
  setVersionInWasPackageJson();

  /* */

  a.ready.then( () =>
  {
    test.case = 'publish from scratch';
    a.fileProvider.filesDelete( a.abs( 'out' ) );

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'Old.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'Old.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart( `.willfile.merge.into.single secondaryPath:'was.package.json'` );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'Old.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'Old.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart( `.imply withSubmodules:0 .npm.publish tag:latest` );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configPackage = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    let configWasPackage = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'was.package.json' ), encoding : 'json' });
    test.identical( configPackage.name, configWasPackage.name );
    test.notIdentical( configPackage.version, configWasPackage.version );
    test.notIdentical( configPackage.enabled, configWasPackage.enabled );
    test.notIdentical( configPackage.engine, configWasPackage.engine );
    test.identical( configPackage.description, configWasPackage.description );
    test.identical( configPackage.keywords, configWasPackage.keywords );
    test.identical( configPackage.license, configWasPackage.license );
    test.identical( configPackage.author, configWasPackage.author );
    test.identical( configPackage.contributors.length, configWasPackage.contributors.length );
    test.identical( configPackage.bin, configWasPackage.bin );
    test.notIdentical( configPackage.repository, configWasPackage.repository );
    test.notIdentical( configPackage.bugs, configWasPackage.bugs );
    test.identical( configPackage.main, configWasPackage.main );
    test.identical( configPackage.files, configWasPackage.files );
    let packageDepKeys = _.props.keys( configPackage.dependencies );
    let wasPackageDepKeys = _.props.keys( configWasPackage.dependencies );
    test.true( _.longHasAll( packageDepKeys, wasPackageDepKeys ) );
    test.false( 'wgittools' in configWasPackage.dependencies );
    test.identical( packageDepKeys.length, 30 );
    test.identical( wasPackageDepKeys.length, 29 );
    let packageDevDepKeys = _.props.keys( configPackage.devDependencies );
    let wasPackageDevDepKeys = _.props.keys( configWasPackage.devDependencies );
    test.true( _.longHasAll( packageDevDepKeys, wasPackageDevDepKeys ) );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:latest"` ), 1 );
    test.ge( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'x Nothing to publish in module::PublishCommandTest1' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::PublishCommandTest1' ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "."` ), 1 );
    test.identical( _.strCount( op.output, '+ Publishing module::PublishCommandTest1 at' ), 1 );
    test.identical( _.strCount( op.output, '+ writing' ), 2 );
    test.identical( _.strCount( op.output, 'Exporting module::PublishCommandTest1' ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::PublishCommandTest1' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configPackage.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::PublishCommandTest1` ), 3 );
    test.identical( _.strCount( op.output, `Creating tag v${ configPackage.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag latest` ), 1 );

    return null;
  });

  /* */

  npmLogout();

  /* - */

  return a.ready;

  /* */

  function npmLogin()
  {
    a.shell( 'npm i -g npm-cli-login' );
    a.shell
    ({
      execPath : `npm-cli-login -u ${ botUser } -p ${ botPass } -e ${ botEmail } --quotes`,
      outputPiping : 0,
      inputMirroring : 0
    });
    return a.ready;
  }

  /* */

  function repoPrepare()
  {
    a.shell( `git clone https://github.com/${ botUser }/${ botRepo }.git .` );
    a.shell( `git reset --hard v0.0.0` );
    a.shell( `git push -u origin --all --force` );
    a.shell( `git push --tags --force` );
    return a.ready;
  }

  /* */

  function setVersionInWasPackageJson()
  {
    return a.ready.then( () =>
    {
      let moduleName = botRepo.toLowerCase();
      let filePath = a.abs( 'was.package.json' );
      let config = a.fileProvider.fileRead({ filePath, encoding : 'json' });
      let lastVersion = _.npm.remoteVersionLatest( `npm:///${ moduleName }!latest` );
      config.version = lastVersion;
      a.fileProvider.fileWrite({ filePath, data : config, encoding : 'json' });
      return null;
    });
  }

  /* */

  function npmLogout()
  {
    a.shell( 'npm logout' );
  }
}

//

function commandNpmPublishFullRegularModule( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmFromWillfile' );
  a.fileProvider.dirMake( a.abs( '.' ) );

  let botUser = 'wtools-bot';
  let botRepo = 'PublishCommandTest2';
  let botPass = process.env.PRIVATE_WTOOLS_BOT_NPM_PASS;
  let botEmail = process.env.PRIVATE_WTOOLS_BOT_EMAIL;
  if( !_.process.insideTestContainer() || !botPass || !botEmail )
  return test.true( true );

  /* - */

  npmLogin();

  /* */

  repoPrepare();
  setVersionInWasPackageJson();

  /* */

  a.ready.then( () =>
  {
    test.case = 'publish from scratch';
    a.fileProvider.filesDelete( a.abs( 'out' ) );

    test.true( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'Old.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'Old.ex.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart( `.willfile.merge.into.single secondaryPath:'was.package.json'` );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( a.fileProvider.fileExists( a.abs( '.im.will.yml' ) ) );
    test.false( a.fileProvider.fileExists( a.abs( '.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'Old.im.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'Old.ex.will.yml' ) ) );
    test.true( a.fileProvider.fileExists( a.abs( 'will.yml' ) ) );
    return null;
  });

  a.appStart( `.imply withSubmodules:0 .npm.publish tag:latest` );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    let configPackage = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'package.json' ), encoding : 'json' });
    let configWasPackage = a.fileProvider.fileReadUnknown({ filePath : a.abs( 'was.package.json' ), encoding : 'json' });
    test.identical( configPackage.name, configWasPackage.name );
    test.notIdentical( configPackage.version, configWasPackage.version );
    test.notIdentical( configPackage.enabled, configWasPackage.enabled );
    test.notIdentical( configPackage.engine, configWasPackage.engine );
    test.identical( configPackage.description, configWasPackage.description );
    test.identical( configPackage.keywords, configWasPackage.keywords );
    test.identical( configPackage.license, configWasPackage.license );
    test.identical( configPackage.author, configWasPackage.author );
    test.identical( configPackage.contributors.length, 2 );
    test.identical( configWasPackage.contributors, undefined );
    test.identical( configPackage.bin, configWasPackage.bin );
    test.notIdentical( configPackage.repository, configWasPackage.repository );
    test.notIdentical( configPackage.bugs, configWasPackage.bugs );
    test.identical( configPackage.main, configWasPackage.main );
    test.identical( configPackage.files, configWasPackage.files );
    let packageDepKeys = _.mapKeys( configPackage.dependencies );
    let wasPackageDepKeys = _.mapKeys( configWasPackage.dependencies );
    test.true( _.longHasAll( packageDepKeys, wasPackageDepKeys ) );
    test.false( 'wgittools' in configWasPackage.dependencies );
    test.identical( packageDepKeys.length, 4 );
    test.identical( wasPackageDepKeys.length, 4 );
    let packageDevDepKeys = _.mapKeys( configPackage.devDependencies );
    let wasPackageDevDepKeys = _.mapKeys( configWasPackage.devDependencies );
    test.true( _.longHasAll( packageDevDepKeys, wasPackageDevDepKeys ) );

    test.identical( _.strCount( op.output, `Command ".imply withSubmodules:0 .npm.publish tag:latest"` ), 1 );
    test.ge( _.strCount( op.output, '. Opened .' ), 0 );
    test.identical( _.strCount( op.output, 'x Nothing to publish in module::PublishCommandTest2' ), 0 );
    test.identical( _.strCount( op.output, 'Committing module::PublishCommandTest2' ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "."` ), 1 );
    test.identical( _.strCount( op.output, '+ Publishing module::PublishCommandTest2 at' ), 1 );
    test.identical( _.strCount( op.output, '+ writing' ), 2 );
    test.identical( _.strCount( op.output, 'Exporting module::PublishCommandTest2' ), 1 );
    test.identical( _.strCount( op.output, 'Exported module::PublishCommandTest2' ), 1 );
    test.identical( _.strCount( op.output, '> git add --all' ), 2 );
    test.identical( _.strCount( op.output, `> git commit -am "version ${ configPackage.version }"` ), 1 );
    test.identical( _.strCount( op.output, `Pushing module::PublishCommandTest2` ), 3 );
    test.identical( _.strCount( op.output, `Creating tag v${ configPackage.version }` ), 1 );
    test.identical( _.strCount( op.output, `Creating tag latest` ), 1 );

    return null;
  });

  /* */

  npmLogout();

  /* - */

  return a.ready;

  /* */

  function npmLogin()
  {
    a.shell( 'npm i -g npm-cli-login' );
    a.shell
    ({
      execPath : `npm-cli-login -u ${ botUser } -p ${ botPass } -e ${ botEmail } --quotes`,
      outputPiping : 0,
      inputMirroring : 0
    });
    return a.ready;
  }

  /* */

  function repoPrepare()
  {
    a.shell( `git clone https://github.com/${ botUser }/${ botRepo }.git .` );
    a.shell( `git reset --hard v0.0.0` );
    a.shell( `git push -u origin --all --force` );
    a.shell( `git push --tags --force` );
    return a.ready;
  }

  /* */

  function setVersionInWasPackageJson()
  {
    return a.ready.then( () =>
    {
      let moduleName = botRepo.toLowerCase();
      let filePath = a.abs( 'was.package.json' );
      let config = a.fileProvider.fileRead({ filePath, encoding : 'json' });
      let lastVersion = _.npm.remoteVersionLatest( `npm:///${ moduleName }!latest` );
      config.version = lastVersion;
      a.fileProvider.fileWrite({ filePath, data : config, encoding : 'json' });
      return null;
    });
  }

  /* */

  function npmLogout()
  {
    a.shell( 'npm logout' );
  }
}

//

function commandNpmDepAdd( test )
{
  let context = this;
  let a = context.assetFor( test, 'npmDepAdd' );

  /* - */

  begin().then( () =>
  {
    test.case = 'without options, only subject - dot';
    return null;
  });
  a.appStart( '.npm.dep.add . editing:0' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.areSoftLinked( a.abs( 'node_modules/test' ), a.abs( '.' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './test', './wmodulefortesting2' ] );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add . editing:0"' ), 1 );
    var exp = /Linking hd:\/\/\/.*\/commandNpmDepAdd to .*\/commandNpmDepAdd\/node_modules\/test/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'without options, only subject - module';
    return null;
  });
  a.shell( 'git clone https://github.com/Wandalen/wModuleForTesting1.git wModuleForTesting1' );
  a.appStart( '\'.npm.dep.add "hd://./wModuleForTesting1" editing:0\'' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.areSoftLinked( a.abs( 'node_modules/wmodulefortesting1' ), a.abs( 'wModuleForTesting1' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './wmodulefortesting1', './wmodulefortesting2' ] );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add "hd://./wModuleForTesting1" editing:0"' ), 1 );
    var exp =
    /Linking hd:\/\/\/.*\/commandNpmDepAdd\/wModuleForTesting1 to .*\/commandNpmDepAdd\/node_modules\/wmodulefortesting1/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'as === module.name, dry - 1';
    return null;
  });
  a.appStart( '.npm.dep.add . editing:0 as:test dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( a.fileProvider.areSoftLinked( a.abs( 'node_modules/test' ), a.abs( '.' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './wmodulefortesting2' ] );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add . editing:0 as:test dry:1"' ), 1 );
    var exp = /Linking hd:\/\/\/.*\/commandNpmDepAdd to .*\/commandNpmDepAdd\/node_modules\/test/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'dry - 1';
    return null;
  });
  a.appStart( '.npm.dep.add . editing:0 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( a.fileProvider.areSoftLinked( a.abs( 'node_modules/test' ), a.abs( '.' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './wmodulefortesting2' ] );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add . editing:0 dry:1"' ), 1 );
    var exp = /Linking hd:\/\/\/.*\/commandNpmDepAdd to .*\/commandNpmDepAdd\/node_modules\/test/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'as !== module.name';
    return null;
  });
  a.appStart( '.npm.dep.add . editing:0 as:wmodulefortesting1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.areSoftLinked( a.abs( 'node_modules/wmodulefortesting1' ), a.abs( '.' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './wmodulefortesting1', './wmodulefortesting2' ] );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add . editing:0 as:wmodulefortesting1"' ), 1 );
    var exp = /Linking hd:\/\/\/.*\/commandNpmDepAdd to .*\/commandNpmDepAdd\/node_modules\/wmodulefortesting1/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* */

  let filesBefore;
  begin().then( () =>
  {
    test.case = 'rewrite soft link to module by another link';
    return null;
  });
  a.shell( 'git clone https://github.com/Wandalen/wModuleForTesting1.git wModuleForTesting1' );
  a.appStart( '\'.npm.dep.add "hd://./wModuleForTesting1" editing:0\'' );
  a.ready.then( ( op ) =>
  {
    filesBefore = a.find( a.abs( 'wModuleForTesting1' ) );

    test.identical( op.exitCode, 0 );
    test.true( a.fileProvider.areSoftLinked( a.abs( 'node_modules/wmodulefortesting1' ), a.abs( 'wModuleForTesting1' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './wmodulefortesting1', './wmodulefortesting2' ] );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add "hd://./wModuleForTesting1" editing:0"' ), 1 );
    var exp =
    /Linking hd:\/\/\/.*\/commandNpmDepAdd\/wModuleForTesting1 to .*\/commandNpmDepAdd\/node_modules\/wmodulefortesting1/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });
  a.appStart( '.npm.dep.add . editing:0 as:wmodulefortesting1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( a.fileProvider.areSoftLinked( a.abs( 'node_modules/wmodulefortesting1' ), a.abs( 'wModuleForTesting1' ) ) );
    test.true( a.fileProvider.areSoftLinked( a.abs( 'node_modules/wmodulefortesting1' ), a.abs( '.' ) ) );
    var files = find( 'node_modules' );
    test.identical( files, [ '.', './wmodulefortesting1', './wmodulefortesting2' ] );
    var files = find( 'node_modules' )
    test.identical( files, [ '.', './wmodulefortesting1', './wmodulefortesting2' ] );
    var filesAfter = a.find( a.abs( 'wModuleForTesting1' ) );
    test.identical( filesBefore, filesAfter );

    test.identical( _.strCount( op.output, 'Command ".npm.dep.add . editing:0 as:wmodulefortesting1"' ), 1 );
    var exp = /Linking hd:\/\/\/.*\/commandNpmDepAdd to .*\/commandNpmDepAdd\/node_modules\/wmodulefortesting1/;
    test.identical( _.strCount( op.output, exp ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    a.ready.then( () =>
    {
      a.fileProvider.dirMake( a.abs( 'node_modules' ) );
      a.fileProvider.dirMake( a.abs( 'node_modules/wmodulefortesting2' ) );
      return null;
    });
    return a.ready;
  }

  /* */

  function find( filePath )
  {
    return a.fileProvider.filesFind
    ({
      filePath : a.abs( filePath ),
      filter : { recursive : 1 },
      outputFormat : 'relative',
      withDirs : 1,
    });
  }
}

//

function commandNpmInstall( test )
{
  let self = this;
  let a = test.assetFor( 'npmDepAdd' );

  /* - */

  begin().then( () =>
  {
    test.case = 'default options, package-lock.json exists';
    return null;
  });
  a.appStart( '.npm.install' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 6 )
    var exp = [ '.', './.package-lock.json', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );
    test.identical( versionGet( 'wmodulefortesting1' ), '0.0.134' );
    test.identical( versionGet( 'wmodulefortesting2' ), '0.0.125' );
    test.identical( versionGet( 'wmodulefortesting12' ), '0.0.125' );

    test.identical( _.strCount( op.output, 'Command ".npm.install"' ), 1 );
    test.identical( _.strCount( op.output, '> npm ci' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'locked - 0, package-lock.json exists';
    return null;
  });
  a.appStart( '.npm.install locked:0' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 6 )
    var exp = [ '.', './.package-lock.json', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );
    test.notIdentical( versionGet( 'wmodulefortesting1' ), '0.0.134' );
    test.notIdentical( versionGet( 'wmodulefortesting2' ), '0.0.125' );
    test.notIdentical( versionGet( 'wmodulefortesting12' ), '0.0.125' );

    test.identical( _.strCount( op.output, 'Command ".npm.install locked:0"' ), 1 );
    test.identical( _.strCount( op.output, '> npm install' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'locked - 0, package-lock.json not exists';
    a.fileProvider.filesDelete( a.abs( 'package-lock.json' ) );
    return null;
  });
  a.appStart( '.npm.install locked:0' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 6 )
    var exp = [ '.', './.package-lock.json', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );
    test.notIdentical( versionGet( 'wmodulefortesting1' ), '0.0.134' );
    test.notIdentical( versionGet( 'wmodulefortesting2' ), '0.0.125' );
    test.notIdentical( versionGet( 'wmodulefortesting12' ), '0.0.125' );

    test.identical( _.strCount( op.output, 'Command ".npm.install locked:0"' ), 1 );
    test.identical( _.strCount( op.output, '> npm install' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'locked - 1, package-lock.json exists';
    return null;
  });
  a.appStart( '.npm.install locked:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 6 )
    var exp = [ '.', './.package-lock.json', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );
    test.identical( versionGet( 'wmodulefortesting1' ), '0.0.134' );
    test.identical( versionGet( 'wmodulefortesting2' ), '0.0.125' );
    test.identical( versionGet( 'wmodulefortesting12' ), '0.0.125' );

    test.identical( _.strCount( op.output, 'Command ".npm.install locked:1"' ), 1 );
    test.identical( _.strCount( op.output, '> npm ci' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'linkingSelf - 0';
    return null;
  });
  a.appStart( '.npm.install locked:1 linkingSelf:0' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 5 )
    var exp = [ '.', './.package-lock.json', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );
    test.identical( versionGet( 'wmodulefortesting1' ), '0.0.134' );
    test.identical( versionGet( 'wmodulefortesting2' ), '0.0.125' );
    test.identical( versionGet( 'wmodulefortesting12' ), '0.0.125' );

    test.identical( _.strCount( op.output, 'Command ".npm.install locked:1 linkingSelf:0"' ), 1 );
    test.identical( _.strCount( op.output, '> npm ci' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 0 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'linkingSelf - 1';
    return null;
  });
  a.appStart( '.npm.install linkingSelf:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 6 )
    var exp = [ '.', './.package-lock.json', './test', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );
    test.identical( versionGet( 'wmodulefortesting1' ), '0.0.134' );
    test.identical( versionGet( 'wmodulefortesting2' ), '0.0.125' );
    test.identical( versionGet( 'wmodulefortesting12' ), '0.0.125' );

    test.identical( _.strCount( op.output, 'Command ".npm.install linkingSelf:1"' ), 1 );
    test.identical( _.strCount( op.output, '> npm ci' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 1 );

    return null;
  });

  /* */

  begin().then( () =>
  {
    test.case = 'dry - 1';
    return null;
  });
  a.appStart( '.npm.install locked:0 linkingSelf:1 dry:1' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    test.identical( files, [] );

    test.identical( _.strCount( op.output, 'Command ".npm.install locked:0 linkingSelf:1 dry:1"' ), 1 );
    test.identical( _.strCount( op.output, '> npm install' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 1 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    a.ready.then( () => a.reflect() );
    return a.ready;
  }

  /* */

  function find( filePath )
  {
    return a.fileProvider.filesFind
    ({
      filePath : a.abs( filePath ),
      filter : { recursive : 1 },
      outputFormat : 'relative',
      withDirs : 1,
    });
  }

  /* */

  function versionGet( dirName )
  {
    return a.fileProvider.configRead
    ({
      filePath : a.abs( 'node_modules', dirName, 'package.json' ),
      encoding : 'json',
    }).version;
  }
}

//

function commandNpmInstallFromPackageWithoutName( test )
{
  let self = this;
  let a = test.assetFor( 'npmDepAdd' );
  a.fileProvider.dirMake( a.abs( '.' ) );

  /* - */

  begin().then( () =>
  {
    test.case = 'default option linkingSelf, should not link';
    return null;
  });
  a.appStart( '.npm.install' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 5 )
    var exp = [ '.', './.package-lock.json', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Command ".npm.install"' ), 1 );
    test.identical( _.strCount( op.output, '> npm install' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = 'linkingSelf - 0, should not link';
    return null;
  });
  a.appStart( '.npm.install linkingSelf:0' );
  a.ready.then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 5 )
    var exp = [ '.', './.package-lock.json', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Command ".npm.install linkingSelf:0"' ), 1 );
    test.identical( _.strCount( op.output, '> npm install' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 0 );

    return null;
  });

  begin().then( () =>
  {
    test.case = 'linkingSelf - 1, should throw error';
    return null;
  });
  a.appStartNonThrowing( '.npm.install linkingSelf:1' );
  a.ready.then( ( op ) =>
  {
    test.notIdentical( op.exitCode, 0 );
    var files = find( 'node_modules' );
    var exp = [ '.', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    if( files.length === 5 )
    var exp = [ '.', './.package-lock.json', './wmodulefortesting1', './wmodulefortesting12', './wmodulefortesting2' ];
    test.identical( files, exp );

    test.identical( _.strCount( op.output, 'Command ".npm.install linkingSelf:1"' ), 1 );
    test.identical( _.strCount( op.output, '> npm install' ), 1 );
    test.identical( _.strCount( op.output, /Linking hd:\/\/.*\/commandNpmInstall to .*\/commandNpmInstall\/node_modules\/test/ ), 0 );

    return null;
  });

  /* - */

  return a.ready;

  /* */

  function begin()
  {
    const data =
    {
      dependencies :
      {
        wmodulefortesting1 : '',
        wmodulefortesting12 : '',
      }
    };
    a.ready.then( () =>
    {
      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.fileProvider.fileWriteUnknown({ filePath : a.abs( 'package.json' ), data });
      return null;
    });
    return a.ready;
  }

  /* */

  function find( filePath )
  {
    return a.fileProvider.filesFind
    ({
      filePath : a.abs( filePath ),
      filter : { recursive : 1 },
      outputFormat : 'relative',
      withDirs : 1,
    });
  }
}

//

function commandsSubmoduleSafety( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesSafety' );

  a.rooWillFilePath = a.abs( '.will.yml' );
  a.localPath = a.abs( '.module/ModuleForTesting1' );

  a.rootWillFileRead = () => a.fileProvider.fileRead({ filePath : a.rooWillFilePath });
  a.rootWillFileWrite = ( data ) => a.fileProvider.fileWrite({ filePath : a.rooWillFilePath, data });
  a.moduleGitStatusGet = () =>
  {
    return _.git.statusLocal
    ({
      localPath : a.localPath,
      uncommitted : 1,
      detailing : 1,
      sync : 1,
    });
  };
  a.moduleFilesGet = () =>
  {
    return a.fileProvider.filesFind
    ({
      filePath : a.localPath,
      filter : { recursive : 2 },
      maskPreset : 0,
      outputFormat : 'absolute'
    });
  };
  a.moduleFixateTag = ( tag ) =>
  {
    let data = a.rootWillFileRead();
    data = _.strReplace( data, '/!master', `/!${tag}` );
    a.rootWillFileWrite( data );
  };
  a.moduleShell = _.process.starter
  ({
    currentPath : a.localPath,
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  });

  let routinesPre = Object.create( null );
  let routinesPost = Object.create( null );
  let outputMap = Object.create( null );
  routineForCasesRegister();

  /* - */

  run({ command : 'download', case : 'missing/tag', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'missing/tag', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'download', case : 'invalid/url', downloaded : 1, error : 1 });
  run({ command : 'download', case : 'invalid/url', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'download', case : 'local/untracked', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'local/unstaged', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'local/staged', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'local/commit', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'local/branch', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'local/tag', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'local/conflict', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'notGitReporOrNpmModule', downloaded : 1, error : 1 });
  run({ command : 'download', case : 'different/origin', downloaded : 1, error : 0 });
  run({ command : 'download', case : 'different/branch', downloaded : 1, error : 0 });

  /* - */

  run({ command : 'update', case : 'missing/tag', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'missing/tag', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'update', case : 'invalid/url', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'invalid/url', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'update', case : 'local/untracked', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'local/unstaged', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'local/staged', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'local/commit', downloaded : 1, error : 0 });
  run({ command : 'update', case : 'local/branch', downloaded : 1, error : 0 });
  run({ command : 'update', case : 'local/tag', downloaded : 1, error : 0 });
  run({ command : 'update', case : 'local/conflict', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'notGitReporOrNpmModule', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'different/origin', downloaded : 1, error : 1 });
  run({ command : 'update', case : 'different/branch', downloaded : 1, error : 0 });

  /* - */

  run({ command : 'versions.verify', case : 'missing/tag', downloaded : 1, error : 1 });
  run({ command : 'versions.verify', case : 'missing/tag', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'versions.verify', case : 'invalid/url', downloaded : 1, error : 0, deleted : 0 });
  run({ command : 'versions.verify', case : 'invalid/url', downloaded : 0, error : 0, deleted : 1 });
  // run({ command : 'versions.verify', case : 'invalid/url', downloaded : 1, error : 1 }); // aaa: Vova: fails, error is ignored /* Dmytro : fixed, routine commandSubmodulesVersionsVerify use routine _commandCleanLike that allows invalid submodules */
  // run({ command : 'versions.verify', case : 'invalid/url', downloaded : 0, error : 1 }); // aaa: Vova: fails, error is ignored /* Dmytro : fixed, routine commandSubmodulesVersionsVerify use routine _commandCleanLike that allows invalid submodules */
  run({ command : 'versions.verify', case : 'local/untracked', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'local/unstaged', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'local/staged', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'local/commit', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'local/branch', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'local/tag', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'local/conflict', downloaded : 1, error : 0 });
  run({ command : 'versions.verify', case : 'notGitReporOrNpmModule', downloaded : 1, error : 1 });
  run({ command : 'versions.verify', case : 'different/origin', downloaded : 1, error : 1 });
  run({ command : 'versions.verify', case : 'different/branch', downloaded : 1, error : 1 });

  /* - */

  run({ command : 'clean', case : 'missing/tag', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', case : 'missing/tag', downloaded : 0, error : 0, deleted : 1 });
  run({ command : 'clean', case : 'invalid/url', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', case : 'invalid/url', downloaded : 0, error : 0, deleted : 1 });
  run({ command : 'clean', case : 'local/untracked', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'local/unstaged', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'local/staged', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'local/commit', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'local/branch', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'local/tag', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'local/conflict', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'clean', case : 'notGitReporOrNpmModule', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', case : 'different/origin', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', case : 'different/branch', downloaded : 1, error : 0, deleted : 1 });

  /* - */

  run({ command : 'clean', options : 'force:1', case : 'missing/tag', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'missing/tag', downloaded : 0, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'invalid/url', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'invalid/url', downloaded : 0, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/untracked', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/unstaged', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/staged', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/commit', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/branch', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/tag', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'local/conflict', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'notGitReporOrNpmModule', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'different/origin', downloaded : 1, error : 0, deleted : 1 });
  run({ command : 'clean', options : 'force:1', case : 'different/branch', downloaded : 1, error : 0, deleted : 1 });

  /* - */

  run({ command : 'versions.agree', case : 'missing/tag', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'versions.agree', case : 'missing/tag', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'versions.agree', case : 'invalid/url', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'versions.agree', case : 'invalid/url', downloaded : 0, error : 1, deleted : 1 });
  run({ command : 'versions.agree', case : 'local/untracked', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'versions.agree', case : 'local/unstaged', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'versions.agree', case : 'local/staged', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'versions.agree', case : 'local/commit', downloaded : 1, error : 0, deleted : 0 });
  run({ command : 'versions.agree', case : 'local/branch', downloaded : 1, error : 0, deleted : 0 });
  run({ command : 'versions.agree', case : 'local/tag', downloaded : 1, error : 0, deleted : 0 });
  run({ command : 'versions.agree', case : 'local/conflict', downloaded : 1, error : 1, deleted : 0 });
  run({ command : 'versions.agree', case : 'notGitReporOrNpmModule', downloaded : 1, error : 0, redownloaded : 1 });
  run({ command : 'versions.agree', case : 'different/origin', downloaded : 1, error : 0, redownloaded : 1 });
  run({ command : 'versions.agree', case : 'different/branch', downloaded : 1, error : 0, deleted : 0 });

  /* - */

  function run( env )
  {
    a.ready.then( () =>
    {
      test.case = `${_.entity.exportStringSolo( env )}`;
      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflectMinimal();
      return null;
    })

    if( env.downloaded )
    {
      a.appStart({ args : '.submodules.download' });
      a.ready.then( () =>
      {
        env.isGitRepo = _.git.isRepository({ localPath : a.localPath });
        env.isNpmModule = _.npm.isRepository({ localPath : a.localPath });
        if( env.isGitRepo )
        env.moduleGitStatusBefore = a.moduleGitStatusGet();
        env.moduleFilesBefore = a.moduleFilesGet();
        return null;
      })
    }

    a.ready.then( () =>
    {
      if( _.longHas( [ 'update', 'versions.agree' ], env.command ) )
      if( env.case !== 'missing/tag' )
      {
        a.moduleFixateTag( 'dev1' );
      }

      if( routinesPre[ env.case ] )
      return routinesPre[ env.case ]( env ) || true;
      return null;
    });

    let op = { args : `.submodules.${env.command}` };
    if( env.command === 'clean' )
    op = { args : `.clean.submodules ${ env.options ? env.options : '' }` };

    a.appStart( op );

    a.ready.tap( ( err, arg ) =>
    {
      let isGitModuleInCurrentState = _.git.isRepository({ localPath : a.localPath });
      if( _.longHas( [ 'update', 'versions.agree' ], env.command ) && isGitModuleInCurrentState )
      {
        let branch = _.git.tagLocalRetrive( a.localPath );

        if( env.error )
        test.identical( branch, 'master' );
        else
        test.identical( branch, 'dev1' );

        if( !env.error )
        a.moduleShell( 'git checkout master' );
      }

      if( routinesPost[ env.case ] )
      routinesPost[ env.case ]( env );
    })

    if( env.error )
    a.ready.finally( ( err, op ) =>
    {
      if( err )
      {
        _.errAttend( err );
        _.errLogOnce( err );
      }
      test.true( _.errIs( err ) );
      return null;
    })

    a.ready.then( () =>
    {
      if( env.error )
      test.notIdentical( op.exitCode, 0 );
      else
      test.identical( op.exitCode, 0 );

      var expectedOutput = _.select({ src : outputMap, selector : `${env.case}/${env.command}` });
      if( _.object.isBasic( expectedOutput ) )
      expectedOutput = _.select({ src : expectedOutput, selector : `downloaded:${env.downloaded}` });
      if( expectedOutput )
      _.each( _.array.as( expectedOutput ), ( expected ) => test.true( _.strHas( op.output, expected ) ) );

      let moduleDirExists = a.fileProvider.isDir( a.localPath );

      if( env.deleted )
      test.false( moduleDirExists );
      else
      test.true( moduleDirExists );

      if( !moduleDirExists )
      return null;

      env.moduleFilesAfter = a.moduleFilesGet();

      if( env.redownloaded )
      {
        test.le( env.moduleFilesBefore.length, env.moduleFilesAfter.length );
        let config = _.git.configRead( a.localPath );
        let originUrl = config[ 'remote "origin"' ].url;
        let expected = 'https://github.com/Wandalen/wModuleForTesting1.git';
        test.identical( originUrl, expected );
      }
      else
      {
        test.ge( env.moduleFilesAfter.length, env.moduleFilesBefore.length );
      }

      if( env.isGitRepo )
      {
        test.true( _.git.isRepository({ localPath : a.localPath }) );
        env.moduleGitStatusAfter = a.moduleGitStatusGet();
        test.identical( env.moduleGitStatusAfter, env.moduleGitStatusBefore );
      }
      else
      {
        test.true( _.npm.isRepository({ localPath : a.localPath }) );
      }

      return null;
    })
  }

  /* - */

  function routineForCasesRegister()
  {
    routinesPre[ 'missing/tag' ] = () =>
    {
      let data = a.rootWillFileRead();
      data = _.strReplace( data, '/!master', '/!missing' );
      a.rootWillFileWrite( data );
    }

    _.select
    ({
      src : outputMap,
      selector : 'missing/tag',
      set :
      {
        'versions.verify' :
        {
          'downloaded:0' : `does not have files`,
          'downloaded:1' : `doesn't exist in local and remote copy of the repository`
        },
      }
    })

    routinesPre[ 'invalid/url' ] = () =>
    {
      let data = a.rootWillFileRead();
      data = _.strReplace( data, 'git+https', 'test+https' );
      a.rootWillFileWrite( data );
    }

    routinesPre[ 'local/untracked' ] = ( env ) =>
    {
      let filePath = a.path.join( a.localPath, 'untracked' + _.idWithTime() );
      a.fileProvider.fileWrite({ filePath, data : ' ' });
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }

    routinesPre[ 'local/unstaged' ] = ( env ) =>
    {
      let filePath = a.path.join( a.localPath, 'Readme.md');
      a.fileProvider.fileWrite({ filePath, data : ' ' });
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }
    _.select
    ({
      src : outputMap,
      selector : 'local/unstaged',
      set : { update : `needs to be updated, but has local changes` }
    })

    routinesPre[ 'local/staged' ] = ( env ) =>
    {
      let filePath = a.path.join( a.localPath, 'Readme.md');
      a.fileProvider.fileWrite({ filePath, data : ' ' });
      a.moduleShell( 'git add Readme.md' );
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }
    _.select
    ({
      src : outputMap,
      selector : 'local/staged',
      set : { update : `needs to be updated, but has local changes` }
    })

    routinesPre[ 'local/commit' ] = ( env ) =>
    {
      a.moduleShell( 'git commit --allow-empty -m test' );
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }

    routinesPre[ 'local/branch' ] = ( env ) =>
    {
      a.moduleShell( 'git branch test' );
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }

    routinesPre[ 'local/tag' ] = ( env ) =>
    {
      a.moduleShell( 'git tag test' );
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }

    routinesPre[ 'local/conflict' ] = ( env ) =>
    {
      a.moduleShell( 'git branch dev1' );
      let filePath = a.path.join( a.localPath, 'Readme.md');
      let data = a.fileProvider.fileRead({ filePath });

      a.moduleShell( 'git checkout dev1' );
      let data2 = 'dev1 ' + data;
      a.fileProvider.fileWrite({ filePath, data : data2 });
      a.moduleShell( 'git commit -am test' );

      a.moduleShell( 'git checkout master' );
      let data3 = 'master ' + data;
      a.fileProvider.fileWrite({ filePath, data : data3 });
      a.moduleShell( 'git commit -am test' );
      a.moduleShell( 'git merge dev1' );

      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }
    _.select
    ({
      src : outputMap,
      selector : 'local/conflict',
      set : { update : `needs to be updated, but has local changes` }
    })

    routinesPre[ 'notGitReporOrNpmModule' ] = ( env ) =>
    {
      if( env.isGitRepo )
      a.fileProvider.fileRename( a.path.join( a.localPath, '.git_disabled' ), a.path.join( a.localPath, '.git' ) );
      if( env.isNpmModule )
      a.fileProvider.fileRename( a.path.join( a.localPath, 'package_disabled.json' ), a.path.join( a.localPath, 'package.json' ) );
      a.moduleFilesBefore = a.moduleFilesGet();
    }
    routinesPost[ 'notGitReporOrNpmModule' ] = ( env ) =>
    {
      if( env.deleted || env.redownloaded )
      return;
      if( env.isGitRepo )
      a.fileProvider.fileRename( a.path.join( a.localPath, '.git' ), a.path.join( a.localPath, '.git_disabled' ) );
      if( env.isNpmModule )
      a.fileProvider.fileRename( a.path.join( a.localPath, 'package.json' ), a.path.join( a.localPath, 'package_disabled.json' ) );
    }

    _.select
    ({
      src : outputMap,
      selector : 'notGitReporOrNpmModule',
      set :
      {
        'download' : `it's not a git repository or npm module`,
        'update' : `it's not a git repository or npm module`,
        'versions.verify' : `is downloaded, but it's not a repository`
      }
    })

    routinesPre[ 'different/origin' ] = () =>
    {
      a.moduleShell( 'git remote set-url origin https://github.com/Wandalen/SomeModule.git' );
    }
    _.select
    ({
      src : outputMap,
      selector : 'different/origin',
      set :
      {
        'update' : `but has different origin`,
        'versions.verify' : `has different origin url`,
      }
    })

    routinesPre[ 'different/branch' ] = ( env ) =>
    {
      a.moduleShell( 'git checkout dev1' );
      env.moduleGitStatusBefore = a.moduleGitStatusGet();
    }
    _.select
    ({
      src : outputMap,
      selector : 'different/branch',
      set :
      {
        'versions.verify' : `has version different from that is specified in will-file`
      }
    })
  }

  /* - */

  return a.ready;
}

commandsSubmoduleSafety.rapidity = 1;
commandsSubmoduleSafety.routineTimeOut = 12000000;
commandsSubmoduleSafety.description =
`
Checks if .submodules.* commands are safe to use in different situations.
It means that utility doesn't modify the data of the module if it's not required.
`;

//

function commandsSubmoduleSafetyDownloadInvalidUrl( test ) /* xxx : for Kos */ /* Dmytro : used namespace `repo` for classifying of repo paths, test routine works fine */
{
  let context = this;
  let a = context.assetFor( test, 'submodulesSafety' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'downloaded submodules';
    a.reflect();
    return null;
  });
  a.appStart({ args : `.submodules.download` });
  a.ready.then( () =>
  {
    let data = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ) })
    data = _.strReplace( data, 'git+https', 'test+https' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data })
    return null;
  });

  var op = { args : `.submodules.download` };
  a.appStart( op );
  a.ready.finally( ( err, got ) =>
  {
    if( err )
    _.errAttend( err );

    test.true( _.errIs( err ) );
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'not downloaded submodules';
    a.reflect();
    let data = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ) })
    data = _.strReplace( data, 'git+https', 'test+https' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data })
    return null;
  });

  var op = { args : `.submodules.download` };
  a.appStart( op );
  a.ready.finally( ( err, got ) =>
  {
    if( err )
    _.errAttend( err );

    test.true( _.errIs( err ) );
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  /* - */

  return a.ready;
}

commandsSubmoduleSafetyDownloadInvalidUrl.description =
`
Should throw error about invalid protocol in remote path.
`;

//

function commandsSubmoduleSafetyVerifyInvalidUrl( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesSafety' );

  /* - */

  a.ready.then( () =>
  {
    test.case = 'downloaded submodules';
    a.reflect();
    return null;
  });
  a.appStart({ args : `.submodules.download` });
  a.ready.then( () =>
  {
    let data = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ) })
    data = _.strReplace( data, 'git+https', 'test+https' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data })
    return null;
  });

  var op = { args : `.submodules.versions.verify` };
  a.appStart( op );
  a.ready.finally( ( err, got ) =>
  {
    if( err )
    _.errAttend( err );

    test.false( _.errIs( err ) );
    test.notIdentical( op.exitCode, 0 );

    return null;
  });

  /* */

  a.ready.then( () =>
  {
    test.case = 'not downloaded submodules';
    a.reflect();
    let data = a.fileProvider.fileRead({ filePath : a.abs( '.will.yml' ) })
    data = _.strReplace( data, 'git+https', 'test+https' );
    a.fileProvider.fileWrite({ filePath : a.abs( '.will.yml' ), data })
    return null;
  });

  var op = { args : `.submodules.versions.verify` };
  a.appStart( op );
  a.ready.finally( ( err, got ) =>
  {
    if( err )
    _.errAttend( err );

    test.false( _.errIs( err ) );
    test.identical( op.exitCode, 0 );

    return null;
  });

  /* - */

  return a.ready;
}

commandsSubmoduleSafetyVerifyInvalidUrl.description =
`
Should not throw error about invalid protocol
because command routine use routine _commandCleanLike
that allows invalid submodules.
`;

//

function commandSubmodulesUpdateOptionTo( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesUpdateTo' );

  a.localPath = a.abs( '.module/ModuleForTesting' );
  a.remotePath = a.abs( 'module' );

  a.moduleShellSync = _.process.starter
  ({
    currentPath : a.abs( 'module' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.moduleDownloadedShell = _.process.starter
  ({
    currentPath : a.abs( '.module/ModuleForTesting' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 0,
    deasync : 0,
    ready : a.ready
  })

  a.moduleDownloadedShellSync = _.process.starter
  ({
    currentPath : a.abs( '.module/ModuleForTesting' ),
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.init = () =>
  {
    a.ready.then( () =>
    {
      a.fileProvider.filesDelete( a.abs( '.' ) );
      a.reflect();
      a.willFileBefore = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
      a.moduleShellSync( 'git init && git add -fA . && git commit -m initial' )
      a.moduleShellSync( 'git tag dev1' )
      return null;
    })
    a.appStart( '.submodules.download' );
    return a.ready;
  }

  /* - */

  a.init()
  a.appStart( '.submodules.update to:!dev1' )
  .then( ( op ) =>
  {
    test.case = 'switch to dev1 after download'
    test.identical( op.exitCode, 0 );
    var got = a.moduleDownloadedShellSync( 'git status' )
    test.true( _.strHas( got.output, `HEAD detached at dev1` ) );
    let tagVersionLocal = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 1, remote : 0 });
    let tagVersionRemote = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 0, remote : 1 });
    test.identical( tagVersionLocal, tagVersionRemote );
    let willFileAftet = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    test.identical( willFileAftet, a.willFileBefore );

    return null;
  })

  /* - */

  a.init()
  .then( () =>
  {
    test.case = 'switch to dev1 after tag update on the remote, should update local tag'
    a.moduleDownloadedShellSync( 'git fetch --tags' );
    a.moduleShellSync( 'git commit --allow-empty -m test' )
    a.moduleShellSync( 'git tag -f dev1' )
    let tagVersionLocal = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 1, remote : 0 });
    let tagVersionRemote = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 0, remote : 1 });
    test.notIdentical( tagVersionLocal, tagVersionRemote );
    return null;
  })
  a.appStart( '.submodules.update to:!dev1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var got = a.moduleDownloadedShellSync( 'git status' )
    test.true( _.strHas( got.output, `HEAD detached at dev1` ) );
    let tagVersionLocal = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 1, remote : 0 });
    let tagVersionRemote = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 0, remote : 1 });
    test.identical( tagVersionLocal, tagVersionRemote );
    let willFileAftet = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    test.identical( willFileAftet, a.willFileBefore );
    return null;
  })

  /* - */

  a.init()
  .then( () =>
  {
    test.case = 'switch to dev2, new tag was created on the remote after download'
    a.moduleDownloadedShellSync( 'git fetch --tags' )
    a.moduleShellSync( 'git commit --allow-empty -m test' )
    a.moduleShellSync( 'git tag dev2' )
    return null;
  })
  a.appStart( '.submodules.update to:!dev2' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var got = a.moduleDownloadedShellSync( 'git status' )
    test.true( _.strHas( got.output, `HEAD detached at dev2` ) );
    let tagVersionLocal = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev2', local : 1, remote : 0 });
    let tagVersionRemote = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev2', local : 0, remote : 1 });
    test.identical( tagVersionLocal, tagVersionRemote );
    let willFileAftet = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    test.identical( willFileAftet, a.willFileBefore );
    return null;
  })

  /* - */

  a.init()
  .then( () =>
  {
    test.case = 'switch to dev3, dev1 was renamed to dev3 on the remote after download'
    let escapeCaret = process.platform === 'win32' ? '^' : '';
    a.moduleDownloadedShellSync( 'git fetch --tags' );
    a.moduleShellSync( `git tag dev3 dev1${ escapeCaret }^{}` );
    a.moduleShellSync( 'git tag -d dev1' );
    return null;
  });
  a.appStart( '.submodules.update to:!dev3' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var got = a.moduleDownloadedShellSync( 'git status' )
    test.true( _.strHas( got.output, `HEAD detached at dev3` ) );
    let tagVersionLocal = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev3', local : 1, remote : 0 });
    let tagVersionRemote = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev3', local : 0, remote : 1 });
    test.identical( tagVersionLocal, tagVersionRemote );
    let willFileAftet = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    test.identical( willFileAftet, a.willFileBefore );
    return null;
  })

  /* - */

  a.init()
  .then( () =>
  {
    test.case = 'switch to tag removed on remote after download'
    a.moduleDownloadedShellSync( 'git fetch --tags' )
    a.moduleShellSync( 'git tag -d dev1' )
    return null;
  });
  a.appStart( '.submodules.update to:!dev1' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    var got = a.moduleDownloadedShellSync( 'git status' )
    test.true( _.strHas( got.output, `HEAD detached at dev1` ) );
    let tagVersionLocal = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 1, remote : 0 });
    let tagVersionRemote = _.git.repositoryTagToVersion({ localPath : a.localPath, tag : 'dev1', local : 0, remote : 1 });
    var got = a.moduleDownloadedShellSync( 'git show-ref --tags -- dev1' )
    test.true( _.strHas( got.output, tagVersionLocal ) );
    test.identical( tagVersionRemote, false );
    let willFileAftet = a.fileProvider.fileRead( a.abs( '.will.yml' ) );
    test.identical( willFileAftet, a.willFileBefore );
    return null;
  });

  /* - */

  return a.ready;
}
commandSubmodulesUpdateOptionTo.rapidity = 1;
commandSubmodulesUpdateOptionTo.routineTimeOut = 300000;
commandSubmodulesUpdateOptionTo.description =
`
Checks if command tag:
 - Downloads new tags from the remote
 - Updates existing tag
 - Checkouts selected submodules to specific tag
`;

//

function commandSubmodulesUpdateSwitchToOutdatedBranch( test )
{
  let context = this;
  let a = context.assetFor( test, 'submodulesUpdateSwitchToOutdatedBranch' );

  a.shellSync = _.process.starter
  ({
    outputCollecting : 1,
    outputGraying : 1,
    throwingExitCode : 0,
    sync : 1,
    deasync : 0,
    ready : null
  })

  a.ready

  /* - */

  begin()
  a.shell( 'git clone repo .module/testrepo' )
  a.shell( 'git -C repo commit --allow-empty -m test2' )
  a.shell( 'git -C .module/testrepo checkout second' )
  .then( () =>
  {
    let currentBranch = _.git.localVersion( a.abs( '.module/testrepo' ) );
    return test.identical( currentBranch, 'second' );
  })
  a.appStart( '.submodules.update' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );

    test.true( _.strHas( op.output, 'module::testrepo was updated to version master' ) );

    let currentBranch = _.git.localVersion( a.abs( '.module/testrepo' ) );
    test.identical( currentBranch, 'master' );

    let remoteVersion = getHead( a.abs( 'repo' ) );
    let cloneVersion = getHead( a.abs( '.module/testrepo' ) );

    console.log( 'remote:', remoteVersion )
    console.log( 'updated clone:', cloneVersion )

    test.identical( remoteVersion, cloneVersion );

    return null;
  })

  /* - */

  return a.ready;

  function begin( testCase )
  {
    a.ready.then( () =>
    {
      if( testCase )
      test.case = testCase;

      a.reflect();

      let repoPath = a.abs( 'repo' );

      a.shellSync({ execPath : 'git init', currentPath : repoPath })
      a.shellSync({ execPath : 'git add -fA .', currentPath : repoPath })
      a.shellSync({ execPath : 'git commit --allow-empty -m init', currentPath : repoPath })
      a.shellSync({ execPath : 'git commit --allow-empty -m test', currentPath : repoPath })
      a.shellSync({ execPath : 'git branch second', currentPath : repoPath })
      a.shellSync({ execPath : 'git checkout master', currentPath : repoPath })

      return null;
    })
  }

  function getHead( localPath, branch )
  {
    if( !branch )
    branch = 'master';

    let result = a.shellSync
    ({
      execPath : `git show-ref refs/heads/${branch} --hash`,
      currentPath : localPath,
      outputPiping : 0,
      inputMirroring : 0,
      outputCollecting : 1
    })
    return result.output.trim();
  }
}

commandSubmodulesUpdateSwitchToOutdatedBranch.rapidity = 1;
commandSubmodulesUpdateSwitchToOutdatedBranch.routineTimeOut = 300000;
commandSubmodulesUpdateSwitchToOutdatedBranch.description =
`
Command switches submodule from second branch to outdated master.
Routine checks if master branch is updated after switch.
`;

//

function commandsSequenceProceduresTermination( test )
{
  let context = this;
  let a = context.assetFor( test, 'commandsSequenceProceduresTermination' );

  a.reflect();

  /* */

  a.appStart( '.submodules.update .build' )
  .then( ( op ) =>
  {
    test.identical( op.exitCode, 0 );
    test.false( _.strHas( op.output, `procedure::` ) );
    test.false( _.strHas( op.output, /Waiting for .* procedure\(s\)/ ) );
    test.true( _.strHas( op.output, `step::start` ) );
    test.true( _.strHas( op.output, `step::end` ) );
    return null;
  })

  /* - */

  return a.ready;
}

commandsSequenceProceduresTermination.rapidity = 1;
commandsSequenceProceduresTermination.routineTimeOut = 120000;
commandsSequenceProceduresTermination.description =
`
Runs two commands in sequence.
Second command executes long running step.
Routine checks that procedures termination begins after last command.
`

// --
// declare
// --

const Proto =
{

  name : 'Tools.Willbe.Ext',
  silencing : 1,

  onSuiteBegin,
  onSuiteEnd,
  onRoutineEnd, /* Dmytro : should reduce time of hardlinking for all suite test run */
  routineTimeOut : 300000,

  context :
  {
    suiteTempPath : null,
    assetsOriginalPath : null,
    appJsPath : null,
    repoDirPath : null,
    assetFor,
  },

  tests :
  {
    // etc

    etcPreCloneRepos,
    etcSingleModuleWithSpaceTrivial,
    etcWillFilterFieldsOverwrite,
    etcOldImportFileAdapt,

    // etcRunWillbe, // zzz : help to fix, please
    etcKillWillbe,
    etcRunDebugWill,

    // etcResourcesFormReflectorsExperiment, // xxx : look

    etcCommandsSeveral,
    etcRunCommandsOnDisabledModule,

    etcResolveDefaultBuilds,
    etcResolveBuildsLists,

    etcRunWithSubmodules,

    // build

    build,
    buildStepShellAndViewWithoutAbout,
    buildTranspile,
    buildTranspileWithOptions,
    buildTranspileExperiment,
    buildSingleModule,
    buildSingleStep,
    buildSubmodules,
    buildOptionWithSubmodules, /* xxx : fix */
    buildOptionWithSubmodulesExplicitRunOption,
    // buildDetached, /* xxx : later */

    //open

    openModuleWithLostSubmodule,

    openWith,
    openInDirWithUnderscore,
    openEach,

    // reflect

    reflectorOptionsCheck,
    reflectorOptionsCheckDefaultOptionsAndWithoutOptions,
    reflectorOptionsCheckWithoutOptionsAndDefaultOptions,
    reflectorOptionsCheckWithoutOptionsAndNotDefaultOptions,
    reflectNothingFromSubmodules,
    reflectGetPath,
    reflectSubdir,
    reflectSubmodulesWithBase,
    reflectComposite,
    reflectRemoteGit,
    reflectRemoteHttp,
    reflectWithOptions,
    reflectWithOptionDstRewriting,
    reflectWithOptionLinking,
    reflectorFromPredefinedWithOptions,
    reflectWithSelectorInDstFilter,
    reflectSubmodulesWithCriterion,
    reflectSubmodulesWithPluralCriterionManualExport,
    reflectSubmodulesWithPluralCriterionEmbeddedExport,
    reflectNpmModules,
    // relfectSubmodulesWithNotExistingFile, // zzz : uncomment after final transition to willbe
    reflectInherit,
    reflectInheritSubmodules,
    reflectComplexInherit,
    reflectorMasks,
    reflectorsCommonPrefix,
    reflectorOptionStep,
    reflectorOptionStepThrowing,

    // with do

    hookCommentOut,
    hookCallInfo,
    hookGitMake,
    // hookPrepare, /* xxx : uncomment it when TemplateFileWriter will be reimplemented, test write template for module */
    hookHlink,
    hookGitPull,
    hookGitPullConflict,
    hookGitPush,
    hookGitReset,
    hookGitSyncConflict,
    hookGitSyncRestoreHardLinksWithShared,
    hookGitSyncArguments,
    hookGitTag,
    hookWasPackageExtendWillfile,
    hookPublishCheckPackageJsonFormatting,
    // hookPublish2, /* Dmytro : hook was commented out */

    // output

    verbositySet,
    verbosityStepDelete,
    verbosityStepPrintName,

    modulesTreeDotless,
    modulesTreeLocal,
    modulesTreeHierarchyRemote,
    // modulesTreeHierarchyRemoteDownloaded, /* xxx : later */
    // modulesTreeHierarchyRemotePartiallyDownloaded, /* xxx : later */
    modulesTreeDisabledAndCorrupted,

    listSingleModule,
    listWithSubmodulesSimple,
    listWithSubmodules,

    // export

    /* xxx : write test routine exportOptionWithSubmodules */
    exportSingle,
    exportWithExistedGitRepository,
    exportItself,
    exportNonExportable,
    exportPurging, /* yyy */
    // exportStringrmal, /* xxx : later */
    exportWithReflector,
    exportToRoot,
    // exportMixed, /* xxx : later */
    exportSecond,
    exportSubmodules,
    exportMultiple,
    exportImportMultiple,
    exportBroken,
    exportDoc,
    exportImport,
    exportBrokenNoreflector,
    exportCourrputedOutfileUnknownSection,
    exportCourruptedOutfileSyntax,
    exportCourruptedSubmodulesDisabled,
    exportDisabledModule,
    exportOutdated,
    exportWholeModule,
    exportRecursive,
    exportRecursiveUsingSubmodule,
    exportRecursiveLocal,
    exportDotless,
    exportDotlessSingle,
    exportTracing,
    exportRewritesOutFile,
    exportWithRemoteSubmodulesMin,
    exportWithRemoteSubmodulesMinRecursive,
    exportWithRemoteSubmodules,
    exportWithRemoteSubmodulesRecursive,
    exportDiffDownloadPathsRegular,
    exportHierarchyRemote,
    exportWithDisabled,
    exportOutResourceWithoutGeneratedCriterion, /* xxx : qqq : for Dmytro : investigate */
    exportImplicit,
    /* xxx : implement same test for hierarchyRemote and irregular */
    /* xxx : implement clean tests */
    /* xxx : refactor ** clean */
    // exportAuto, // xxx : later
    exportOutdated2,
    exportWithSubmoduleThatHasModuleDirDeleted,
    exportWithoutSubSubModules,
    exportWithSubmoduleWithNotDownloadedSubmodule,
    exportMainIsGitRepository,
    exportTwoFirstIsDepOfSecond,
    exportWithOutdatedWillbe,
    exportCreatesOutDir,

    importPathLocal,
    // importLocalRepo, /* xxx : later */
    importOutWithDeletedSource,
    importOutdated,

    // clean

    clean,
    cleanOptionWithSubmodules,
    cleanSingleModule,
    cleanItself,
    cleanBroken1,
    cleanBroken2,
    cleanBrokenSubmodules,
    cleanHdBug,
    cleanNoBuild,
    cleanDry,
    cleanSubmodules,
    cleanMixed,
    cleanWithInPath,
    cleanRecursiveMin,
    cleanGlobMin,
    cleanRecursive,
    cleanDisabledModule,
    cleanHierarchyRemote,
    cleanHierarchyRemoteDry,
    cleanSubmodulesHierarchyRemote,
    cleanSubmodulesHierarchyRemoteDry,
    cleanSpecial,
    cleanSelfRefBug,

    // shell

    shellWithCriterion,
    shellVerbosity,
    shellQuotedCommand,

    // function

    functionStringsJoin,
    functionPlatform,
    functionThisCriterion,

    // submodules

    submodulesDownload,
    submodulesDownloadRecursiveGit,
    submodulesDownloadRecursiveNpm,
    submodulesDownloadRecursiveHd,

    submodulesDownloadSingle,
    submodulesDownloadEnabledAndDisabled,
    submodulesDownloadUpdate,
    submodulesDownloadUpdateDry,
    submodulesDownloadSwitchBranch,
    submodulesDownloadWithSubmodulesDefault,
    submodulesDownloadUpdateWithSubmodulesDefault,

    submodulesDownloadRecursive, /* aaa : for Dmytro : uncomment, normalize and fix */ /* Dmytro : done */
    submodulesDownloadThrowing,
    submodulesDownloadInvalidUrl,
    submodulesDownloadStepAndCommand,
    submodulesDownloadDiffDownloadPathsRegular,
    submodulesDownloadDiffDownloadPathsIrregular,
    submodulesDownloadHierarchyRemote,
    submodulesDownloadHierarchyDuplicate,
    submodulesDownloadNpm,
    submodulesDownloadUpdateNpm,
    submodulesDownloadAutoCrlfEnabled,
    // rootModuleRenormalization, /* xxx : check */

    submodulesUpdateThrowing,
    submodulesAgreeThrowing,
    submodulesVersionsAgreeWrongOrigin,
    submodulesDownloadedUpdate,
    subModulesUpdate,
    subModulesUpdateSwitchBranch,
    submodulesVerify,
    submodulesVerifyOutdatedBranch,
    submodulesVersionsAgree,
    submodulesVersionsAgreeNpm,

    // submodulesUpgradeDryDetached, // xxx : look later
    // submodulesUpgradeDetached, // xxx : look later
    // submodulesUpgradeDetachedExperiment, // xxx : look later
    // submodulesFixateDryDetached, // xxx : look later
    // submodulesFixateDetached, // xxx : look later

    // step

    stepSubmodulesDownload,
    stepSubmodulesUpdate,
    stepModulesUpdate,
    stepWillbeVersionCheck,
    stepVersionBump,
    stepVersionBumpCheckReset,
    stepSubmodulesAreUpdated,
    stepBuild,
    stepShellWithPathResolving,
    stepShellWithSeveralCommands,
    stepSourcesJoin,
    stepSourcesJoinRunInBrowser,
    stepSourcesJoinRunWithExts,
    stepNpmGenerate,
    stepNpmGenerateOptionsInStep,
    stepGitCheckHardLinkRestoring,
    stepGitDifferentCommands,
    stepGitPull,
    stepGitPush,
    stepGitReset,
    stepGitSync,
    stepGitStatus,
    stepGitTag,
    stepRepoReleaseRemote,
    stepView,

    /* xxx : cover "will .module.new.with prepare" */

    //command

    commandHelp,

    commandImplyWithDot,
    commandImplyWithAsterisk,

    commandImplyWithSubmodulesModulesList, /* qqq : test to cover imply + submodules.verify */

    commandImplyPropertyWithDisabled,
    commandImplyPropertyWithEnabled,

    commandBuildImply,
    commandBuildImplyWithSeveralSteps,

    commandVersion,
    commandVersionCheck,
    commandVersionBump,
    commandVersionBumpCheckReset,

    commandStepsList,

    commandModuleNewDotless,
    commandModuleNewDotlessSingle,
    commandModuleNewNamed,

    // commandWithMixed, /* xxx : later */
    commandWithList,

    // commandEachMixed, // xxx : later
    // commandEachList, // xxx : later
    commandEachBrokenIll,
    commandEachBrokenNon,
    commandEachBrokenCommand,

    commandHookCallWithHookInfo,
    commandDoWithHookStatus,

    commandSubmodulesClean,
    commandSubmodulesShell,
    commandSubmodulesGit,
    commandSubmodulesGitRemoteSubmodules,
    commandSubmodulesGitRemoteSubmodulesRecursive,
    commandSubmodulesGitDiff,
    commandSubmodulesGitStatusWithOnlyRoot,
    commandSubmodulesGitStatus,
    commandSubmodulesGitSync,

    commandSubmodulesRepoPullOpen,

    commandModulesUpdate,
    commandModulesShell,
    commandModulesGit,
    commandModulesGitOutputFormat,
    commandModulesGitRemoteSubmodules,
    commandModulesGitRemoteSubmodulesRecursive,
    commandModulesGitDiff,
    commandModulesGitDiffOutputFormat,
    commandModulesGitStatusWithOnlyRoot,
    commandModulesGitStatus,
    commandModulesGitStatusOutputFormat,
    commandModulesGitSync,
    commandModulesGitSyncRestoreHardLinksInModuleWithSuccess,
    commandModulesGitSyncRestoreHardLinksInModuleWithFail,
    commandModulesGitSyncRestoreHardLinksInModule,
    commandModulesGitSyncRestoreHardLinksInSubmodule,
    commandModules,
    commandSubmodules,

    commandModulesRepoPullOpen,

    commandGitCheckHardLinkRestoringThrowing,
    commandGitCheckHardLinkRestoring,
    commandGitDifferentCommands,
    commandGitDiff,
    commandGitPull,
    commandGitPullRestoreHardlinkOnFail,
    commandGitPush,
    commandGitReset,
    commandGitStatus,
    commandGitStatusWithPR,
    commandGitSync,
    commandGitSyncRestoringHardlinks,
    commandGitSyncRestoreHardLinksWithShared,
    commandGitTag,

    commandRepoPullOpen,
    commandRepoPullOpenRemote,
    commandRepoReleaseRemote,

    commandNpmFromWillfile,
    commandNpmFromWillfileOptionsInCommand,
    commandWillfileFromNpm,
    commandWillfileFromNpmDoubleConversion,

    commandWillfileGet,
    commandWillfileSet,
    commandWillfileDel,
    commandWillfileExtend,
    commandWillfileSupplement,

    commandWillfileExtendWillfileDstIsWillfile,
    commandWillfileExtendWillfileDstIsJson,
    commandWillfileExtendWillfileWithOptions,
    commandWillfileSupplementWillfileDstIsWillfile,
    commandWillfileSupplementWillfileDstIsJson,
    commandWillfileSupplementWillfileWithOptions,

    commandWillfileMergeIntoSingle,
    commandWillfileMergeIntoSingleRunWith,
    commandWillfileMergeIntoSingleWithSeveralRuns,
    commandWillfileMergeIntoSinglePrimaryPathIsDirectory,
    commandWillfileMergeIntoSingleWithDuplicatedSubmodules,
    commandWillfileMergeIntoSingleWithDiffSubmoduleRecord,
    commandWillfileMergeIntoSingleFilterNpmFields,

    commandNpmPublish,
    commandNpmPublishFullModuleFromUtility,
    commandNpmPublishFullRegularModule,
    commandNpmDepAdd,
    commandNpmInstall,
    commandNpmInstallFromPackageWithoutName,

    commandsSubmoduleSafety,
    commandsSubmoduleSafetyDownloadInvalidUrl,
    commandsSubmoduleSafetyVerifyInvalidUrl,
    commandSubmodulesUpdateOptionTo,
    commandSubmodulesUpdateSwitchToOutdatedBranch,

    commandsSequenceProceduresTermination,

    // etcWillFilterFieldsOverwrite,

  }

}

//

const Self = wTestSuite( Proto );
if( typeof module !== 'undefined' && !module.parent )
wTester.test( Self.name );

/* aaa : for Dmytro : remove -assets, discuss before removing! */ /* Dmytro : files with dash are generated in tests */

})();
